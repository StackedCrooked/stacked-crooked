// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: license.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "license.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* HardwareId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HardwareId_reflection_ = NULL;
const ::google::protobuf::Descriptor* Features_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Features_reflection_ = NULL;
const ::google::protobuf::Descriptor* Limits_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Limits_reflection_ = NULL;
const ::google::protobuf::Descriptor* License_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  License_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HardwareIdType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_license_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_license_2eproto() {
  protobuf_AddDesc_license_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "license.proto");
  GOOGLE_CHECK(file != NULL);
  HardwareId_descriptor_ = file->message_type(0);
  static const int HardwareId_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareId, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareId, value_),
  };
  HardwareId_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HardwareId_descriptor_,
      HardwareId::default_instance_,
      HardwareId_offsets_,
      -1,
      -1,
      -1,
      sizeof(HardwareId),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareId, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareId, _is_default_instance_));
  Features_descriptor_ = file->message_type(1);
  static const int Features_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, num_trunk_ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, num_nontrunk_ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, num_usb_ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, num_nbaset_ports_),
  };
  Features_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Features_descriptor_,
      Features::default_instance_,
      Features_offsets_,
      -1,
      -1,
      -1,
      sizeof(Features),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _is_default_instance_));
  Limits_descriptor_ = file->message_type(2);
  static const int Limits_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, seconds_assigned_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, seconds_consumed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, trialperiod_begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, trialperiod_end_),
  };
  Limits_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Limits_descriptor_,
      Limits::default_instance_,
      Limits_offsets_,
      -1,
      -1,
      -1,
      sizeof(Limits),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limits, _is_default_instance_));
  License_descriptor_ = file->message_type(3);
  static const int License_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, secure_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, hardware_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, features_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, limits_),
  };
  License_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      License_descriptor_,
      License::default_instance_,
      License_offsets_,
      -1,
      -1,
      -1,
      sizeof(License),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(License, _is_default_instance_));
  HardwareIdType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_license_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HardwareId_descriptor_, &HardwareId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Features_descriptor_, &Features::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Limits_descriptor_, &Limits::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      License_descriptor_, &License::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_license_2eproto() {
  delete HardwareId::default_instance_;
  delete HardwareId_reflection_;
  delete Features::default_instance_;
  delete Features_reflection_;
  delete Limits::default_instance_;
  delete Limits_reflection_;
  delete License::default_instance_;
  delete License_reflection_;
}

void protobuf_AddDesc_license_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_license_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rlicense.proto\":\n\nHardwareId\022\035\n\004type\030\001 "
    "\001(\0162\017.HardwareIdType\022\r\n\005value\030\002 \001(\014\"p\n\010F"
    "eatures\022\027\n\017num_trunk_ports\030\001 \001(\005\022\032\n\022num_"
    "nontrunk_ports\030\002 \001(\005\022\025\n\rnum_usb_ports\030\003 "
    "\001(\005\022\030\n\020num_nbaset_ports\030\004 \001(\005\"p\n\006Limits\022"
    "\030\n\020seconds_assigned\030\001 \001(\003\022\030\n\020seconds_con"
    "sumed\030\002 \001(\003\022\031\n\021trialperiod_begin\030\003 \001(\003\022\027"
    "\n\017trialperiod_end\030\004 \001(\003\"\207\001\n\007License\022\017\n\007v"
    "ersion\030\001 \001(\005\022\023\n\013secure_hash\030\002 \001(\014\022 \n\013har"
    "dware_id\030\003 \001(\0132\013.HardwareId\022\033\n\010features\030"
    "\004 \001(\0132\t.Features\022\027\n\006limits\030\005 \001(\0132\007.Limit"
    "s*9\n\016HardwareIdType\022\017\n\013MAC_ADDRESS\020\000\022\026\n\022"
    "MOTHERBOARD_SERIAL\020\001b\006proto3", 508);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "license.proto", &protobuf_RegisterTypes);
  HardwareId::default_instance_ = new HardwareId();
  Features::default_instance_ = new Features();
  Limits::default_instance_ = new Limits();
  License::default_instance_ = new License();
  HardwareId::default_instance_->InitAsDefaultInstance();
  Features::default_instance_->InitAsDefaultInstance();
  Limits::default_instance_->InitAsDefaultInstance();
  License::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_license_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_license_2eproto {
  StaticDescriptorInitializer_license_2eproto() {
    protobuf_AddDesc_license_2eproto();
  }
} static_descriptor_initializer_license_2eproto_;
const ::google::protobuf::EnumDescriptor* HardwareIdType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardwareIdType_descriptor_;
}
bool HardwareIdType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HardwareId::kTypeFieldNumber;
const int HardwareId::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HardwareId::HardwareId()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:HardwareId)
}

void HardwareId::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

HardwareId::HardwareId(const HardwareId& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HardwareId)
}

void HardwareId::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

HardwareId::~HardwareId() {
  // @@protoc_insertion_point(destructor:HardwareId)
  SharedDtor();
}

void HardwareId::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void HardwareId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HardwareId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardwareId_descriptor_;
}

const HardwareId& HardwareId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_license_2eproto();
  return *default_instance_;
}

HardwareId* HardwareId::default_instance_ = NULL;

HardwareId* HardwareId::New(::google::protobuf::Arena* arena) const {
  HardwareId* n = new HardwareId;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HardwareId::Clear() {
// @@protoc_insertion_point(message_clear_start:HardwareId)
  type_ = 0;
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HardwareId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:HardwareId)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .HardwareIdType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::HardwareIdType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional bytes value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HardwareId)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HardwareId)
  return false;
#undef DO_
}

void HardwareId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HardwareId)
  // optional .HardwareIdType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional bytes value = 2;
  if (this->value().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->value(), output);
  }

  // @@protoc_insertion_point(serialize_end:HardwareId)
}

::google::protobuf::uint8* HardwareId::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:HardwareId)
  // optional .HardwareIdType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional bytes value = 2;
  if (this->value().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->value(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:HardwareId)
  return target;
}

int HardwareId::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:HardwareId)
  int total_size = 0;

  // optional .HardwareIdType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional bytes value = 2;
  if (this->value().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->value());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardwareId::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:HardwareId)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HardwareId* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HardwareId>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:HardwareId)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:HardwareId)
    MergeFrom(*source);
  }
}

void HardwareId::MergeFrom(const HardwareId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HardwareId)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.value().size() > 0) {

    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
}

void HardwareId::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:HardwareId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HardwareId::CopyFrom(const HardwareId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HardwareId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardwareId::IsInitialized() const {

  return true;
}

void HardwareId::Swap(HardwareId* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HardwareId::InternalSwap(HardwareId* other) {
  std::swap(type_, other->type_);
  value_.Swap(&other->value_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HardwareId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HardwareId_descriptor_;
  metadata.reflection = HardwareId_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HardwareId

// optional .HardwareIdType type = 1;
void HardwareId::clear_type() {
  type_ = 0;
}
 ::HardwareIdType HardwareId::type() const {
  // @@protoc_insertion_point(field_get:HardwareId.type)
  return static_cast< ::HardwareIdType >(type_);
}
 void HardwareId::set_type(::HardwareIdType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:HardwareId.type)
}

// optional bytes value = 2;
void HardwareId::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& HardwareId::value() const {
  // @@protoc_insertion_point(field_get:HardwareId.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HardwareId::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HardwareId.value)
}
 void HardwareId::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HardwareId.value)
}
 void HardwareId::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HardwareId.value)
}
 ::std::string* HardwareId::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:HardwareId.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HardwareId::release_value() {
  // @@protoc_insertion_point(field_release:HardwareId.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HardwareId::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:HardwareId.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Features::kNumTrunkPortsFieldNumber;
const int Features::kNumNontrunkPortsFieldNumber;
const int Features::kNumUsbPortsFieldNumber;
const int Features::kNumNbasetPortsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Features::Features()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Features)
}

void Features::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Features::Features(const Features& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Features)
}

void Features::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  num_trunk_ports_ = 0;
  num_nontrunk_ports_ = 0;
  num_usb_ports_ = 0;
  num_nbaset_ports_ = 0;
}

Features::~Features() {
  // @@protoc_insertion_point(destructor:Features)
  SharedDtor();
}

void Features::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Features::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Features::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Features_descriptor_;
}

const Features& Features::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_license_2eproto();
  return *default_instance_;
}

Features* Features::default_instance_ = NULL;

Features* Features::New(::google::protobuf::Arena* arena) const {
  Features* n = new Features;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Features::Clear() {
// @@protoc_insertion_point(message_clear_start:Features)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Features, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Features*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(num_trunk_ports_, num_nbaset_ports_);

#undef ZR_HELPER_
#undef ZR_

}

bool Features::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Features)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_trunk_ports = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_trunk_ports_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num_nontrunk_ports;
        break;
      }

      // optional int32 num_nontrunk_ports = 2;
      case 2: {
        if (tag == 16) {
         parse_num_nontrunk_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_nontrunk_ports_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_num_usb_ports;
        break;
      }

      // optional int32 num_usb_ports = 3;
      case 3: {
        if (tag == 24) {
         parse_num_usb_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_usb_ports_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_num_nbaset_ports;
        break;
      }

      // optional int32 num_nbaset_ports = 4;
      case 4: {
        if (tag == 32) {
         parse_num_nbaset_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_nbaset_ports_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Features)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Features)
  return false;
#undef DO_
}

void Features::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Features)
  // optional int32 num_trunk_ports = 1;
  if (this->num_trunk_ports() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_trunk_ports(), output);
  }

  // optional int32 num_nontrunk_ports = 2;
  if (this->num_nontrunk_ports() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num_nontrunk_ports(), output);
  }

  // optional int32 num_usb_ports = 3;
  if (this->num_usb_ports() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_usb_ports(), output);
  }

  // optional int32 num_nbaset_ports = 4;
  if (this->num_nbaset_ports() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->num_nbaset_ports(), output);
  }

  // @@protoc_insertion_point(serialize_end:Features)
}

::google::protobuf::uint8* Features::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Features)
  // optional int32 num_trunk_ports = 1;
  if (this->num_trunk_ports() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->num_trunk_ports(), target);
  }

  // optional int32 num_nontrunk_ports = 2;
  if (this->num_nontrunk_ports() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->num_nontrunk_ports(), target);
  }

  // optional int32 num_usb_ports = 3;
  if (this->num_usb_ports() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num_usb_ports(), target);
  }

  // optional int32 num_nbaset_ports = 4;
  if (this->num_nbaset_ports() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->num_nbaset_ports(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Features)
  return target;
}

int Features::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Features)
  int total_size = 0;

  // optional int32 num_trunk_ports = 1;
  if (this->num_trunk_ports() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->num_trunk_ports());
  }

  // optional int32 num_nontrunk_ports = 2;
  if (this->num_nontrunk_ports() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->num_nontrunk_ports());
  }

  // optional int32 num_usb_ports = 3;
  if (this->num_usb_ports() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->num_usb_ports());
  }

  // optional int32 num_nbaset_ports = 4;
  if (this->num_nbaset_ports() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->num_nbaset_ports());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Features::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Features)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Features* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Features>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Features)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Features)
    MergeFrom(*source);
  }
}

void Features::MergeFrom(const Features& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Features)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.num_trunk_ports() != 0) {
    set_num_trunk_ports(from.num_trunk_ports());
  }
  if (from.num_nontrunk_ports() != 0) {
    set_num_nontrunk_ports(from.num_nontrunk_ports());
  }
  if (from.num_usb_ports() != 0) {
    set_num_usb_ports(from.num_usb_ports());
  }
  if (from.num_nbaset_ports() != 0) {
    set_num_nbaset_ports(from.num_nbaset_ports());
  }
}

void Features::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Features::CopyFrom(const Features& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Features::IsInitialized() const {

  return true;
}

void Features::Swap(Features* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Features::InternalSwap(Features* other) {
  std::swap(num_trunk_ports_, other->num_trunk_ports_);
  std::swap(num_nontrunk_ports_, other->num_nontrunk_ports_);
  std::swap(num_usb_ports_, other->num_usb_ports_);
  std::swap(num_nbaset_ports_, other->num_nbaset_ports_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Features::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Features_descriptor_;
  metadata.reflection = Features_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Features

// optional int32 num_trunk_ports = 1;
void Features::clear_num_trunk_ports() {
  num_trunk_ports_ = 0;
}
 ::google::protobuf::int32 Features::num_trunk_ports() const {
  // @@protoc_insertion_point(field_get:Features.num_trunk_ports)
  return num_trunk_ports_;
}
 void Features::set_num_trunk_ports(::google::protobuf::int32 value) {
  
  num_trunk_ports_ = value;
  // @@protoc_insertion_point(field_set:Features.num_trunk_ports)
}

// optional int32 num_nontrunk_ports = 2;
void Features::clear_num_nontrunk_ports() {
  num_nontrunk_ports_ = 0;
}
 ::google::protobuf::int32 Features::num_nontrunk_ports() const {
  // @@protoc_insertion_point(field_get:Features.num_nontrunk_ports)
  return num_nontrunk_ports_;
}
 void Features::set_num_nontrunk_ports(::google::protobuf::int32 value) {
  
  num_nontrunk_ports_ = value;
  // @@protoc_insertion_point(field_set:Features.num_nontrunk_ports)
}

// optional int32 num_usb_ports = 3;
void Features::clear_num_usb_ports() {
  num_usb_ports_ = 0;
}
 ::google::protobuf::int32 Features::num_usb_ports() const {
  // @@protoc_insertion_point(field_get:Features.num_usb_ports)
  return num_usb_ports_;
}
 void Features::set_num_usb_ports(::google::protobuf::int32 value) {
  
  num_usb_ports_ = value;
  // @@protoc_insertion_point(field_set:Features.num_usb_ports)
}

// optional int32 num_nbaset_ports = 4;
void Features::clear_num_nbaset_ports() {
  num_nbaset_ports_ = 0;
}
 ::google::protobuf::int32 Features::num_nbaset_ports() const {
  // @@protoc_insertion_point(field_get:Features.num_nbaset_ports)
  return num_nbaset_ports_;
}
 void Features::set_num_nbaset_ports(::google::protobuf::int32 value) {
  
  num_nbaset_ports_ = value;
  // @@protoc_insertion_point(field_set:Features.num_nbaset_ports)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Limits::kSecondsAssignedFieldNumber;
const int Limits::kSecondsConsumedFieldNumber;
const int Limits::kTrialperiodBeginFieldNumber;
const int Limits::kTrialperiodEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Limits::Limits()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Limits)
}

void Limits::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Limits::Limits(const Limits& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Limits)
}

void Limits::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  seconds_assigned_ = GOOGLE_LONGLONG(0);
  seconds_consumed_ = GOOGLE_LONGLONG(0);
  trialperiod_begin_ = GOOGLE_LONGLONG(0);
  trialperiod_end_ = GOOGLE_LONGLONG(0);
}

Limits::~Limits() {
  // @@protoc_insertion_point(destructor:Limits)
  SharedDtor();
}

void Limits::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Limits::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Limits::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Limits_descriptor_;
}

const Limits& Limits::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_license_2eproto();
  return *default_instance_;
}

Limits* Limits::default_instance_ = NULL;

Limits* Limits::New(::google::protobuf::Arena* arena) const {
  Limits* n = new Limits;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Limits::Clear() {
// @@protoc_insertion_point(message_clear_start:Limits)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Limits, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Limits*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(seconds_assigned_, trialperiod_end_);

#undef ZR_HELPER_
#undef ZR_

}

bool Limits::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Limits)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 seconds_assigned = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seconds_assigned_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seconds_consumed;
        break;
      }

      // optional int64 seconds_consumed = 2;
      case 2: {
        if (tag == 16) {
         parse_seconds_consumed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seconds_consumed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_trialperiod_begin;
        break;
      }

      // optional int64 trialperiod_begin = 3;
      case 3: {
        if (tag == 24) {
         parse_trialperiod_begin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &trialperiod_begin_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_trialperiod_end;
        break;
      }

      // optional int64 trialperiod_end = 4;
      case 4: {
        if (tag == 32) {
         parse_trialperiod_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &trialperiod_end_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Limits)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Limits)
  return false;
#undef DO_
}

void Limits::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Limits)
  // optional int64 seconds_assigned = 1;
  if (this->seconds_assigned() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds_assigned(), output);
  }

  // optional int64 seconds_consumed = 2;
  if (this->seconds_consumed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->seconds_consumed(), output);
  }

  // optional int64 trialperiod_begin = 3;
  if (this->trialperiod_begin() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->trialperiod_begin(), output);
  }

  // optional int64 trialperiod_end = 4;
  if (this->trialperiod_end() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->trialperiod_end(), output);
  }

  // @@protoc_insertion_point(serialize_end:Limits)
}

::google::protobuf::uint8* Limits::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Limits)
  // optional int64 seconds_assigned = 1;
  if (this->seconds_assigned() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->seconds_assigned(), target);
  }

  // optional int64 seconds_consumed = 2;
  if (this->seconds_consumed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->seconds_consumed(), target);
  }

  // optional int64 trialperiod_begin = 3;
  if (this->trialperiod_begin() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->trialperiod_begin(), target);
  }

  // optional int64 trialperiod_end = 4;
  if (this->trialperiod_end() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->trialperiod_end(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Limits)
  return target;
}

int Limits::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Limits)
  int total_size = 0;

  // optional int64 seconds_assigned = 1;
  if (this->seconds_assigned() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds_assigned());
  }

  // optional int64 seconds_consumed = 2;
  if (this->seconds_consumed() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds_consumed());
  }

  // optional int64 trialperiod_begin = 3;
  if (this->trialperiod_begin() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->trialperiod_begin());
  }

  // optional int64 trialperiod_end = 4;
  if (this->trialperiod_end() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->trialperiod_end());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limits::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Limits)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Limits* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Limits>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Limits)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Limits)
    MergeFrom(*source);
  }
}

void Limits::MergeFrom(const Limits& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Limits)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.seconds_assigned() != 0) {
    set_seconds_assigned(from.seconds_assigned());
  }
  if (from.seconds_consumed() != 0) {
    set_seconds_consumed(from.seconds_consumed());
  }
  if (from.trialperiod_begin() != 0) {
    set_trialperiod_begin(from.trialperiod_begin());
  }
  if (from.trialperiod_end() != 0) {
    set_trialperiod_end(from.trialperiod_end());
  }
}

void Limits::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Limits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limits::CopyFrom(const Limits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Limits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limits::IsInitialized() const {

  return true;
}

void Limits::Swap(Limits* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Limits::InternalSwap(Limits* other) {
  std::swap(seconds_assigned_, other->seconds_assigned_);
  std::swap(seconds_consumed_, other->seconds_consumed_);
  std::swap(trialperiod_begin_, other->trialperiod_begin_);
  std::swap(trialperiod_end_, other->trialperiod_end_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Limits::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Limits_descriptor_;
  metadata.reflection = Limits_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Limits

// optional int64 seconds_assigned = 1;
void Limits::clear_seconds_assigned() {
  seconds_assigned_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 Limits::seconds_assigned() const {
  // @@protoc_insertion_point(field_get:Limits.seconds_assigned)
  return seconds_assigned_;
}
 void Limits::set_seconds_assigned(::google::protobuf::int64 value) {
  
  seconds_assigned_ = value;
  // @@protoc_insertion_point(field_set:Limits.seconds_assigned)
}

// optional int64 seconds_consumed = 2;
void Limits::clear_seconds_consumed() {
  seconds_consumed_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 Limits::seconds_consumed() const {
  // @@protoc_insertion_point(field_get:Limits.seconds_consumed)
  return seconds_consumed_;
}
 void Limits::set_seconds_consumed(::google::protobuf::int64 value) {
  
  seconds_consumed_ = value;
  // @@protoc_insertion_point(field_set:Limits.seconds_consumed)
}

// optional int64 trialperiod_begin = 3;
void Limits::clear_trialperiod_begin() {
  trialperiod_begin_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 Limits::trialperiod_begin() const {
  // @@protoc_insertion_point(field_get:Limits.trialperiod_begin)
  return trialperiod_begin_;
}
 void Limits::set_trialperiod_begin(::google::protobuf::int64 value) {
  
  trialperiod_begin_ = value;
  // @@protoc_insertion_point(field_set:Limits.trialperiod_begin)
}

// optional int64 trialperiod_end = 4;
void Limits::clear_trialperiod_end() {
  trialperiod_end_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 Limits::trialperiod_end() const {
  // @@protoc_insertion_point(field_get:Limits.trialperiod_end)
  return trialperiod_end_;
}
 void Limits::set_trialperiod_end(::google::protobuf::int64 value) {
  
  trialperiod_end_ = value;
  // @@protoc_insertion_point(field_set:Limits.trialperiod_end)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int License::kVersionFieldNumber;
const int License::kSecureHashFieldNumber;
const int License::kHardwareIdFieldNumber;
const int License::kFeaturesFieldNumber;
const int License::kLimitsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

License::License()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:License)
}

void License::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  hardware_id_ = const_cast< ::HardwareId*>(&::HardwareId::default_instance());
  features_ = const_cast< ::Features*>(&::Features::default_instance());
  limits_ = const_cast< ::Limits*>(&::Limits::default_instance());
}

License::License(const License& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:License)
}

void License::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 0;
  secure_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_id_ = NULL;
  features_ = NULL;
  limits_ = NULL;
}

License::~License() {
  // @@protoc_insertion_point(destructor:License)
  SharedDtor();
}

void License::SharedDtor() {
  secure_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete hardware_id_;
    delete features_;
    delete limits_;
  }
}

void License::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* License::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return License_descriptor_;
}

const License& License::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_license_2eproto();
  return *default_instance_;
}

License* License::default_instance_ = NULL;

License* License::New(::google::protobuf::Arena* arena) const {
  License* n = new License;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void License::Clear() {
// @@protoc_insertion_point(message_clear_start:License)
  version_ = 0;
  secure_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && hardware_id_ != NULL) delete hardware_id_;
  hardware_id_ = NULL;
  if (GetArenaNoVirtual() == NULL && features_ != NULL) delete features_;
  features_ = NULL;
  if (GetArenaNoVirtual() == NULL && limits_ != NULL) delete limits_;
  limits_ = NULL;
}

bool License::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:License)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_secure_hash;
        break;
      }

      // optional bytes secure_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_secure_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_secure_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_hardware_id;
        break;
      }

      // optional .HardwareId hardware_id = 3;
      case 3: {
        if (tag == 26) {
         parse_hardware_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hardware_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_features;
        break;
      }

      // optional .Features features = 4;
      case 4: {
        if (tag == 34) {
         parse_features:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_features()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_limits;
        break;
      }

      // optional .Limits limits = 5;
      case 5: {
        if (tag == 42) {
         parse_limits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:License)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:License)
  return false;
#undef DO_
}

void License::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:License)
  // optional int32 version = 1;
  if (this->version() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // optional bytes secure_hash = 2;
  if (this->secure_hash().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->secure_hash(), output);
  }

  // optional .HardwareId hardware_id = 3;
  if (this->has_hardware_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->hardware_id_, output);
  }

  // optional .Features features = 4;
  if (this->has_features()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->features_, output);
  }

  // optional .Limits limits = 5;
  if (this->has_limits()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->limits_, output);
  }

  // @@protoc_insertion_point(serialize_end:License)
}

::google::protobuf::uint8* License::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:License)
  // optional int32 version = 1;
  if (this->version() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  // optional bytes secure_hash = 2;
  if (this->secure_hash().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->secure_hash(), target);
  }

  // optional .HardwareId hardware_id = 3;
  if (this->has_hardware_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->hardware_id_, false, target);
  }

  // optional .Features features = 4;
  if (this->has_features()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->features_, false, target);
  }

  // optional .Limits limits = 5;
  if (this->has_limits()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->limits_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:License)
  return target;
}

int License::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:License)
  int total_size = 0;

  // optional int32 version = 1;
  if (this->version() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());
  }

  // optional bytes secure_hash = 2;
  if (this->secure_hash().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->secure_hash());
  }

  // optional .HardwareId hardware_id = 3;
  if (this->has_hardware_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->hardware_id_);
  }

  // optional .Features features = 4;
  if (this->has_features()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->features_);
  }

  // optional .Limits limits = 5;
  if (this->has_limits()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->limits_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void License::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:License)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const License* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const License>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:License)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:License)
    MergeFrom(*source);
  }
}

void License::MergeFrom(const License& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:License)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.version() != 0) {
    set_version(from.version());
  }
  if (from.secure_hash().size() > 0) {

    secure_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.secure_hash_);
  }
  if (from.has_hardware_id()) {
    mutable_hardware_id()->::HardwareId::MergeFrom(from.hardware_id());
  }
  if (from.has_features()) {
    mutable_features()->::Features::MergeFrom(from.features());
  }
  if (from.has_limits()) {
    mutable_limits()->::Limits::MergeFrom(from.limits());
  }
}

void License::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:License)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void License::CopyFrom(const License& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:License)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool License::IsInitialized() const {

  return true;
}

void License::Swap(License* other) {
  if (other == this) return;
  InternalSwap(other);
}
void License::InternalSwap(License* other) {
  std::swap(version_, other->version_);
  secure_hash_.Swap(&other->secure_hash_);
  std::swap(hardware_id_, other->hardware_id_);
  std::swap(features_, other->features_);
  std::swap(limits_, other->limits_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata License::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = License_descriptor_;
  metadata.reflection = License_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// License

// optional int32 version = 1;
void License::clear_version() {
  version_ = 0;
}
 ::google::protobuf::int32 License::version() const {
  // @@protoc_insertion_point(field_get:License.version)
  return version_;
}
 void License::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:License.version)
}

// optional bytes secure_hash = 2;
void License::clear_secure_hash() {
  secure_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& License::secure_hash() const {
  // @@protoc_insertion_point(field_get:License.secure_hash)
  return secure_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void License::set_secure_hash(const ::std::string& value) {
  
  secure_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:License.secure_hash)
}
 void License::set_secure_hash(const char* value) {
  
  secure_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:License.secure_hash)
}
 void License::set_secure_hash(const void* value, size_t size) {
  
  secure_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:License.secure_hash)
}
 ::std::string* License::mutable_secure_hash() {
  
  // @@protoc_insertion_point(field_mutable:License.secure_hash)
  return secure_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* License::release_secure_hash() {
  // @@protoc_insertion_point(field_release:License.secure_hash)
  
  return secure_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void License::set_allocated_secure_hash(::std::string* secure_hash) {
  if (secure_hash != NULL) {
    
  } else {
    
  }
  secure_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secure_hash);
  // @@protoc_insertion_point(field_set_allocated:License.secure_hash)
}

// optional .HardwareId hardware_id = 3;
bool License::has_hardware_id() const {
  return !_is_default_instance_ && hardware_id_ != NULL;
}
void License::clear_hardware_id() {
  if (GetArenaNoVirtual() == NULL && hardware_id_ != NULL) delete hardware_id_;
  hardware_id_ = NULL;
}
const ::HardwareId& License::hardware_id() const {
  // @@protoc_insertion_point(field_get:License.hardware_id)
  return hardware_id_ != NULL ? *hardware_id_ : *default_instance_->hardware_id_;
}
::HardwareId* License::mutable_hardware_id() {
  
  if (hardware_id_ == NULL) {
    hardware_id_ = new ::HardwareId;
  }
  // @@protoc_insertion_point(field_mutable:License.hardware_id)
  return hardware_id_;
}
::HardwareId* License::release_hardware_id() {
  // @@protoc_insertion_point(field_release:License.hardware_id)
  
  ::HardwareId* temp = hardware_id_;
  hardware_id_ = NULL;
  return temp;
}
void License::set_allocated_hardware_id(::HardwareId* hardware_id) {
  delete hardware_id_;
  hardware_id_ = hardware_id;
  if (hardware_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:License.hardware_id)
}

// optional .Features features = 4;
bool License::has_features() const {
  return !_is_default_instance_ && features_ != NULL;
}
void License::clear_features() {
  if (GetArenaNoVirtual() == NULL && features_ != NULL) delete features_;
  features_ = NULL;
}
const ::Features& License::features() const {
  // @@protoc_insertion_point(field_get:License.features)
  return features_ != NULL ? *features_ : *default_instance_->features_;
}
::Features* License::mutable_features() {
  
  if (features_ == NULL) {
    features_ = new ::Features;
  }
  // @@protoc_insertion_point(field_mutable:License.features)
  return features_;
}
::Features* License::release_features() {
  // @@protoc_insertion_point(field_release:License.features)
  
  ::Features* temp = features_;
  features_ = NULL;
  return temp;
}
void License::set_allocated_features(::Features* features) {
  delete features_;
  features_ = features;
  if (features) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:License.features)
}

// optional .Limits limits = 5;
bool License::has_limits() const {
  return !_is_default_instance_ && limits_ != NULL;
}
void License::clear_limits() {
  if (GetArenaNoVirtual() == NULL && limits_ != NULL) delete limits_;
  limits_ = NULL;
}
const ::Limits& License::limits() const {
  // @@protoc_insertion_point(field_get:License.limits)
  return limits_ != NULL ? *limits_ : *default_instance_->limits_;
}
::Limits* License::mutable_limits() {
  
  if (limits_ == NULL) {
    limits_ = new ::Limits;
  }
  // @@protoc_insertion_point(field_mutable:License.limits)
  return limits_;
}
::Limits* License::release_limits() {
  // @@protoc_insertion_point(field_release:License.limits)
  
  ::Limits* temp = limits_;
  limits_ = NULL;
  return temp;
}
void License::set_allocated_limits(::Limits* limits) {
  delete limits_;
  limits_ = limits;
  if (limits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:License.limits)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
