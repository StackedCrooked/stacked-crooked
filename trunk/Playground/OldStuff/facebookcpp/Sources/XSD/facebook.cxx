// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "facebook.hxx"

namespace FacebookCpp
{
  namespace XSD
  {
    // container
    // 


    // aid
    // 


    // pid
    // 


    // eid
    // 


    // gid
    // 


    // nid
    // 


    // hsid
    // 


    // uid
    // 


    // flid
    // 


    // id
    // 


    // lid
    // 


    // page_id
    // 


    // old_id_list
    // 


    // aid_list
    // 


    // pid_list
    // 


    // gid_list
    // 


    // eid_list
    // 


    // uid_list
    // 


    // field_list
    // 


    // tag_list
    // 


    // lid_list
    // 


    // pageid_list
    // 


    // time
    // 


    // date
    // 


    // year
    // 


    // auth_token
    // 


    // session_key
    // 


    // friend_link
    // 


    // member_type
    // 


    // old_id
    // 


    // marketplace_category
    // 


    // marketplace_subcategory
    // 


    // json_string
    // 


    // concentration
    // 


    // sex
    // 


    // seeking
    // 


    // user_status
    // 

    const user_status::message_type& user_status::
    message () const
    {
      return this->message_.get ();
    }

    user_status::message_type& user_status::
    message ()
    {
      return this->message_.get ();
    }

    void user_status::
    message (const message_type& x)
    {
      this->message_.set (x);
    }

    void user_status::
    message (::std::auto_ptr< message_type > x)
    {
      this->message_.set (x);
    }

    const user_status::time_type& user_status::
    time () const
    {
      return this->time_.get ();
    }

    user_status::time_type& user_status::
    time ()
    {
      return this->time_.get ();
    }

    void user_status::
    time (const time_type& x)
    {
      this->time_.set (x);
    }

    void user_status::
    time (::std::auto_ptr< time_type > x)
    {
      this->time_.set (x);
    }


    // id_map
    // 

    const id_map::old_id_type& id_map::
    old_id () const
    {
      return this->old_id_.get ();
    }

    id_map::old_id_type& id_map::
    old_id ()
    {
      return this->old_id_.get ();
    }

    void id_map::
    old_id (const old_id_type& x)
    {
      this->old_id_.set (x);
    }

    void id_map::
    old_id (::std::auto_ptr< old_id_type > x)
    {
      this->old_id_.set (x);
    }

    const id_map::new_id_type& id_map::
    new_id () const
    {
      return this->new_id_.get ();
    }

    id_map::new_id_type& id_map::
    new_id ()
    {
      return this->new_id_.get ();
    }

    void id_map::
    new_id (const new_id_type& x)
    {
      this->new_id_.set (x);
    }

    void id_map::
    new_id (::std::auto_ptr< new_id_type > x)
    {
      this->new_id_.set (x);
    }


    // arg
    // 

    const arg::key_type& arg::
    key () const
    {
      return this->key_.get ();
    }

    arg::key_type& arg::
    key ()
    {
      return this->key_.get ();
    }

    void arg::
    key (const key_type& x)
    {
      this->key_.set (x);
    }

    void arg::
    key (::std::auto_ptr< key_type > x)
    {
      this->key_.set (x);
    }

    const arg::value_type& arg::
    value () const
    {
      return this->value_.get ();
    }

    arg::value_type& arg::
    value ()
    {
      return this->value_.get ();
    }

    void arg::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void arg::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // FacebookApiException
    // 

    const FacebookApiException::error_code_type& FacebookApiException::
    error_code () const
    {
      return this->error_code_.get ();
    }

    FacebookApiException::error_code_type& FacebookApiException::
    error_code ()
    {
      return this->error_code_.get ();
    }

    void FacebookApiException::
    error_code (const error_code_type& x)
    {
      this->error_code_.set (x);
    }

    const FacebookApiException::error_msg_type& FacebookApiException::
    error_msg () const
    {
      return this->error_msg_.get ();
    }

    FacebookApiException::error_msg_type& FacebookApiException::
    error_msg ()
    {
      return this->error_msg_.get ();
    }

    void FacebookApiException::
    error_msg (const error_msg_type& x)
    {
      this->error_msg_.set (x);
    }

    void FacebookApiException::
    error_msg (::std::auto_ptr< error_msg_type > x)
    {
      this->error_msg_.set (x);
    }

    const FacebookApiException::request_args_type& FacebookApiException::
    request_args () const
    {
      return this->request_args_.get ();
    }

    FacebookApiException::request_args_type& FacebookApiException::
    request_args ()
    {
      return this->request_args_.get ();
    }

    void FacebookApiException::
    request_args (const request_args_type& x)
    {
      this->request_args_.set (x);
    }

    void FacebookApiException::
    request_args (::std::auto_ptr< request_args_type > x)
    {
      this->request_args_.set (x);
    }


    // session_info
    // 

    const session_info::session_key_type& session_info::
    session_key () const
    {
      return this->session_key_.get ();
    }

    session_info::session_key_type& session_info::
    session_key ()
    {
      return this->session_key_.get ();
    }

    void session_info::
    session_key (const session_key_type& x)
    {
      this->session_key_.set (x);
    }

    void session_info::
    session_key (::std::auto_ptr< session_key_type > x)
    {
      this->session_key_.set (x);
    }

    const session_info::uid_type& session_info::
    uid () const
    {
      return this->uid_.get ();
    }

    session_info::uid_type& session_info::
    uid ()
    {
      return this->uid_.get ();
    }

    void session_info::
    uid (const uid_type& x)
    {
      this->uid_.set (x);
    }

    void session_info::
    uid (::std::auto_ptr< uid_type > x)
    {
      this->uid_.set (x);
    }

    const session_info::expires_type& session_info::
    expires () const
    {
      return this->expires_.get ();
    }

    session_info::expires_type& session_info::
    expires ()
    {
      return this->expires_.get ();
    }

    void session_info::
    expires (const expires_type& x)
    {
      this->expires_.set (x);
    }

    const session_info::secret_optional& session_info::
    secret () const
    {
      return this->secret_;
    }

    session_info::secret_optional& session_info::
    secret ()
    {
      return this->secret_;
    }

    void session_info::
    secret (const secret_type& x)
    {
      this->secret_.set (x);
    }

    void session_info::
    secret (const secret_optional& x)
    {
      this->secret_ = x;
    }

    void session_info::
    secret (::std::auto_ptr< secret_type > x)
    {
      this->secret_.set (x);
    }


    // location
    // 

    const location::street_optional& location::
    street () const
    {
      return this->street_;
    }

    location::street_optional& location::
    street ()
    {
      return this->street_;
    }

    void location::
    street (const street_type& x)
    {
      this->street_.set (x);
    }

    void location::
    street (const street_optional& x)
    {
      this->street_ = x;
    }

    void location::
    street (::std::auto_ptr< street_type > x)
    {
      this->street_.set (x);
    }

    const location::city_optional& location::
    city () const
    {
      return this->city_;
    }

    location::city_optional& location::
    city ()
    {
      return this->city_;
    }

    void location::
    city (const city_type& x)
    {
      this->city_.set (x);
    }

    void location::
    city (const city_optional& x)
    {
      this->city_ = x;
    }

    void location::
    city (::std::auto_ptr< city_type > x)
    {
      this->city_.set (x);
    }

    const location::state_optional& location::
    state () const
    {
      return this->state_;
    }

    location::state_optional& location::
    state ()
    {
      return this->state_;
    }

    void location::
    state (const state_type& x)
    {
      this->state_.set (x);
    }

    void location::
    state (const state_optional& x)
    {
      this->state_ = x;
    }

    void location::
    state (::std::auto_ptr< state_type > x)
    {
      this->state_.set (x);
    }

    const location::country_optional& location::
    country () const
    {
      return this->country_;
    }

    location::country_optional& location::
    country ()
    {
      return this->country_;
    }

    void location::
    country (const country_type& x)
    {
      this->country_.set (x);
    }

    void location::
    country (const country_optional& x)
    {
      this->country_ = x;
    }

    void location::
    country (::std::auto_ptr< country_type > x)
    {
      this->country_.set (x);
    }

    const location::zip_optional& location::
    zip () const
    {
      return this->zip_;
    }

    location::zip_optional& location::
    zip ()
    {
      return this->zip_;
    }

    void location::
    zip (const zip_type& x)
    {
      this->zip_.set (x);
    }

    void location::
    zip (const zip_optional& x)
    {
      this->zip_ = x;
    }

    void location::
    zip (::std::auto_ptr< zip_type > x)
    {
      this->zip_.set (x);
    }

    const location::latitude_optional& location::
    latitude () const
    {
      return this->latitude_;
    }

    location::latitude_optional& location::
    latitude ()
    {
      return this->latitude_;
    }

    void location::
    latitude (const latitude_type& x)
    {
      this->latitude_.set (x);
    }

    void location::
    latitude (const latitude_optional& x)
    {
      this->latitude_ = x;
    }

    const location::longitude_optional& location::
    longitude () const
    {
      return this->longitude_;
    }

    location::longitude_optional& location::
    longitude ()
    {
      return this->longitude_;
    }

    void location::
    longitude (const longitude_type& x)
    {
      this->longitude_.set (x);
    }

    void location::
    longitude (const longitude_optional& x)
    {
      this->longitude_ = x;
    }


    // event
    // 

    const event::eid_type& event::
    eid () const
    {
      return this->eid_.get ();
    }

    event::eid_type& event::
    eid ()
    {
      return this->eid_.get ();
    }

    void event::
    eid (const eid_type& x)
    {
      this->eid_.set (x);
    }

    void event::
    eid (::std::auto_ptr< eid_type > x)
    {
      this->eid_.set (x);
    }

    const event::name_type& event::
    name () const
    {
      return this->name_.get ();
    }

    event::name_type& event::
    name ()
    {
      return this->name_.get ();
    }

    void event::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void event::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const event::tagline_type& event::
    tagline () const
    {
      return this->tagline_.get ();
    }

    event::tagline_type& event::
    tagline ()
    {
      return this->tagline_.get ();
    }

    void event::
    tagline (const tagline_type& x)
    {
      this->tagline_.set (x);
    }

    void event::
    tagline (::std::auto_ptr< tagline_type > x)
    {
      this->tagline_.set (x);
    }

    const event::nid_type& event::
    nid () const
    {
      return this->nid_.get ();
    }

    event::nid_type& event::
    nid ()
    {
      return this->nid_.get ();
    }

    void event::
    nid (const nid_type& x)
    {
      this->nid_.set (x);
    }

    void event::
    nid (::std::auto_ptr< nid_type > x)
    {
      this->nid_.set (x);
    }

    const event::pic_type& event::
    pic () const
    {
      return this->pic_.get ();
    }

    event::pic_type& event::
    pic ()
    {
      return this->pic_.get ();
    }

    void event::
    pic (const pic_type& x)
    {
      this->pic_.set (x);
    }

    void event::
    pic (::std::auto_ptr< pic_type > x)
    {
      this->pic_.set (x);
    }

    const event::pic_big_type& event::
    pic_big () const
    {
      return this->pic_big_.get ();
    }

    event::pic_big_type& event::
    pic_big ()
    {
      return this->pic_big_.get ();
    }

    void event::
    pic_big (const pic_big_type& x)
    {
      this->pic_big_.set (x);
    }

    void event::
    pic_big (::std::auto_ptr< pic_big_type > x)
    {
      this->pic_big_.set (x);
    }

    const event::pic_small_type& event::
    pic_small () const
    {
      return this->pic_small_.get ();
    }

    event::pic_small_type& event::
    pic_small ()
    {
      return this->pic_small_.get ();
    }

    void event::
    pic_small (const pic_small_type& x)
    {
      this->pic_small_.set (x);
    }

    void event::
    pic_small (::std::auto_ptr< pic_small_type > x)
    {
      this->pic_small_.set (x);
    }

    const event::host_type& event::
    host () const
    {
      return this->host_.get ();
    }

    event::host_type& event::
    host ()
    {
      return this->host_.get ();
    }

    void event::
    host (const host_type& x)
    {
      this->host_.set (x);
    }

    void event::
    host (::std::auto_ptr< host_type > x)
    {
      this->host_.set (x);
    }

    const event::description_type& event::
    description () const
    {
      return this->description_.get ();
    }

    event::description_type& event::
    description ()
    {
      return this->description_.get ();
    }

    void event::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void event::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const event::event_type_type& event::
    event_type () const
    {
      return this->event_type_.get ();
    }

    event::event_type_type& event::
    event_type ()
    {
      return this->event_type_.get ();
    }

    void event::
    event_type (const event_type_type& x)
    {
      this->event_type_.set (x);
    }

    void event::
    event_type (::std::auto_ptr< event_type_type > x)
    {
      this->event_type_.set (x);
    }

    const event::event_subtype_type& event::
    event_subtype () const
    {
      return this->event_subtype_.get ();
    }

    event::event_subtype_type& event::
    event_subtype ()
    {
      return this->event_subtype_.get ();
    }

    void event::
    event_subtype (const event_subtype_type& x)
    {
      this->event_subtype_.set (x);
    }

    void event::
    event_subtype (::std::auto_ptr< event_subtype_type > x)
    {
      this->event_subtype_.set (x);
    }

    const event::start_time_type& event::
    start_time () const
    {
      return this->start_time_.get ();
    }

    event::start_time_type& event::
    start_time ()
    {
      return this->start_time_.get ();
    }

    void event::
    start_time (const start_time_type& x)
    {
      this->start_time_.set (x);
    }

    void event::
    start_time (::std::auto_ptr< start_time_type > x)
    {
      this->start_time_.set (x);
    }

    const event::end_time_type& event::
    end_time () const
    {
      return this->end_time_.get ();
    }

    event::end_time_type& event::
    end_time ()
    {
      return this->end_time_.get ();
    }

    void event::
    end_time (const end_time_type& x)
    {
      this->end_time_.set (x);
    }

    void event::
    end_time (::std::auto_ptr< end_time_type > x)
    {
      this->end_time_.set (x);
    }

    const event::creator_type& event::
    creator () const
    {
      return this->creator_.get ();
    }

    event::creator_type& event::
    creator ()
    {
      return this->creator_.get ();
    }

    void event::
    creator (const creator_type& x)
    {
      this->creator_.set (x);
    }

    void event::
    creator (::std::auto_ptr< creator_type > x)
    {
      this->creator_.set (x);
    }

    const event::update_time_type& event::
    update_time () const
    {
      return this->update_time_.get ();
    }

    event::update_time_type& event::
    update_time ()
    {
      return this->update_time_.get ();
    }

    void event::
    update_time (const update_time_type& x)
    {
      this->update_time_.set (x);
    }

    void event::
    update_time (::std::auto_ptr< update_time_type > x)
    {
      this->update_time_.set (x);
    }

    const event::location_type& event::
    location () const
    {
      return this->location_.get ();
    }

    event::location_type& event::
    location ()
    {
      return this->location_.get ();
    }

    void event::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void event::
    location (::std::auto_ptr< location_type > x)
    {
      this->location_.set (x);
    }

    const event::venue_type& event::
    venue () const
    {
      return this->venue_.get ();
    }

    event::venue_type& event::
    venue ()
    {
      return this->venue_.get ();
    }

    void event::
    venue (const venue_type& x)
    {
      this->venue_.set (x);
    }

    void event::
    venue (::std::auto_ptr< venue_type > x)
    {
      this->venue_.set (x);
    }


    // event_member
    // 

    const event_member::uid_type& event_member::
    uid () const
    {
      return this->uid_.get ();
    }

    event_member::uid_type& event_member::
    uid ()
    {
      return this->uid_.get ();
    }

    void event_member::
    uid (const uid_type& x)
    {
      this->uid_.set (x);
    }

    void event_member::
    uid (::std::auto_ptr< uid_type > x)
    {
      this->uid_.set (x);
    }

    const event_member::oid_type& event_member::
    oid () const
    {
      return this->oid_.get ();
    }

    event_member::oid_type& event_member::
    oid ()
    {
      return this->oid_.get ();
    }

    void event_member::
    oid (const oid_type& x)
    {
      this->oid_.set (x);
    }

    void event_member::
    oid (::std::auto_ptr< oid_type > x)
    {
      this->oid_.set (x);
    }

    const event_member::attending_type& event_member::
    attending () const
    {
      return this->attending_.get ();
    }

    event_member::attending_type& event_member::
    attending ()
    {
      return this->attending_.get ();
    }

    void event_member::
    attending (const attending_type& x)
    {
      this->attending_.set (x);
    }

    void event_member::
    attending (::std::auto_ptr< attending_type > x)
    {
      this->attending_.set (x);
    }


    // group
    // 

    const group::gid_type& group::
    gid () const
    {
      return this->gid_.get ();
    }

    group::gid_type& group::
    gid ()
    {
      return this->gid_.get ();
    }

    void group::
    gid (const gid_type& x)
    {
      this->gid_.set (x);
    }

    void group::
    gid (::std::auto_ptr< gid_type > x)
    {
      this->gid_.set (x);
    }

    const group::name_type& group::
    name () const
    {
      return this->name_.get ();
    }

    group::name_type& group::
    name ()
    {
      return this->name_.get ();
    }

    void group::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void group::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const group::nid_type& group::
    nid () const
    {
      return this->nid_.get ();
    }

    group::nid_type& group::
    nid ()
    {
      return this->nid_.get ();
    }

    void group::
    nid (const nid_type& x)
    {
      this->nid_.set (x);
    }

    void group::
    nid (::std::auto_ptr< nid_type > x)
    {
      this->nid_.set (x);
    }

    const group::description_type& group::
    description () const
    {
      return this->description_.get ();
    }

    group::description_type& group::
    description ()
    {
      return this->description_.get ();
    }

    void group::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void group::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const group::group_type_type& group::
    group_type () const
    {
      return this->group_type_.get ();
    }

    group::group_type_type& group::
    group_type ()
    {
      return this->group_type_.get ();
    }

    void group::
    group_type (const group_type_type& x)
    {
      this->group_type_.set (x);
    }

    void group::
    group_type (::std::auto_ptr< group_type_type > x)
    {
      this->group_type_.set (x);
    }

    const group::group_subtype_type& group::
    group_subtype () const
    {
      return this->group_subtype_.get ();
    }

    group::group_subtype_type& group::
    group_subtype ()
    {
      return this->group_subtype_.get ();
    }

    void group::
    group_subtype (const group_subtype_type& x)
    {
      this->group_subtype_.set (x);
    }

    void group::
    group_subtype (::std::auto_ptr< group_subtype_type > x)
    {
      this->group_subtype_.set (x);
    }

    const group::recent_news_type& group::
    recent_news () const
    {
      return this->recent_news_.get ();
    }

    group::recent_news_type& group::
    recent_news ()
    {
      return this->recent_news_.get ();
    }

    void group::
    recent_news (const recent_news_type& x)
    {
      this->recent_news_.set (x);
    }

    void group::
    recent_news (::std::auto_ptr< recent_news_type > x)
    {
      this->recent_news_.set (x);
    }

    const group::pic_type& group::
    pic () const
    {
      return this->pic_.get ();
    }

    group::pic_type& group::
    pic ()
    {
      return this->pic_.get ();
    }

    void group::
    pic (const pic_type& x)
    {
      this->pic_.set (x);
    }

    void group::
    pic (::std::auto_ptr< pic_type > x)
    {
      this->pic_.set (x);
    }

    const group::pic_big_type& group::
    pic_big () const
    {
      return this->pic_big_.get ();
    }

    group::pic_big_type& group::
    pic_big ()
    {
      return this->pic_big_.get ();
    }

    void group::
    pic_big (const pic_big_type& x)
    {
      this->pic_big_.set (x);
    }

    void group::
    pic_big (::std::auto_ptr< pic_big_type > x)
    {
      this->pic_big_.set (x);
    }

    const group::pic_small_type& group::
    pic_small () const
    {
      return this->pic_small_.get ();
    }

    group::pic_small_type& group::
    pic_small ()
    {
      return this->pic_small_.get ();
    }

    void group::
    pic_small (const pic_small_type& x)
    {
      this->pic_small_.set (x);
    }

    void group::
    pic_small (::std::auto_ptr< pic_small_type > x)
    {
      this->pic_small_.set (x);
    }

    const group::creator_type& group::
    creator () const
    {
      return this->creator_.get ();
    }

    group::creator_type& group::
    creator ()
    {
      return this->creator_.get ();
    }

    void group::
    creator (const creator_type& x)
    {
      this->creator_.set (x);
    }

    void group::
    creator (::std::auto_ptr< creator_type > x)
    {
      this->creator_.set (x);
    }

    const group::update_time_type& group::
    update_time () const
    {
      return this->update_time_.get ();
    }

    group::update_time_type& group::
    update_time ()
    {
      return this->update_time_.get ();
    }

    void group::
    update_time (const update_time_type& x)
    {
      this->update_time_.set (x);
    }

    void group::
    update_time (::std::auto_ptr< update_time_type > x)
    {
      this->update_time_.set (x);
    }

    const group::office_type& group::
    office () const
    {
      return this->office_.get ();
    }

    group::office_type& group::
    office ()
    {
      return this->office_.get ();
    }

    void group::
    office (const office_type& x)
    {
      this->office_.set (x);
    }

    void group::
    office (::std::auto_ptr< office_type > x)
    {
      this->office_.set (x);
    }

    const group::website_type& group::
    website () const
    {
      return this->website_.get ();
    }

    group::website_type& group::
    website ()
    {
      return this->website_.get ();
    }

    void group::
    website (const website_type& x)
    {
      this->website_.set (x);
    }

    void group::
    website (::std::auto_ptr< website_type > x)
    {
      this->website_.set (x);
    }

    const group::venue_type& group::
    venue () const
    {
      return this->venue_.get ();
    }

    group::venue_type& group::
    venue ()
    {
      return this->venue_.get ();
    }

    void group::
    venue (const venue_type& x)
    {
      this->venue_.set (x);
    }

    void group::
    venue (::std::auto_ptr< venue_type > x)
    {
      this->venue_.set (x);
    }


    // group_member
    // 

    const group_member::uid_type& group_member::
    uid () const
    {
      return this->uid_.get ();
    }

    group_member::uid_type& group_member::
    uid ()
    {
      return this->uid_.get ();
    }

    void group_member::
    uid (const uid_type& x)
    {
      this->uid_.set (x);
    }

    void group_member::
    uid (::std::auto_ptr< uid_type > x)
    {
      this->uid_.set (x);
    }

    const group_member::gid_type& group_member::
    gid () const
    {
      return this->gid_.get ();
    }

    group_member::gid_type& group_member::
    gid ()
    {
      return this->gid_.get ();
    }

    void group_member::
    gid (const gid_type& x)
    {
      this->gid_.set (x);
    }

    void group_member::
    gid (::std::auto_ptr< gid_type > x)
    {
      this->gid_.set (x);
    }

    const group_member::positions_type& group_member::
    positions () const
    {
      return this->positions_.get ();
    }

    group_member::positions_type& group_member::
    positions ()
    {
      return this->positions_.get ();
    }

    void group_member::
    positions (const positions_type& x)
    {
      this->positions_.set (x);
    }

    void group_member::
    positions (::std::auto_ptr< positions_type > x)
    {
      this->positions_.set (x);
    }


    // group_members
    // 

    const group_members::members_type& group_members::
    members () const
    {
      return this->members_.get ();
    }

    group_members::members_type& group_members::
    members ()
    {
      return this->members_.get ();
    }

    void group_members::
    members (const members_type& x)
    {
      this->members_.set (x);
    }

    void group_members::
    members (::std::auto_ptr< members_type > x)
    {
      this->members_.set (x);
    }

    const group_members::admins_type& group_members::
    admins () const
    {
      return this->admins_.get ();
    }

    group_members::admins_type& group_members::
    admins ()
    {
      return this->admins_.get ();
    }

    void group_members::
    admins (const admins_type& x)
    {
      this->admins_.set (x);
    }

    void group_members::
    admins (::std::auto_ptr< admins_type > x)
    {
      this->admins_.set (x);
    }

    const group_members::officers_type& group_members::
    officers () const
    {
      return this->officers_.get ();
    }

    group_members::officers_type& group_members::
    officers ()
    {
      return this->officers_.get ();
    }

    void group_members::
    officers (const officers_type& x)
    {
      this->officers_.set (x);
    }

    void group_members::
    officers (::std::auto_ptr< officers_type > x)
    {
      this->officers_.set (x);
    }

    const group_members::not_replied_type& group_members::
    not_replied () const
    {
      return this->not_replied_.get ();
    }

    group_members::not_replied_type& group_members::
    not_replied ()
    {
      return this->not_replied_.get ();
    }

    void group_members::
    not_replied (const not_replied_type& x)
    {
      this->not_replied_.set (x);
    }

    void group_members::
    not_replied (::std::auto_ptr< not_replied_type > x)
    {
      this->not_replied_.set (x);
    }


    // event_members
    // 

    const event_members::attending_type& event_members::
    attending () const
    {
      return this->attending_.get ();
    }

    event_members::attending_type& event_members::
    attending ()
    {
      return this->attending_.get ();
    }

    void event_members::
    attending (const attending_type& x)
    {
      this->attending_.set (x);
    }

    void event_members::
    attending (::std::auto_ptr< attending_type > x)
    {
      this->attending_.set (x);
    }

    const event_members::unsure_type& event_members::
    unsure () const
    {
      return this->unsure_.get ();
    }

    event_members::unsure_type& event_members::
    unsure ()
    {
      return this->unsure_.get ();
    }

    void event_members::
    unsure (const unsure_type& x)
    {
      this->unsure_.set (x);
    }

    void event_members::
    unsure (::std::auto_ptr< unsure_type > x)
    {
      this->unsure_.set (x);
    }

    const event_members::declined_type& event_members::
    declined () const
    {
      return this->declined_.get ();
    }

    event_members::declined_type& event_members::
    declined ()
    {
      return this->declined_.get ();
    }

    void event_members::
    declined (const declined_type& x)
    {
      this->declined_.set (x);
    }

    void event_members::
    declined (::std::auto_ptr< declined_type > x)
    {
      this->declined_.set (x);
    }

    const event_members::not_replied_type& event_members::
    not_replied () const
    {
      return this->not_replied_.get ();
    }

    event_members::not_replied_type& event_members::
    not_replied ()
    {
      return this->not_replied_.get ();
    }

    void event_members::
    not_replied (const not_replied_type& x)
    {
      this->not_replied_.set (x);
    }

    void event_members::
    not_replied (::std::auto_ptr< not_replied_type > x)
    {
      this->not_replied_.set (x);
    }


    // notification_count
    // 

    const notification_count::unread_type& notification_count::
    unread () const
    {
      return this->unread_.get ();
    }

    notification_count::unread_type& notification_count::
    unread ()
    {
      return this->unread_.get ();
    }

    void notification_count::
    unread (const unread_type& x)
    {
      this->unread_.set (x);
    }

    const notification_count::most_recent_type& notification_count::
    most_recent () const
    {
      return this->most_recent_.get ();
    }

    notification_count::most_recent_type& notification_count::
    most_recent ()
    {
      return this->most_recent_.get ();
    }

    void notification_count::
    most_recent (const most_recent_type& x)
    {
      this->most_recent_.set (x);
    }

    void notification_count::
    most_recent (::std::auto_ptr< most_recent_type > x)
    {
      this->most_recent_.set (x);
    }


    // notifications
    // 

    const notifications::messages_type& notifications::
    messages () const
    {
      return this->messages_.get ();
    }

    notifications::messages_type& notifications::
    messages ()
    {
      return this->messages_.get ();
    }

    void notifications::
    messages (const messages_type& x)
    {
      this->messages_.set (x);
    }

    void notifications::
    messages (::std::auto_ptr< messages_type > x)
    {
      this->messages_.set (x);
    }

    const notifications::pokes_type& notifications::
    pokes () const
    {
      return this->pokes_.get ();
    }

    notifications::pokes_type& notifications::
    pokes ()
    {
      return this->pokes_.get ();
    }

    void notifications::
    pokes (const pokes_type& x)
    {
      this->pokes_.set (x);
    }

    void notifications::
    pokes (::std::auto_ptr< pokes_type > x)
    {
      this->pokes_.set (x);
    }

    const notifications::shares_type& notifications::
    shares () const
    {
      return this->shares_.get ();
    }

    notifications::shares_type& notifications::
    shares ()
    {
      return this->shares_.get ();
    }

    void notifications::
    shares (const shares_type& x)
    {
      this->shares_.set (x);
    }

    void notifications::
    shares (::std::auto_ptr< shares_type > x)
    {
      this->shares_.set (x);
    }

    const notifications::friend_requests_type& notifications::
    friend_requests () const
    {
      return this->friend_requests_.get ();
    }

    notifications::friend_requests_type& notifications::
    friend_requests ()
    {
      return this->friend_requests_.get ();
    }

    void notifications::
    friend_requests (const friend_requests_type& x)
    {
      this->friend_requests_.set (x);
    }

    void notifications::
    friend_requests (::std::auto_ptr< friend_requests_type > x)
    {
      this->friend_requests_.set (x);
    }

    const notifications::group_invites_type& notifications::
    group_invites () const
    {
      return this->group_invites_.get ();
    }

    notifications::group_invites_type& notifications::
    group_invites ()
    {
      return this->group_invites_.get ();
    }

    void notifications::
    group_invites (const group_invites_type& x)
    {
      this->group_invites_.set (x);
    }

    void notifications::
    group_invites (::std::auto_ptr< group_invites_type > x)
    {
      this->group_invites_.set (x);
    }

    const notifications::event_invites_type& notifications::
    event_invites () const
    {
      return this->event_invites_.get ();
    }

    notifications::event_invites_type& notifications::
    event_invites ()
    {
      return this->event_invites_.get ();
    }

    void notifications::
    event_invites (const event_invites_type& x)
    {
      this->event_invites_.set (x);
    }

    void notifications::
    event_invites (::std::auto_ptr< event_invites_type > x)
    {
      this->event_invites_.set (x);
    }


    // photo
    // 

    const photo::pid_type& photo::
    pid () const
    {
      return this->pid_.get ();
    }

    photo::pid_type& photo::
    pid ()
    {
      return this->pid_.get ();
    }

    void photo::
    pid (const pid_type& x)
    {
      this->pid_.set (x);
    }

    void photo::
    pid (::std::auto_ptr< pid_type > x)
    {
      this->pid_.set (x);
    }

    const photo::aid_type& photo::
    aid () const
    {
      return this->aid_.get ();
    }

    photo::aid_type& photo::
    aid ()
    {
      return this->aid_.get ();
    }

    void photo::
    aid (const aid_type& x)
    {
      this->aid_.set (x);
    }

    void photo::
    aid (::std::auto_ptr< aid_type > x)
    {
      this->aid_.set (x);
    }

    const photo::owner_type& photo::
    owner () const
    {
      return this->owner_.get ();
    }

    photo::owner_type& photo::
    owner ()
    {
      return this->owner_.get ();
    }

    void photo::
    owner (const owner_type& x)
    {
      this->owner_.set (x);
    }

    void photo::
    owner (::std::auto_ptr< owner_type > x)
    {
      this->owner_.set (x);
    }

    const photo::src_type& photo::
    src () const
    {
      return this->src_.get ();
    }

    photo::src_type& photo::
    src ()
    {
      return this->src_.get ();
    }

    void photo::
    src (const src_type& x)
    {
      this->src_.set (x);
    }

    void photo::
    src (::std::auto_ptr< src_type > x)
    {
      this->src_.set (x);
    }

    const photo::src_big_type& photo::
    src_big () const
    {
      return this->src_big_.get ();
    }

    photo::src_big_type& photo::
    src_big ()
    {
      return this->src_big_.get ();
    }

    void photo::
    src_big (const src_big_type& x)
    {
      this->src_big_.set (x);
    }

    void photo::
    src_big (::std::auto_ptr< src_big_type > x)
    {
      this->src_big_.set (x);
    }

    const photo::src_small_type& photo::
    src_small () const
    {
      return this->src_small_.get ();
    }

    photo::src_small_type& photo::
    src_small ()
    {
      return this->src_small_.get ();
    }

    void photo::
    src_small (const src_small_type& x)
    {
      this->src_small_.set (x);
    }

    void photo::
    src_small (::std::auto_ptr< src_small_type > x)
    {
      this->src_small_.set (x);
    }

    const photo::link_type& photo::
    link () const
    {
      return this->link_.get ();
    }

    photo::link_type& photo::
    link ()
    {
      return this->link_.get ();
    }

    void photo::
    link (const link_type& x)
    {
      this->link_.set (x);
    }

    void photo::
    link (::std::auto_ptr< link_type > x)
    {
      this->link_.set (x);
    }

    const photo::caption_type& photo::
    caption () const
    {
      return this->caption_.get ();
    }

    photo::caption_type& photo::
    caption ()
    {
      return this->caption_.get ();
    }

    void photo::
    caption (const caption_type& x)
    {
      this->caption_.set (x);
    }

    void photo::
    caption (::std::auto_ptr< caption_type > x)
    {
      this->caption_.set (x);
    }

    const photo::created_type& photo::
    created () const
    {
      return this->created_.get ();
    }

    photo::created_type& photo::
    created ()
    {
      return this->created_.get ();
    }

    void photo::
    created (const created_type& x)
    {
      this->created_.set (x);
    }

    void photo::
    created (::std::auto_ptr< created_type > x)
    {
      this->created_.set (x);
    }


    // photo_tag
    // 

    const photo_tag::pid_type& photo_tag::
    pid () const
    {
      return this->pid_.get ();
    }

    photo_tag::pid_type& photo_tag::
    pid ()
    {
      return this->pid_.get ();
    }

    void photo_tag::
    pid (const pid_type& x)
    {
      this->pid_.set (x);
    }

    void photo_tag::
    pid (::std::auto_ptr< pid_type > x)
    {
      this->pid_.set (x);
    }

    const photo_tag::subject_optional& photo_tag::
    subject () const
    {
      return this->subject_;
    }

    photo_tag::subject_optional& photo_tag::
    subject ()
    {
      return this->subject_;
    }

    void photo_tag::
    subject (const subject_type& x)
    {
      this->subject_.set (x);
    }

    void photo_tag::
    subject (const subject_optional& x)
    {
      this->subject_ = x;
    }

    void photo_tag::
    subject (::std::auto_ptr< subject_type > x)
    {
      this->subject_.set (x);
    }

    const photo_tag::text_optional& photo_tag::
    text () const
    {
      return this->text_;
    }

    photo_tag::text_optional& photo_tag::
    text ()
    {
      return this->text_;
    }

    void photo_tag::
    text (const text_type& x)
    {
      this->text_.set (x);
    }

    void photo_tag::
    text (const text_optional& x)
    {
      this->text_ = x;
    }

    void photo_tag::
    text (::std::auto_ptr< text_type > x)
    {
      this->text_.set (x);
    }

    const photo_tag::xcoord_type& photo_tag::
    xcoord () const
    {
      return this->xcoord_.get ();
    }

    photo_tag::xcoord_type& photo_tag::
    xcoord ()
    {
      return this->xcoord_.get ();
    }

    void photo_tag::
    xcoord (const xcoord_type& x)
    {
      this->xcoord_.set (x);
    }

    const photo_tag::ycoord_type& photo_tag::
    ycoord () const
    {
      return this->ycoord_.get ();
    }

    photo_tag::ycoord_type& photo_tag::
    ycoord ()
    {
      return this->ycoord_.get ();
    }

    void photo_tag::
    ycoord (const ycoord_type& x)
    {
      this->ycoord_.set (x);
    }

    const photo_tag::created_type& photo_tag::
    created () const
    {
      return this->created_.get ();
    }

    photo_tag::created_type& photo_tag::
    created ()
    {
      return this->created_.get ();
    }

    void photo_tag::
    created (const created_type& x)
    {
      this->created_.set (x);
    }

    void photo_tag::
    created (::std::auto_ptr< created_type > x)
    {
      this->created_.set (x);
    }


    // album
    // 

    const album::aid_type& album::
    aid () const
    {
      return this->aid_.get ();
    }

    album::aid_type& album::
    aid ()
    {
      return this->aid_.get ();
    }

    void album::
    aid (const aid_type& x)
    {
      this->aid_.set (x);
    }

    void album::
    aid (::std::auto_ptr< aid_type > x)
    {
      this->aid_.set (x);
    }

    const album::cover_pid_type& album::
    cover_pid () const
    {
      return this->cover_pid_.get ();
    }

    album::cover_pid_type& album::
    cover_pid ()
    {
      return this->cover_pid_.get ();
    }

    void album::
    cover_pid (const cover_pid_type& x)
    {
      this->cover_pid_.set (x);
    }

    void album::
    cover_pid (::std::auto_ptr< cover_pid_type > x)
    {
      this->cover_pid_.set (x);
    }

    const album::owner_type& album::
    owner () const
    {
      return this->owner_.get ();
    }

    album::owner_type& album::
    owner ()
    {
      return this->owner_.get ();
    }

    void album::
    owner (const owner_type& x)
    {
      this->owner_.set (x);
    }

    void album::
    owner (::std::auto_ptr< owner_type > x)
    {
      this->owner_.set (x);
    }

    const album::name_type& album::
    name () const
    {
      return this->name_.get ();
    }

    album::name_type& album::
    name ()
    {
      return this->name_.get ();
    }

    void album::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void album::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const album::created_type& album::
    created () const
    {
      return this->created_.get ();
    }

    album::created_type& album::
    created ()
    {
      return this->created_.get ();
    }

    void album::
    created (const created_type& x)
    {
      this->created_.set (x);
    }

    void album::
    created (::std::auto_ptr< created_type > x)
    {
      this->created_.set (x);
    }

    const album::modified_type& album::
    modified () const
    {
      return this->modified_.get ();
    }

    album::modified_type& album::
    modified ()
    {
      return this->modified_.get ();
    }

    void album::
    modified (const modified_type& x)
    {
      this->modified_.set (x);
    }

    void album::
    modified (::std::auto_ptr< modified_type > x)
    {
      this->modified_.set (x);
    }

    const album::description_type& album::
    description () const
    {
      return this->description_.get ();
    }

    album::description_type& album::
    description ()
    {
      return this->description_.get ();
    }

    void album::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void album::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const album::location_type& album::
    location () const
    {
      return this->location_.get ();
    }

    album::location_type& album::
    location ()
    {
      return this->location_.get ();
    }

    void album::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void album::
    location (::std::auto_ptr< location_type > x)
    {
      this->location_.set (x);
    }

    const album::link_type& album::
    link () const
    {
      return this->link_.get ();
    }

    album::link_type& album::
    link ()
    {
      return this->link_.get ();
    }

    void album::
    link (const link_type& x)
    {
      this->link_.set (x);
    }

    void album::
    link (::std::auto_ptr< link_type > x)
    {
      this->link_.set (x);
    }

    const album::size_type& album::
    size () const
    {
      return this->size_.get ();
    }

    album::size_type& album::
    size ()
    {
      return this->size_.get ();
    }

    void album::
    size (const size_type& x)
    {
      this->size_.set (x);
    }


    // affiliation
    // 

    const affiliation::nid_type& affiliation::
    nid () const
    {
      return this->nid_.get ();
    }

    affiliation::nid_type& affiliation::
    nid ()
    {
      return this->nid_.get ();
    }

    void affiliation::
    nid (const nid_type& x)
    {
      this->nid_.set (x);
    }

    void affiliation::
    nid (::std::auto_ptr< nid_type > x)
    {
      this->nid_.set (x);
    }

    const affiliation::name_type& affiliation::
    name () const
    {
      return this->name_.get ();
    }

    affiliation::name_type& affiliation::
    name ()
    {
      return this->name_.get ();
    }

    void affiliation::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void affiliation::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const affiliation::type_type& affiliation::
    type () const
    {
      return this->type_.get ();
    }

    affiliation::type_type& affiliation::
    type ()
    {
      return this->type_.get ();
    }

    void affiliation::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void affiliation::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const affiliation::status_type& affiliation::
    status () const
    {
      return this->status_.get ();
    }

    affiliation::status_type& affiliation::
    status ()
    {
      return this->status_.get ();
    }

    void affiliation::
    status (const status_type& x)
    {
      this->status_.set (x);
    }

    void affiliation::
    status (::std::auto_ptr< status_type > x)
    {
      this->status_.set (x);
    }

    const affiliation::year_type& affiliation::
    year () const
    {
      return this->year_.get ();
    }

    affiliation::year_type& affiliation::
    year ()
    {
      return this->year_.get ();
    }

    void affiliation::
    year (const year_type& x)
    {
      this->year_.set (x);
    }

    void affiliation::
    year (::std::auto_ptr< year_type > x)
    {
      this->year_.set (x);
    }


    // hs_info
    // 

    const hs_info::hs1_name_optional& hs_info::
    hs1_name () const
    {
      return this->hs1_name_;
    }

    hs_info::hs1_name_optional& hs_info::
    hs1_name ()
    {
      return this->hs1_name_;
    }

    void hs_info::
    hs1_name (const hs1_name_type& x)
    {
      this->hs1_name_.set (x);
    }

    void hs_info::
    hs1_name (const hs1_name_optional& x)
    {
      this->hs1_name_ = x;
    }

    void hs_info::
    hs1_name (::std::auto_ptr< hs1_name_type > x)
    {
      this->hs1_name_.set (x);
    }

    const hs_info::hs2_name_optional& hs_info::
    hs2_name () const
    {
      return this->hs2_name_;
    }

    hs_info::hs2_name_optional& hs_info::
    hs2_name ()
    {
      return this->hs2_name_;
    }

    void hs_info::
    hs2_name (const hs2_name_type& x)
    {
      this->hs2_name_.set (x);
    }

    void hs_info::
    hs2_name (const hs2_name_optional& x)
    {
      this->hs2_name_ = x;
    }

    void hs_info::
    hs2_name (::std::auto_ptr< hs2_name_type > x)
    {
      this->hs2_name_.set (x);
    }

    const hs_info::grad_year_optional& hs_info::
    grad_year () const
    {
      return this->grad_year_;
    }

    hs_info::grad_year_optional& hs_info::
    grad_year ()
    {
      return this->grad_year_;
    }

    void hs_info::
    grad_year (const grad_year_type& x)
    {
      this->grad_year_.set (x);
    }

    void hs_info::
    grad_year (const grad_year_optional& x)
    {
      this->grad_year_ = x;
    }

    void hs_info::
    grad_year (::std::auto_ptr< grad_year_type > x)
    {
      this->grad_year_.set (x);
    }

    const hs_info::hs1_id_optional& hs_info::
    hs1_id () const
    {
      return this->hs1_id_;
    }

    hs_info::hs1_id_optional& hs_info::
    hs1_id ()
    {
      return this->hs1_id_;
    }

    void hs_info::
    hs1_id (const hs1_id_type& x)
    {
      this->hs1_id_.set (x);
    }

    void hs_info::
    hs1_id (const hs1_id_optional& x)
    {
      this->hs1_id_ = x;
    }

    void hs_info::
    hs1_id (::std::auto_ptr< hs1_id_type > x)
    {
      this->hs1_id_.set (x);
    }

    const hs_info::hs2_id_optional& hs_info::
    hs2_id () const
    {
      return this->hs2_id_;
    }

    hs_info::hs2_id_optional& hs_info::
    hs2_id ()
    {
      return this->hs2_id_;
    }

    void hs_info::
    hs2_id (const hs2_id_type& x)
    {
      this->hs2_id_.set (x);
    }

    void hs_info::
    hs2_id (const hs2_id_optional& x)
    {
      this->hs2_id_ = x;
    }

    void hs_info::
    hs2_id (::std::auto_ptr< hs2_id_type > x)
    {
      this->hs2_id_.set (x);
    }


    // education_info
    // 

    const education_info::name_type& education_info::
    name () const
    {
      return this->name_.get ();
    }

    education_info::name_type& education_info::
    name ()
    {
      return this->name_.get ();
    }

    void education_info::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void education_info::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const education_info::year_type& education_info::
    year () const
    {
      return this->year_.get ();
    }

    education_info::year_type& education_info::
    year ()
    {
      return this->year_.get ();
    }

    void education_info::
    year (const year_type& x)
    {
      this->year_.set (x);
    }

    void education_info::
    year (::std::auto_ptr< year_type > x)
    {
      this->year_.set (x);
    }

    const education_info::concentrations_type& education_info::
    concentrations () const
    {
      return this->concentrations_.get ();
    }

    education_info::concentrations_type& education_info::
    concentrations ()
    {
      return this->concentrations_.get ();
    }

    void education_info::
    concentrations (const concentrations_type& x)
    {
      this->concentrations_.set (x);
    }

    void education_info::
    concentrations (::std::auto_ptr< concentrations_type > x)
    {
      this->concentrations_.set (x);
    }

    const education_info::degree_type& education_info::
    degree () const
    {
      return this->degree_.get ();
    }

    education_info::degree_type& education_info::
    degree ()
    {
      return this->degree_.get ();
    }

    void education_info::
    degree (const degree_type& x)
    {
      this->degree_.set (x);
    }

    void education_info::
    degree (::std::auto_ptr< degree_type > x)
    {
      this->degree_.set (x);
    }


    // work_info
    // 

    const work_info::location_type& work_info::
    location () const
    {
      return this->location_.get ();
    }

    work_info::location_type& work_info::
    location ()
    {
      return this->location_.get ();
    }

    void work_info::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void work_info::
    location (::std::auto_ptr< location_type > x)
    {
      this->location_.set (x);
    }

    const work_info::company_name_type& work_info::
    company_name () const
    {
      return this->company_name_.get ();
    }

    work_info::company_name_type& work_info::
    company_name ()
    {
      return this->company_name_.get ();
    }

    void work_info::
    company_name (const company_name_type& x)
    {
      this->company_name_.set (x);
    }

    void work_info::
    company_name (::std::auto_ptr< company_name_type > x)
    {
      this->company_name_.set (x);
    }

    const work_info::position_type& work_info::
    position () const
    {
      return this->position_.get ();
    }

    work_info::position_type& work_info::
    position ()
    {
      return this->position_.get ();
    }

    void work_info::
    position (const position_type& x)
    {
      this->position_.set (x);
    }

    void work_info::
    position (::std::auto_ptr< position_type > x)
    {
      this->position_.set (x);
    }

    const work_info::description_type& work_info::
    description () const
    {
      return this->description_.get ();
    }

    work_info::description_type& work_info::
    description ()
    {
      return this->description_.get ();
    }

    void work_info::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void work_info::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const work_info::start_date_type& work_info::
    start_date () const
    {
      return this->start_date_.get ();
    }

    work_info::start_date_type& work_info::
    start_date ()
    {
      return this->start_date_.get ();
    }

    void work_info::
    start_date (const start_date_type& x)
    {
      this->start_date_.set (x);
    }

    void work_info::
    start_date (::std::auto_ptr< start_date_type > x)
    {
      this->start_date_.set (x);
    }

    const work_info::end_date_type& work_info::
    end_date () const
    {
      return this->end_date_.get ();
    }

    work_info::end_date_type& work_info::
    end_date ()
    {
      return this->end_date_.get ();
    }

    void work_info::
    end_date (const end_date_type& x)
    {
      this->end_date_.set (x);
    }

    void work_info::
    end_date (::std::auto_ptr< end_date_type > x)
    {
      this->end_date_.set (x);
    }


    // user
    // 

    const user::about_me_optional& user::
    about_me () const
    {
      return this->about_me_;
    }

    user::about_me_optional& user::
    about_me ()
    {
      return this->about_me_;
    }

    void user::
    about_me (const about_me_type& x)
    {
      this->about_me_.set (x);
    }

    void user::
    about_me (const about_me_optional& x)
    {
      this->about_me_ = x;
    }

    void user::
    about_me (::std::auto_ptr< about_me_type > x)
    {
      this->about_me_.set (x);
    }

    const user::activities_optional& user::
    activities () const
    {
      return this->activities_;
    }

    user::activities_optional& user::
    activities ()
    {
      return this->activities_;
    }

    void user::
    activities (const activities_type& x)
    {
      this->activities_.set (x);
    }

    void user::
    activities (const activities_optional& x)
    {
      this->activities_ = x;
    }

    void user::
    activities (::std::auto_ptr< activities_type > x)
    {
      this->activities_.set (x);
    }

    const user::affiliations_optional& user::
    affiliations () const
    {
      return this->affiliations_;
    }

    user::affiliations_optional& user::
    affiliations ()
    {
      return this->affiliations_;
    }

    void user::
    affiliations (const affiliations_type& x)
    {
      this->affiliations_.set (x);
    }

    void user::
    affiliations (const affiliations_optional& x)
    {
      this->affiliations_ = x;
    }

    void user::
    affiliations (::std::auto_ptr< affiliations_type > x)
    {
      this->affiliations_.set (x);
    }

    const user::birthday_optional& user::
    birthday () const
    {
      return this->birthday_;
    }

    user::birthday_optional& user::
    birthday ()
    {
      return this->birthday_;
    }

    void user::
    birthday (const birthday_type& x)
    {
      this->birthday_.set (x);
    }

    void user::
    birthday (const birthday_optional& x)
    {
      this->birthday_ = x;
    }

    void user::
    birthday (::std::auto_ptr< birthday_type > x)
    {
      this->birthday_.set (x);
    }

    const user::books_optional& user::
    books () const
    {
      return this->books_;
    }

    user::books_optional& user::
    books ()
    {
      return this->books_;
    }

    void user::
    books (const books_type& x)
    {
      this->books_.set (x);
    }

    void user::
    books (const books_optional& x)
    {
      this->books_ = x;
    }

    void user::
    books (::std::auto_ptr< books_type > x)
    {
      this->books_.set (x);
    }

    const user::current_location_optional& user::
    current_location () const
    {
      return this->current_location_;
    }

    user::current_location_optional& user::
    current_location ()
    {
      return this->current_location_;
    }

    void user::
    current_location (const current_location_type& x)
    {
      this->current_location_.set (x);
    }

    void user::
    current_location (const current_location_optional& x)
    {
      this->current_location_ = x;
    }

    void user::
    current_location (::std::auto_ptr< current_location_type > x)
    {
      this->current_location_.set (x);
    }

    const user::education_history_optional& user::
    education_history () const
    {
      return this->education_history_;
    }

    user::education_history_optional& user::
    education_history ()
    {
      return this->education_history_;
    }

    void user::
    education_history (const education_history_type& x)
    {
      this->education_history_.set (x);
    }

    void user::
    education_history (const education_history_optional& x)
    {
      this->education_history_ = x;
    }

    void user::
    education_history (::std::auto_ptr< education_history_type > x)
    {
      this->education_history_.set (x);
    }

    const user::first_name_optional& user::
    first_name () const
    {
      return this->first_name_;
    }

    user::first_name_optional& user::
    first_name ()
    {
      return this->first_name_;
    }

    void user::
    first_name (const first_name_type& x)
    {
      this->first_name_.set (x);
    }

    void user::
    first_name (const first_name_optional& x)
    {
      this->first_name_ = x;
    }

    void user::
    first_name (::std::auto_ptr< first_name_type > x)
    {
      this->first_name_.set (x);
    }

    const user::hometown_location_optional& user::
    hometown_location () const
    {
      return this->hometown_location_;
    }

    user::hometown_location_optional& user::
    hometown_location ()
    {
      return this->hometown_location_;
    }

    void user::
    hometown_location (const hometown_location_type& x)
    {
      this->hometown_location_.set (x);
    }

    void user::
    hometown_location (const hometown_location_optional& x)
    {
      this->hometown_location_ = x;
    }

    void user::
    hometown_location (::std::auto_ptr< hometown_location_type > x)
    {
      this->hometown_location_.set (x);
    }

    const user::hs_info_optional& user::
    hs_info () const
    {
      return this->hs_info_;
    }

    user::hs_info_optional& user::
    hs_info ()
    {
      return this->hs_info_;
    }

    void user::
    hs_info (const hs_info_type& x)
    {
      this->hs_info_.set (x);
    }

    void user::
    hs_info (const hs_info_optional& x)
    {
      this->hs_info_ = x;
    }

    void user::
    hs_info (::std::auto_ptr< hs_info_type > x)
    {
      this->hs_info_.set (x);
    }

    const user::interests_optional& user::
    interests () const
    {
      return this->interests_;
    }

    user::interests_optional& user::
    interests ()
    {
      return this->interests_;
    }

    void user::
    interests (const interests_type& x)
    {
      this->interests_.set (x);
    }

    void user::
    interests (const interests_optional& x)
    {
      this->interests_ = x;
    }

    void user::
    interests (::std::auto_ptr< interests_type > x)
    {
      this->interests_.set (x);
    }

    const user::is_app_user_optional& user::
    is_app_user () const
    {
      return this->is_app_user_;
    }

    user::is_app_user_optional& user::
    is_app_user ()
    {
      return this->is_app_user_;
    }

    void user::
    is_app_user (const is_app_user_type& x)
    {
      this->is_app_user_.set (x);
    }

    void user::
    is_app_user (const is_app_user_optional& x)
    {
      this->is_app_user_ = x;
    }

    const user::last_name_optional& user::
    last_name () const
    {
      return this->last_name_;
    }

    user::last_name_optional& user::
    last_name ()
    {
      return this->last_name_;
    }

    void user::
    last_name (const last_name_type& x)
    {
      this->last_name_.set (x);
    }

    void user::
    last_name (const last_name_optional& x)
    {
      this->last_name_ = x;
    }

    void user::
    last_name (::std::auto_ptr< last_name_type > x)
    {
      this->last_name_.set (x);
    }

    const user::meeting_for_optional& user::
    meeting_for () const
    {
      return this->meeting_for_;
    }

    user::meeting_for_optional& user::
    meeting_for ()
    {
      return this->meeting_for_;
    }

    void user::
    meeting_for (const meeting_for_type& x)
    {
      this->meeting_for_.set (x);
    }

    void user::
    meeting_for (const meeting_for_optional& x)
    {
      this->meeting_for_ = x;
    }

    void user::
    meeting_for (::std::auto_ptr< meeting_for_type > x)
    {
      this->meeting_for_.set (x);
    }

    const user::meeting_sex_optional& user::
    meeting_sex () const
    {
      return this->meeting_sex_;
    }

    user::meeting_sex_optional& user::
    meeting_sex ()
    {
      return this->meeting_sex_;
    }

    void user::
    meeting_sex (const meeting_sex_type& x)
    {
      this->meeting_sex_.set (x);
    }

    void user::
    meeting_sex (const meeting_sex_optional& x)
    {
      this->meeting_sex_ = x;
    }

    void user::
    meeting_sex (::std::auto_ptr< meeting_sex_type > x)
    {
      this->meeting_sex_.set (x);
    }

    const user::movies_optional& user::
    movies () const
    {
      return this->movies_;
    }

    user::movies_optional& user::
    movies ()
    {
      return this->movies_;
    }

    void user::
    movies (const movies_type& x)
    {
      this->movies_.set (x);
    }

    void user::
    movies (const movies_optional& x)
    {
      this->movies_ = x;
    }

    void user::
    movies (::std::auto_ptr< movies_type > x)
    {
      this->movies_.set (x);
    }

    const user::music_optional& user::
    music () const
    {
      return this->music_;
    }

    user::music_optional& user::
    music ()
    {
      return this->music_;
    }

    void user::
    music (const music_type& x)
    {
      this->music_.set (x);
    }

    void user::
    music (const music_optional& x)
    {
      this->music_ = x;
    }

    void user::
    music (::std::auto_ptr< music_type > x)
    {
      this->music_.set (x);
    }

    const user::name_optional& user::
    name () const
    {
      return this->name_;
    }

    user::name_optional& user::
    name ()
    {
      return this->name_;
    }

    void user::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void user::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void user::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const user::notes_count_optional& user::
    notes_count () const
    {
      return this->notes_count_;
    }

    user::notes_count_optional& user::
    notes_count ()
    {
      return this->notes_count_;
    }

    void user::
    notes_count (const notes_count_type& x)
    {
      this->notes_count_.set (x);
    }

    void user::
    notes_count (const notes_count_optional& x)
    {
      this->notes_count_ = x;
    }

    const user::pic_optional& user::
    pic () const
    {
      return this->pic_;
    }

    user::pic_optional& user::
    pic ()
    {
      return this->pic_;
    }

    void user::
    pic (const pic_type& x)
    {
      this->pic_.set (x);
    }

    void user::
    pic (const pic_optional& x)
    {
      this->pic_ = x;
    }

    void user::
    pic (::std::auto_ptr< pic_type > x)
    {
      this->pic_.set (x);
    }

    const user::pic_big_optional& user::
    pic_big () const
    {
      return this->pic_big_;
    }

    user::pic_big_optional& user::
    pic_big ()
    {
      return this->pic_big_;
    }

    void user::
    pic_big (const pic_big_type& x)
    {
      this->pic_big_.set (x);
    }

    void user::
    pic_big (const pic_big_optional& x)
    {
      this->pic_big_ = x;
    }

    void user::
    pic_big (::std::auto_ptr< pic_big_type > x)
    {
      this->pic_big_.set (x);
    }

    const user::pic_small_optional& user::
    pic_small () const
    {
      return this->pic_small_;
    }

    user::pic_small_optional& user::
    pic_small ()
    {
      return this->pic_small_;
    }

    void user::
    pic_small (const pic_small_type& x)
    {
      this->pic_small_.set (x);
    }

    void user::
    pic_small (const pic_small_optional& x)
    {
      this->pic_small_ = x;
    }

    void user::
    pic_small (::std::auto_ptr< pic_small_type > x)
    {
      this->pic_small_.set (x);
    }

    const user::political_optional& user::
    political () const
    {
      return this->political_;
    }

    user::political_optional& user::
    political ()
    {
      return this->political_;
    }

    void user::
    political (const political_type& x)
    {
      this->political_.set (x);
    }

    void user::
    political (const political_optional& x)
    {
      this->political_ = x;
    }

    void user::
    political (::std::auto_ptr< political_type > x)
    {
      this->political_.set (x);
    }

    const user::profile_update_time_optional& user::
    profile_update_time () const
    {
      return this->profile_update_time_;
    }

    user::profile_update_time_optional& user::
    profile_update_time ()
    {
      return this->profile_update_time_;
    }

    void user::
    profile_update_time (const profile_update_time_type& x)
    {
      this->profile_update_time_.set (x);
    }

    void user::
    profile_update_time (const profile_update_time_optional& x)
    {
      this->profile_update_time_ = x;
    }

    void user::
    profile_update_time (::std::auto_ptr< profile_update_time_type > x)
    {
      this->profile_update_time_.set (x);
    }

    const user::quotes_optional& user::
    quotes () const
    {
      return this->quotes_;
    }

    user::quotes_optional& user::
    quotes ()
    {
      return this->quotes_;
    }

    void user::
    quotes (const quotes_type& x)
    {
      this->quotes_.set (x);
    }

    void user::
    quotes (const quotes_optional& x)
    {
      this->quotes_ = x;
    }

    void user::
    quotes (::std::auto_ptr< quotes_type > x)
    {
      this->quotes_.set (x);
    }

    const user::relationship_status_optional& user::
    relationship_status () const
    {
      return this->relationship_status_;
    }

    user::relationship_status_optional& user::
    relationship_status ()
    {
      return this->relationship_status_;
    }

    void user::
    relationship_status (const relationship_status_type& x)
    {
      this->relationship_status_.set (x);
    }

    void user::
    relationship_status (const relationship_status_optional& x)
    {
      this->relationship_status_ = x;
    }

    void user::
    relationship_status (::std::auto_ptr< relationship_status_type > x)
    {
      this->relationship_status_.set (x);
    }

    const user::religion_optional& user::
    religion () const
    {
      return this->religion_;
    }

    user::religion_optional& user::
    religion ()
    {
      return this->religion_;
    }

    void user::
    religion (const religion_type& x)
    {
      this->religion_.set (x);
    }

    void user::
    religion (const religion_optional& x)
    {
      this->religion_ = x;
    }

    void user::
    religion (::std::auto_ptr< religion_type > x)
    {
      this->religion_.set (x);
    }

    const user::sex_optional& user::
    sex () const
    {
      return this->sex_;
    }

    user::sex_optional& user::
    sex ()
    {
      return this->sex_;
    }

    void user::
    sex (const sex_type& x)
    {
      this->sex_.set (x);
    }

    void user::
    sex (const sex_optional& x)
    {
      this->sex_ = x;
    }

    void user::
    sex (::std::auto_ptr< sex_type > x)
    {
      this->sex_.set (x);
    }

    const user::significant_other_id_optional& user::
    significant_other_id () const
    {
      return this->significant_other_id_;
    }

    user::significant_other_id_optional& user::
    significant_other_id ()
    {
      return this->significant_other_id_;
    }

    void user::
    significant_other_id (const significant_other_id_type& x)
    {
      this->significant_other_id_.set (x);
    }

    void user::
    significant_other_id (const significant_other_id_optional& x)
    {
      this->significant_other_id_ = x;
    }

    void user::
    significant_other_id (::std::auto_ptr< significant_other_id_type > x)
    {
      this->significant_other_id_.set (x);
    }

    const user::status_optional& user::
    status () const
    {
      return this->status_;
    }

    user::status_optional& user::
    status ()
    {
      return this->status_;
    }

    void user::
    status (const status_type& x)
    {
      this->status_.set (x);
    }

    void user::
    status (const status_optional& x)
    {
      this->status_ = x;
    }

    void user::
    status (::std::auto_ptr< status_type > x)
    {
      this->status_.set (x);
    }

    const user::timezone_optional& user::
    timezone () const
    {
      return this->timezone_;
    }

    user::timezone_optional& user::
    timezone ()
    {
      return this->timezone_;
    }

    void user::
    timezone (const timezone_type& x)
    {
      this->timezone_.set (x);
    }

    void user::
    timezone (const timezone_optional& x)
    {
      this->timezone_ = x;
    }

    const user::tv_optional& user::
    tv () const
    {
      return this->tv_;
    }

    user::tv_optional& user::
    tv ()
    {
      return this->tv_;
    }

    void user::
    tv (const tv_type& x)
    {
      this->tv_.set (x);
    }

    void user::
    tv (const tv_optional& x)
    {
      this->tv_ = x;
    }

    void user::
    tv (::std::auto_ptr< tv_type > x)
    {
      this->tv_.set (x);
    }

    const user::uid_optional& user::
    uid () const
    {
      return this->uid_;
    }

    user::uid_optional& user::
    uid ()
    {
      return this->uid_;
    }

    void user::
    uid (const uid_type& x)
    {
      this->uid_.set (x);
    }

    void user::
    uid (const uid_optional& x)
    {
      this->uid_ = x;
    }

    void user::
    uid (::std::auto_ptr< uid_type > x)
    {
      this->uid_.set (x);
    }

    const user::wall_count_optional& user::
    wall_count () const
    {
      return this->wall_count_;
    }

    user::wall_count_optional& user::
    wall_count ()
    {
      return this->wall_count_;
    }

    void user::
    wall_count (const wall_count_type& x)
    {
      this->wall_count_.set (x);
    }

    void user::
    wall_count (const wall_count_optional& x)
    {
      this->wall_count_ = x;
    }

    const user::work_history_optional& user::
    work_history () const
    {
      return this->work_history_;
    }

    user::work_history_optional& user::
    work_history ()
    {
      return this->work_history_;
    }

    void user::
    work_history (const work_history_type& x)
    {
      this->work_history_.set (x);
    }

    void user::
    work_history (const work_history_optional& x)
    {
      this->work_history_ = x;
    }

    void user::
    work_history (::std::auto_ptr< work_history_type > x)
    {
      this->work_history_.set (x);
    }

    const user::pic_square_optional& user::
    pic_square () const
    {
      return this->pic_square_;
    }

    user::pic_square_optional& user::
    pic_square ()
    {
      return this->pic_square_;
    }

    void user::
    pic_square (const pic_square_type& x)
    {
      this->pic_square_.set (x);
    }

    void user::
    pic_square (const pic_square_optional& x)
    {
      this->pic_square_ = x;
    }

    void user::
    pic_square (::std::auto_ptr< pic_square_type > x)
    {
      this->pic_square_.set (x);
    }

    const user::has_added_app_optional& user::
    has_added_app () const
    {
      return this->has_added_app_;
    }

    user::has_added_app_optional& user::
    has_added_app ()
    {
      return this->has_added_app_;
    }

    void user::
    has_added_app (const has_added_app_type& x)
    {
      this->has_added_app_.set (x);
    }

    void user::
    has_added_app (const has_added_app_optional& x)
    {
      this->has_added_app_ = x;
    }


    // friend_info
    // 

    const friend_info::uid1_optional& friend_info::
    uid1 () const
    {
      return this->uid1_;
    }

    friend_info::uid1_optional& friend_info::
    uid1 ()
    {
      return this->uid1_;
    }

    void friend_info::
    uid1 (const uid1_type& x)
    {
      this->uid1_.set (x);
    }

    void friend_info::
    uid1 (const uid1_optional& x)
    {
      this->uid1_ = x;
    }

    void friend_info::
    uid1 (::std::auto_ptr< uid1_type > x)
    {
      this->uid1_.set (x);
    }

    const friend_info::uid2_optional& friend_info::
    uid2 () const
    {
      return this->uid2_;
    }

    friend_info::uid2_optional& friend_info::
    uid2 ()
    {
      return this->uid2_;
    }

    void friend_info::
    uid2 (const uid2_type& x)
    {
      this->uid2_.set (x);
    }

    void friend_info::
    uid2 (const uid2_optional& x)
    {
      this->uid2_ = x;
    }

    void friend_info::
    uid2 (::std::auto_ptr< uid2_type > x)
    {
      this->uid2_.set (x);
    }

    const friend_info::are_friends_optional& friend_info::
    are_friends () const
    {
      return this->are_friends_;
    }

    friend_info::are_friends_optional& friend_info::
    are_friends ()
    {
      return this->are_friends_;
    }

    void friend_info::
    are_friends (const are_friends_type& x)
    {
      this->are_friends_.set (x);
    }

    void friend_info::
    are_friends (const are_friends_optional& x)
    {
      this->are_friends_ = x;
    }


    // friendlist
    // 

    const friendlist::flid_type& friendlist::
    flid () const
    {
      return this->flid_.get ();
    }

    friendlist::flid_type& friendlist::
    flid ()
    {
      return this->flid_.get ();
    }

    void friendlist::
    flid (const flid_type& x)
    {
      this->flid_.set (x);
    }

    void friendlist::
    flid (::std::auto_ptr< flid_type > x)
    {
      this->flid_.set (x);
    }

    const friendlist::name_type& friendlist::
    name () const
    {
      return this->name_.get ();
    }

    friendlist::name_type& friendlist::
    name ()
    {
      return this->name_.get ();
    }

    void friendlist::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void friendlist::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const friendlist::owner_optional& friendlist::
    owner () const
    {
      return this->owner_;
    }

    friendlist::owner_optional& friendlist::
    owner ()
    {
      return this->owner_;
    }

    void friendlist::
    owner (const owner_type& x)
    {
      this->owner_.set (x);
    }

    void friendlist::
    owner (const owner_optional& x)
    {
      this->owner_ = x;
    }

    void friendlist::
    owner (::std::auto_ptr< owner_type > x)
    {
      this->owner_.set (x);
    }


    // object_type_info
    // 

    const object_type_info::name_type& object_type_info::
    name () const
    {
      return this->name_.get ();
    }

    object_type_info::name_type& object_type_info::
    name ()
    {
      return this->name_.get ();
    }

    void object_type_info::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void object_type_info::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const object_type_info::object_class_type& object_type_info::
    object_class () const
    {
      return this->object_class_.get ();
    }

    object_type_info::object_class_type& object_type_info::
    object_class ()
    {
      return this->object_class_.get ();
    }

    void object_type_info::
    object_class (const object_class_type& x)
    {
      this->object_class_.set (x);
    }


    // object_property_info
    // 

    const object_property_info::name_type& object_property_info::
    name () const
    {
      return this->name_.get ();
    }

    object_property_info::name_type& object_property_info::
    name ()
    {
      return this->name_.get ();
    }

    void object_property_info::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void object_property_info::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const object_property_info::data_type_type& object_property_info::
    data_type () const
    {
      return this->data_type_.get ();
    }

    object_property_info::data_type_type& object_property_info::
    data_type ()
    {
      return this->data_type_.get ();
    }

    void object_property_info::
    data_type (const data_type_type& x)
    {
      this->data_type_.set (x);
    }

    const object_property_info::index_type_type& object_property_info::
    index_type () const
    {
      return this->index_type_.get ();
    }

    object_property_info::index_type_type& object_property_info::
    index_type ()
    {
      return this->index_type_.get ();
    }

    void object_property_info::
    index_type (const index_type_type& x)
    {
      this->index_type_.set (x);
    }


    // assoc_object_type
    // 

    const assoc_object_type::alias_type& assoc_object_type::
    alias () const
    {
      return this->alias_.get ();
    }

    assoc_object_type::alias_type& assoc_object_type::
    alias ()
    {
      return this->alias_.get ();
    }

    void assoc_object_type::
    alias (const alias_type& x)
    {
      this->alias_.set (x);
    }

    void assoc_object_type::
    alias (::std::auto_ptr< alias_type > x)
    {
      this->alias_.set (x);
    }

    const assoc_object_type::object_type_type& assoc_object_type::
    object_type () const
    {
      return this->object_type_.get ();
    }

    assoc_object_type::object_type_type& assoc_object_type::
    object_type ()
    {
      return this->object_type_.get ();
    }

    void assoc_object_type::
    object_type (const object_type_type& x)
    {
      this->object_type_.set (x);
    }

    void assoc_object_type::
    object_type (::std::auto_ptr< object_type_type > x)
    {
      this->object_type_.set (x);
    }

    const assoc_object_type::unique_type& assoc_object_type::
    unique () const
    {
      return this->unique_.get ();
    }

    assoc_object_type::unique_type& assoc_object_type::
    unique ()
    {
      return this->unique_.get ();
    }

    void assoc_object_type::
    unique (const unique_type& x)
    {
      this->unique_.set (x);
    }


    // object_assoc_info
    // 

    const object_assoc_info::name_type& object_assoc_info::
    name () const
    {
      return this->name_.get ();
    }

    object_assoc_info::name_type& object_assoc_info::
    name ()
    {
      return this->name_.get ();
    }

    void object_assoc_info::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void object_assoc_info::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const object_assoc_info::assoc_type_type& object_assoc_info::
    assoc_type () const
    {
      return this->assoc_type_.get ();
    }

    object_assoc_info::assoc_type_type& object_assoc_info::
    assoc_type ()
    {
      return this->assoc_type_.get ();
    }

    void object_assoc_info::
    assoc_type (const assoc_type_type& x)
    {
      this->assoc_type_.set (x);
    }

    const object_assoc_info::assoc_info1_type& object_assoc_info::
    assoc_info1 () const
    {
      return this->assoc_info1_.get ();
    }

    object_assoc_info::assoc_info1_type& object_assoc_info::
    assoc_info1 ()
    {
      return this->assoc_info1_.get ();
    }

    void object_assoc_info::
    assoc_info1 (const assoc_info1_type& x)
    {
      this->assoc_info1_.set (x);
    }

    void object_assoc_info::
    assoc_info1 (::std::auto_ptr< assoc_info1_type > x)
    {
      this->assoc_info1_.set (x);
    }

    const object_assoc_info::assoc_info2_type& object_assoc_info::
    assoc_info2 () const
    {
      return this->assoc_info2_.get ();
    }

    object_assoc_info::assoc_info2_type& object_assoc_info::
    assoc_info2 ()
    {
      return this->assoc_info2_.get ();
    }

    void object_assoc_info::
    assoc_info2 (const assoc_info2_type& x)
    {
      this->assoc_info2_.set (x);
    }

    void object_assoc_info::
    assoc_info2 (::std::auto_ptr< assoc_info2_type > x)
    {
      this->assoc_info2_.set (x);
    }


    // object_association
    // 

    const object_association::name_type& object_association::
    name () const
    {
      return this->name_.get ();
    }

    object_association::name_type& object_association::
    name ()
    {
      return this->name_.get ();
    }

    void object_association::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void object_association::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const object_association::id1_type& object_association::
    id1 () const
    {
      return this->id1_.get ();
    }

    object_association::id1_type& object_association::
    id1 ()
    {
      return this->id1_.get ();
    }

    void object_association::
    id1 (const id1_type& x)
    {
      this->id1_.set (x);
    }

    const object_association::id2_type& object_association::
    id2 () const
    {
      return this->id2_.get ();
    }

    object_association::id2_type& object_association::
    id2 ()
    {
      return this->id2_.get ();
    }

    void object_association::
    id2 (const id2_type& x)
    {
      this->id2_.set (x);
    }

    const object_association::data_type& object_association::
    data () const
    {
      return this->data_.get ();
    }

    object_association::data_type& object_association::
    data ()
    {
      return this->data_.get ();
    }

    void object_association::
    data (const data_type& x)
    {
      this->data_.set (x);
    }

    void object_association::
    data (::std::auto_ptr< data_type > x)
    {
      this->data_.set (x);
    }

    const object_association::time_type& object_association::
    time () const
    {
      return this->time_.get ();
    }

    object_association::time_type& object_association::
    time ()
    {
      return this->time_.get ();
    }

    void object_association::
    time (const time_type& x)
    {
      this->time_.set (x);
    }

    void object_association::
    time (::std::auto_ptr< time_type > x)
    {
      this->time_.set (x);
    }


    // listing
    // 

    const listing::listing_id_type& listing::
    listing_id () const
    {
      return this->listing_id_.get ();
    }

    listing::listing_id_type& listing::
    listing_id ()
    {
      return this->listing_id_.get ();
    }

    void listing::
    listing_id (const listing_id_type& x)
    {
      this->listing_id_.set (x);
    }

    void listing::
    listing_id (::std::auto_ptr< listing_id_type > x)
    {
      this->listing_id_.set (x);
    }

    const listing::url_type& listing::
    url () const
    {
      return this->url_.get ();
    }

    listing::url_type& listing::
    url ()
    {
      return this->url_.get ();
    }

    void listing::
    url (const url_type& x)
    {
      this->url_.set (x);
    }

    void listing::
    url (::std::auto_ptr< url_type > x)
    {
      this->url_.set (x);
    }

    const listing::title_type& listing::
    title () const
    {
      return this->title_.get ();
    }

    listing::title_type& listing::
    title ()
    {
      return this->title_.get ();
    }

    void listing::
    title (const title_type& x)
    {
      this->title_.set (x);
    }

    void listing::
    title (::std::auto_ptr< title_type > x)
    {
      this->title_.set (x);
    }

    const listing::description_type& listing::
    description () const
    {
      return this->description_.get ();
    }

    listing::description_type& listing::
    description ()
    {
      return this->description_.get ();
    }

    void listing::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void listing::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const listing::price_optional& listing::
    price () const
    {
      return this->price_;
    }

    listing::price_optional& listing::
    price ()
    {
      return this->price_;
    }

    void listing::
    price (const price_type& x)
    {
      this->price_.set (x);
    }

    void listing::
    price (const price_optional& x)
    {
      this->price_ = x;
    }

    const listing::poster_type& listing::
    poster () const
    {
      return this->poster_.get ();
    }

    listing::poster_type& listing::
    poster ()
    {
      return this->poster_.get ();
    }

    void listing::
    poster (const poster_type& x)
    {
      this->poster_.set (x);
    }

    void listing::
    poster (::std::auto_ptr< poster_type > x)
    {
      this->poster_.set (x);
    }

    const listing::update_time_type& listing::
    update_time () const
    {
      return this->update_time_.get ();
    }

    listing::update_time_type& listing::
    update_time ()
    {
      return this->update_time_.get ();
    }

    void listing::
    update_time (const update_time_type& x)
    {
      this->update_time_.set (x);
    }

    void listing::
    update_time (::std::auto_ptr< update_time_type > x)
    {
      this->update_time_.set (x);
    }

    const listing::category_type& listing::
    category () const
    {
      return this->category_.get ();
    }

    listing::category_type& listing::
    category ()
    {
      return this->category_.get ();
    }

    void listing::
    category (const category_type& x)
    {
      this->category_.set (x);
    }

    void listing::
    category (::std::auto_ptr< category_type > x)
    {
      this->category_.set (x);
    }

    const listing::subcategory_type& listing::
    subcategory () const
    {
      return this->subcategory_.get ();
    }

    listing::subcategory_type& listing::
    subcategory ()
    {
      return this->subcategory_.get ();
    }

    void listing::
    subcategory (const subcategory_type& x)
    {
      this->subcategory_.set (x);
    }

    void listing::
    subcategory (::std::auto_ptr< subcategory_type > x)
    {
      this->subcategory_.set (x);
    }

    const listing::image_urls_optional& listing::
    image_urls () const
    {
      return this->image_urls_;
    }

    listing::image_urls_optional& listing::
    image_urls ()
    {
      return this->image_urls_;
    }

    void listing::
    image_urls (const image_urls_type& x)
    {
      this->image_urls_.set (x);
    }

    void listing::
    image_urls (const image_urls_optional& x)
    {
      this->image_urls_ = x;
    }

    void listing::
    image_urls (::std::auto_ptr< image_urls_type > x)
    {
      this->image_urls_.set (x);
    }

    const listing::condition_optional& listing::
    condition () const
    {
      return this->condition_;
    }

    listing::condition_optional& listing::
    condition ()
    {
      return this->condition_;
    }

    void listing::
    condition (const condition_type& x)
    {
      this->condition_.set (x);
    }

    void listing::
    condition (const condition_optional& x)
    {
      this->condition_ = x;
    }

    const listing::isbn_optional& listing::
    isbn () const
    {
      return this->isbn_;
    }

    listing::isbn_optional& listing::
    isbn ()
    {
      return this->isbn_;
    }

    void listing::
    isbn (const isbn_type& x)
    {
      this->isbn_.set (x);
    }

    void listing::
    isbn (const isbn_optional& x)
    {
      this->isbn_ = x;
    }

    void listing::
    isbn (::std::auto_ptr< isbn_type > x)
    {
      this->isbn_.set (x);
    }

    const listing::num_beds_optional& listing::
    num_beds () const
    {
      return this->num_beds_;
    }

    listing::num_beds_optional& listing::
    num_beds ()
    {
      return this->num_beds_;
    }

    void listing::
    num_beds (const num_beds_type& x)
    {
      this->num_beds_.set (x);
    }

    void listing::
    num_beds (const num_beds_optional& x)
    {
      this->num_beds_ = x;
    }

    void listing::
    num_beds (::std::auto_ptr< num_beds_type > x)
    {
      this->num_beds_.set (x);
    }

    const listing::num_maths_optional& listing::
    num_maths () const
    {
      return this->num_maths_;
    }

    listing::num_maths_optional& listing::
    num_maths ()
    {
      return this->num_maths_;
    }

    void listing::
    num_maths (const num_maths_type& x)
    {
      this->num_maths_.set (x);
    }

    void listing::
    num_maths (const num_maths_optional& x)
    {
      this->num_maths_ = x;
    }

    void listing::
    num_maths (::std::auto_ptr< num_maths_type > x)
    {
      this->num_maths_.set (x);
    }

    const listing::dogs_optional& listing::
    dogs () const
    {
      return this->dogs_;
    }

    listing::dogs_optional& listing::
    dogs ()
    {
      return this->dogs_;
    }

    void listing::
    dogs (const dogs_type& x)
    {
      this->dogs_.set (x);
    }

    void listing::
    dogs (const dogs_optional& x)
    {
      this->dogs_ = x;
    }

    void listing::
    dogs (::std::auto_ptr< dogs_type > x)
    {
      this->dogs_.set (x);
    }

    const listing::cats_optional& listing::
    cats () const
    {
      return this->cats_;
    }

    listing::cats_optional& listing::
    cats ()
    {
      return this->cats_;
    }

    void listing::
    cats (const cats_type& x)
    {
      this->cats_.set (x);
    }

    void listing::
    cats (const cats_optional& x)
    {
      this->cats_ = x;
    }

    void listing::
    cats (::std::auto_ptr< cats_type > x)
    {
      this->cats_.set (x);
    }

    const listing::smoking_optional& listing::
    smoking () const
    {
      return this->smoking_;
    }

    listing::smoking_optional& listing::
    smoking ()
    {
      return this->smoking_;
    }

    void listing::
    smoking (const smoking_type& x)
    {
      this->smoking_.set (x);
    }

    void listing::
    smoking (const smoking_optional& x)
    {
      this->smoking_ = x;
    }

    void listing::
    smoking (::std::auto_ptr< smoking_type > x)
    {
      this->smoking_.set (x);
    }

    const listing::square_footage_optional& listing::
    square_footage () const
    {
      return this->square_footage_;
    }

    listing::square_footage_optional& listing::
    square_footage ()
    {
      return this->square_footage_;
    }

    void listing::
    square_footage (const square_footage_type& x)
    {
      this->square_footage_.set (x);
    }

    void listing::
    square_footage (const square_footage_optional& x)
    {
      this->square_footage_ = x;
    }

    void listing::
    square_footage (::std::auto_ptr< square_footage_type > x)
    {
      this->square_footage_.set (x);
    }

    const listing::street_optional& listing::
    street () const
    {
      return this->street_;
    }

    listing::street_optional& listing::
    street ()
    {
      return this->street_;
    }

    void listing::
    street (const street_type& x)
    {
      this->street_.set (x);
    }

    void listing::
    street (const street_optional& x)
    {
      this->street_ = x;
    }

    void listing::
    street (::std::auto_ptr< street_type > x)
    {
      this->street_.set (x);
    }

    const listing::crossstreet_optional& listing::
    crossstreet () const
    {
      return this->crossstreet_;
    }

    listing::crossstreet_optional& listing::
    crossstreet ()
    {
      return this->crossstreet_;
    }

    void listing::
    crossstreet (const crossstreet_type& x)
    {
      this->crossstreet_.set (x);
    }

    void listing::
    crossstreet (const crossstreet_optional& x)
    {
      this->crossstreet_ = x;
    }

    void listing::
    crossstreet (::std::auto_ptr< crossstreet_type > x)
    {
      this->crossstreet_.set (x);
    }

    const listing::postal_optional& listing::
    postal () const
    {
      return this->postal_;
    }

    listing::postal_optional& listing::
    postal ()
    {
      return this->postal_;
    }

    void listing::
    postal (const postal_type& x)
    {
      this->postal_.set (x);
    }

    void listing::
    postal (const postal_optional& x)
    {
      this->postal_ = x;
    }

    void listing::
    postal (::std::auto_ptr< postal_type > x)
    {
      this->postal_.set (x);
    }

    const listing::rent_optional& listing::
    rent () const
    {
      return this->rent_;
    }

    listing::rent_optional& listing::
    rent ()
    {
      return this->rent_;
    }

    void listing::
    rent (const rent_type& x)
    {
      this->rent_.set (x);
    }

    void listing::
    rent (const rent_optional& x)
    {
      this->rent_ = x;
    }

    void listing::
    rent (::std::auto_ptr< rent_type > x)
    {
      this->rent_.set (x);
    }

    const listing::pay_optional& listing::
    pay () const
    {
      return this->pay_;
    }

    listing::pay_optional& listing::
    pay ()
    {
      return this->pay_;
    }

    void listing::
    pay (const pay_type& x)
    {
      this->pay_.set (x);
    }

    void listing::
    pay (const pay_optional& x)
    {
      this->pay_ = x;
    }

    void listing::
    pay (::std::auto_ptr< pay_type > x)
    {
      this->pay_.set (x);
    }

    const listing::full_optional& listing::
    full () const
    {
      return this->full_;
    }

    listing::full_optional& listing::
    full ()
    {
      return this->full_;
    }

    void listing::
    full (const full_type& x)
    {
      this->full_.set (x);
    }

    void listing::
    full (const full_optional& x)
    {
      this->full_ = x;
    }

    void listing::
    full (::std::auto_ptr< full_type > x)
    {
      this->full_.set (x);
    }

    const listing::intern_optional& listing::
    intern () const
    {
      return this->intern_;
    }

    listing::intern_optional& listing::
    intern ()
    {
      return this->intern_;
    }

    void listing::
    intern (const intern_type& x)
    {
      this->intern_.set (x);
    }

    void listing::
    intern (const intern_optional& x)
    {
      this->intern_ = x;
    }

    void listing::
    intern (::std::auto_ptr< intern_type > x)
    {
      this->intern_.set (x);
    }

    const listing::summer_optional& listing::
    summer () const
    {
      return this->summer_;
    }

    listing::summer_optional& listing::
    summer ()
    {
      return this->summer_;
    }

    void listing::
    summer (const summer_type& x)
    {
      this->summer_.set (x);
    }

    void listing::
    summer (const summer_optional& x)
    {
      this->summer_ = x;
    }

    void listing::
    summer (::std::auto_ptr< summer_type > x)
    {
      this->summer_.set (x);
    }

    const listing::nonprofit_optional& listing::
    nonprofit () const
    {
      return this->nonprofit_;
    }

    listing::nonprofit_optional& listing::
    nonprofit ()
    {
      return this->nonprofit_;
    }

    void listing::
    nonprofit (const nonprofit_type& x)
    {
      this->nonprofit_.set (x);
    }

    void listing::
    nonprofit (const nonprofit_optional& x)
    {
      this->nonprofit_ = x;
    }

    void listing::
    nonprofit (::std::auto_ptr< nonprofit_type > x)
    {
      this->nonprofit_.set (x);
    }

    const listing::pay_type_optional& listing::
    pay_type1 () const
    {
      return this->pay_type_;
    }

    listing::pay_type_optional& listing::
    pay_type1 ()
    {
      return this->pay_type_;
    }

    void listing::
    pay_type1 (const pay_type_type& x)
    {
      this->pay_type_.set (x);
    }

    void listing::
    pay_type1 (const pay_type_optional& x)
    {
      this->pay_type_ = x;
    }

    void listing::
    pay_type1 (::std::auto_ptr< pay_type_type > x)
    {
      this->pay_type_.set (x);
    }


    // preference
    // 

    const preference::pref_id_type& preference::
    pref_id () const
    {
      return this->pref_id_.get ();
    }

    preference::pref_id_type& preference::
    pref_id ()
    {
      return this->pref_id_.get ();
    }

    void preference::
    pref_id (const pref_id_type& x)
    {
      this->pref_id_.set (x);
    }

    const preference::value_type& preference::
    value () const
    {
      return this->value_.get ();
    }

    preference::value_type& preference::
    value ()
    {
      return this->value_.get ();
    }

    void preference::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void preference::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // page_hours
    // 

    const page_hours::mon_1_open_type& page_hours::
    mon_1_open () const
    {
      return this->mon_1_open_.get ();
    }

    page_hours::mon_1_open_type& page_hours::
    mon_1_open ()
    {
      return this->mon_1_open_.get ();
    }

    void page_hours::
    mon_1_open (const mon_1_open_type& x)
    {
      this->mon_1_open_.set (x);
    }

    void page_hours::
    mon_1_open (::std::auto_ptr< mon_1_open_type > x)
    {
      this->mon_1_open_.set (x);
    }

    const page_hours::mon_1_close_type& page_hours::
    mon_1_close () const
    {
      return this->mon_1_close_.get ();
    }

    page_hours::mon_1_close_type& page_hours::
    mon_1_close ()
    {
      return this->mon_1_close_.get ();
    }

    void page_hours::
    mon_1_close (const mon_1_close_type& x)
    {
      this->mon_1_close_.set (x);
    }

    void page_hours::
    mon_1_close (::std::auto_ptr< mon_1_close_type > x)
    {
      this->mon_1_close_.set (x);
    }

    const page_hours::tue_1_open_type& page_hours::
    tue_1_open () const
    {
      return this->tue_1_open_.get ();
    }

    page_hours::tue_1_open_type& page_hours::
    tue_1_open ()
    {
      return this->tue_1_open_.get ();
    }

    void page_hours::
    tue_1_open (const tue_1_open_type& x)
    {
      this->tue_1_open_.set (x);
    }

    void page_hours::
    tue_1_open (::std::auto_ptr< tue_1_open_type > x)
    {
      this->tue_1_open_.set (x);
    }

    const page_hours::tue_1_close_type& page_hours::
    tue_1_close () const
    {
      return this->tue_1_close_.get ();
    }

    page_hours::tue_1_close_type& page_hours::
    tue_1_close ()
    {
      return this->tue_1_close_.get ();
    }

    void page_hours::
    tue_1_close (const tue_1_close_type& x)
    {
      this->tue_1_close_.set (x);
    }

    void page_hours::
    tue_1_close (::std::auto_ptr< tue_1_close_type > x)
    {
      this->tue_1_close_.set (x);
    }

    const page_hours::wed_1_open_type& page_hours::
    wed_1_open () const
    {
      return this->wed_1_open_.get ();
    }

    page_hours::wed_1_open_type& page_hours::
    wed_1_open ()
    {
      return this->wed_1_open_.get ();
    }

    void page_hours::
    wed_1_open (const wed_1_open_type& x)
    {
      this->wed_1_open_.set (x);
    }

    void page_hours::
    wed_1_open (::std::auto_ptr< wed_1_open_type > x)
    {
      this->wed_1_open_.set (x);
    }

    const page_hours::thu_1_open_type& page_hours::
    thu_1_open () const
    {
      return this->thu_1_open_.get ();
    }

    page_hours::thu_1_open_type& page_hours::
    thu_1_open ()
    {
      return this->thu_1_open_.get ();
    }

    void page_hours::
    thu_1_open (const thu_1_open_type& x)
    {
      this->thu_1_open_.set (x);
    }

    void page_hours::
    thu_1_open (::std::auto_ptr< thu_1_open_type > x)
    {
      this->thu_1_open_.set (x);
    }

    const page_hours::thu_1_close_type& page_hours::
    thu_1_close () const
    {
      return this->thu_1_close_.get ();
    }

    page_hours::thu_1_close_type& page_hours::
    thu_1_close ()
    {
      return this->thu_1_close_.get ();
    }

    void page_hours::
    thu_1_close (const thu_1_close_type& x)
    {
      this->thu_1_close_.set (x);
    }

    void page_hours::
    thu_1_close (::std::auto_ptr< thu_1_close_type > x)
    {
      this->thu_1_close_.set (x);
    }

    const page_hours::fri_1_open_type& page_hours::
    fri_1_open () const
    {
      return this->fri_1_open_.get ();
    }

    page_hours::fri_1_open_type& page_hours::
    fri_1_open ()
    {
      return this->fri_1_open_.get ();
    }

    void page_hours::
    fri_1_open (const fri_1_open_type& x)
    {
      this->fri_1_open_.set (x);
    }

    void page_hours::
    fri_1_open (::std::auto_ptr< fri_1_open_type > x)
    {
      this->fri_1_open_.set (x);
    }

    const page_hours::fri_1_close_type& page_hours::
    fri_1_close () const
    {
      return this->fri_1_close_.get ();
    }

    page_hours::fri_1_close_type& page_hours::
    fri_1_close ()
    {
      return this->fri_1_close_.get ();
    }

    void page_hours::
    fri_1_close (const fri_1_close_type& x)
    {
      this->fri_1_close_.set (x);
    }

    void page_hours::
    fri_1_close (::std::auto_ptr< fri_1_close_type > x)
    {
      this->fri_1_close_.set (x);
    }

    const page_hours::sat_1_open_type& page_hours::
    sat_1_open () const
    {
      return this->sat_1_open_.get ();
    }

    page_hours::sat_1_open_type& page_hours::
    sat_1_open ()
    {
      return this->sat_1_open_.get ();
    }

    void page_hours::
    sat_1_open (const sat_1_open_type& x)
    {
      this->sat_1_open_.set (x);
    }

    void page_hours::
    sat_1_open (::std::auto_ptr< sat_1_open_type > x)
    {
      this->sat_1_open_.set (x);
    }

    const page_hours::sat_1_close_type& page_hours::
    sat_1_close () const
    {
      return this->sat_1_close_.get ();
    }

    page_hours::sat_1_close_type& page_hours::
    sat_1_close ()
    {
      return this->sat_1_close_.get ();
    }

    void page_hours::
    sat_1_close (const sat_1_close_type& x)
    {
      this->sat_1_close_.set (x);
    }

    void page_hours::
    sat_1_close (::std::auto_ptr< sat_1_close_type > x)
    {
      this->sat_1_close_.set (x);
    }

    const page_hours::sun_1_open_type& page_hours::
    sun_1_open () const
    {
      return this->sun_1_open_.get ();
    }

    page_hours::sun_1_open_type& page_hours::
    sun_1_open ()
    {
      return this->sun_1_open_.get ();
    }

    void page_hours::
    sun_1_open (const sun_1_open_type& x)
    {
      this->sun_1_open_.set (x);
    }

    void page_hours::
    sun_1_open (::std::auto_ptr< sun_1_open_type > x)
    {
      this->sun_1_open_.set (x);
    }

    const page_hours::sun_1_close_type& page_hours::
    sun_1_close () const
    {
      return this->sun_1_close_.get ();
    }

    page_hours::sun_1_close_type& page_hours::
    sun_1_close ()
    {
      return this->sun_1_close_.get ();
    }

    void page_hours::
    sun_1_close (const sun_1_close_type& x)
    {
      this->sun_1_close_.set (x);
    }

    void page_hours::
    sun_1_close (::std::auto_ptr< sun_1_close_type > x)
    {
      this->sun_1_close_.set (x);
    }

    const page_hours::mon_2_open_type& page_hours::
    mon_2_open () const
    {
      return this->mon_2_open_.get ();
    }

    page_hours::mon_2_open_type& page_hours::
    mon_2_open ()
    {
      return this->mon_2_open_.get ();
    }

    void page_hours::
    mon_2_open (const mon_2_open_type& x)
    {
      this->mon_2_open_.set (x);
    }

    void page_hours::
    mon_2_open (::std::auto_ptr< mon_2_open_type > x)
    {
      this->mon_2_open_.set (x);
    }

    const page_hours::mon_2_close_type& page_hours::
    mon_2_close () const
    {
      return this->mon_2_close_.get ();
    }

    page_hours::mon_2_close_type& page_hours::
    mon_2_close ()
    {
      return this->mon_2_close_.get ();
    }

    void page_hours::
    mon_2_close (const mon_2_close_type& x)
    {
      this->mon_2_close_.set (x);
    }

    void page_hours::
    mon_2_close (::std::auto_ptr< mon_2_close_type > x)
    {
      this->mon_2_close_.set (x);
    }

    const page_hours::tue_2_open_type& page_hours::
    tue_2_open () const
    {
      return this->tue_2_open_.get ();
    }

    page_hours::tue_2_open_type& page_hours::
    tue_2_open ()
    {
      return this->tue_2_open_.get ();
    }

    void page_hours::
    tue_2_open (const tue_2_open_type& x)
    {
      this->tue_2_open_.set (x);
    }

    void page_hours::
    tue_2_open (::std::auto_ptr< tue_2_open_type > x)
    {
      this->tue_2_open_.set (x);
    }

    const page_hours::tue_2_close_type& page_hours::
    tue_2_close () const
    {
      return this->tue_2_close_.get ();
    }

    page_hours::tue_2_close_type& page_hours::
    tue_2_close ()
    {
      return this->tue_2_close_.get ();
    }

    void page_hours::
    tue_2_close (const tue_2_close_type& x)
    {
      this->tue_2_close_.set (x);
    }

    void page_hours::
    tue_2_close (::std::auto_ptr< tue_2_close_type > x)
    {
      this->tue_2_close_.set (x);
    }

    const page_hours::wed_2_open_type& page_hours::
    wed_2_open () const
    {
      return this->wed_2_open_.get ();
    }

    page_hours::wed_2_open_type& page_hours::
    wed_2_open ()
    {
      return this->wed_2_open_.get ();
    }

    void page_hours::
    wed_2_open (const wed_2_open_type& x)
    {
      this->wed_2_open_.set (x);
    }

    void page_hours::
    wed_2_open (::std::auto_ptr< wed_2_open_type > x)
    {
      this->wed_2_open_.set (x);
    }

    const page_hours::wed_2_close_type& page_hours::
    wed_2_close () const
    {
      return this->wed_2_close_.get ();
    }

    page_hours::wed_2_close_type& page_hours::
    wed_2_close ()
    {
      return this->wed_2_close_.get ();
    }

    void page_hours::
    wed_2_close (const wed_2_close_type& x)
    {
      this->wed_2_close_.set (x);
    }

    void page_hours::
    wed_2_close (::std::auto_ptr< wed_2_close_type > x)
    {
      this->wed_2_close_.set (x);
    }

    const page_hours::thu_2_open_type& page_hours::
    thu_2_open () const
    {
      return this->thu_2_open_.get ();
    }

    page_hours::thu_2_open_type& page_hours::
    thu_2_open ()
    {
      return this->thu_2_open_.get ();
    }

    void page_hours::
    thu_2_open (const thu_2_open_type& x)
    {
      this->thu_2_open_.set (x);
    }

    void page_hours::
    thu_2_open (::std::auto_ptr< thu_2_open_type > x)
    {
      this->thu_2_open_.set (x);
    }

    const page_hours::thu_2_close_type& page_hours::
    thu_2_close () const
    {
      return this->thu_2_close_.get ();
    }

    page_hours::thu_2_close_type& page_hours::
    thu_2_close ()
    {
      return this->thu_2_close_.get ();
    }

    void page_hours::
    thu_2_close (const thu_2_close_type& x)
    {
      this->thu_2_close_.set (x);
    }

    void page_hours::
    thu_2_close (::std::auto_ptr< thu_2_close_type > x)
    {
      this->thu_2_close_.set (x);
    }

    const page_hours::fri_2_open_type& page_hours::
    fri_2_open () const
    {
      return this->fri_2_open_.get ();
    }

    page_hours::fri_2_open_type& page_hours::
    fri_2_open ()
    {
      return this->fri_2_open_.get ();
    }

    void page_hours::
    fri_2_open (const fri_2_open_type& x)
    {
      this->fri_2_open_.set (x);
    }

    void page_hours::
    fri_2_open (::std::auto_ptr< fri_2_open_type > x)
    {
      this->fri_2_open_.set (x);
    }

    const page_hours::fri_2_close_type& page_hours::
    fri_2_close () const
    {
      return this->fri_2_close_.get ();
    }

    page_hours::fri_2_close_type& page_hours::
    fri_2_close ()
    {
      return this->fri_2_close_.get ();
    }

    void page_hours::
    fri_2_close (const fri_2_close_type& x)
    {
      this->fri_2_close_.set (x);
    }

    void page_hours::
    fri_2_close (::std::auto_ptr< fri_2_close_type > x)
    {
      this->fri_2_close_.set (x);
    }

    const page_hours::sat_2_open_type& page_hours::
    sat_2_open () const
    {
      return this->sat_2_open_.get ();
    }

    page_hours::sat_2_open_type& page_hours::
    sat_2_open ()
    {
      return this->sat_2_open_.get ();
    }

    void page_hours::
    sat_2_open (const sat_2_open_type& x)
    {
      this->sat_2_open_.set (x);
    }

    void page_hours::
    sat_2_open (::std::auto_ptr< sat_2_open_type > x)
    {
      this->sat_2_open_.set (x);
    }

    const page_hours::sat_2_close_type& page_hours::
    sat_2_close () const
    {
      return this->sat_2_close_.get ();
    }

    page_hours::sat_2_close_type& page_hours::
    sat_2_close ()
    {
      return this->sat_2_close_.get ();
    }

    void page_hours::
    sat_2_close (const sat_2_close_type& x)
    {
      this->sat_2_close_.set (x);
    }

    void page_hours::
    sat_2_close (::std::auto_ptr< sat_2_close_type > x)
    {
      this->sat_2_close_.set (x);
    }

    const page_hours::sun_2_open_type& page_hours::
    sun_2_open () const
    {
      return this->sun_2_open_.get ();
    }

    page_hours::sun_2_open_type& page_hours::
    sun_2_open ()
    {
      return this->sun_2_open_.get ();
    }

    void page_hours::
    sun_2_open (const sun_2_open_type& x)
    {
      this->sun_2_open_.set (x);
    }

    void page_hours::
    sun_2_open (::std::auto_ptr< sun_2_open_type > x)
    {
      this->sun_2_open_.set (x);
    }

    const page_hours::sun_2_close_type& page_hours::
    sun_2_close () const
    {
      return this->sun_2_close_.get ();
    }

    page_hours::sun_2_close_type& page_hours::
    sun_2_close ()
    {
      return this->sun_2_close_.get ();
    }

    void page_hours::
    sun_2_close (const sun_2_close_type& x)
    {
      this->sun_2_close_.set (x);
    }

    void page_hours::
    sun_2_close (::std::auto_ptr< sun_2_close_type > x)
    {
      this->sun_2_close_.set (x);
    }


    // page_parking
    // 

    const page_parking::street_type& page_parking::
    street () const
    {
      return this->street_.get ();
    }

    page_parking::street_type& page_parking::
    street ()
    {
      return this->street_.get ();
    }

    void page_parking::
    street (const street_type& x)
    {
      this->street_.set (x);
    }

    const page_parking::lot_type& page_parking::
    lot () const
    {
      return this->lot_.get ();
    }

    page_parking::lot_type& page_parking::
    lot ()
    {
      return this->lot_.get ();
    }

    void page_parking::
    lot (const lot_type& x)
    {
      this->lot_.set (x);
    }

    const page_parking::valet_type& page_parking::
    valet () const
    {
      return this->valet_.get ();
    }

    page_parking::valet_type& page_parking::
    valet ()
    {
      return this->valet_.get ();
    }

    void page_parking::
    valet (const valet_type& x)
    {
      this->valet_.set (x);
    }


    // page_restaurant_services
    // 

    const page_restaurant_services::reserve_type& page_restaurant_services::
    reserve () const
    {
      return this->reserve_.get ();
    }

    page_restaurant_services::reserve_type& page_restaurant_services::
    reserve ()
    {
      return this->reserve_.get ();
    }

    void page_restaurant_services::
    reserve (const reserve_type& x)
    {
      this->reserve_.set (x);
    }

    const page_restaurant_services::walkins_type& page_restaurant_services::
    walkins () const
    {
      return this->walkins_.get ();
    }

    page_restaurant_services::walkins_type& page_restaurant_services::
    walkins ()
    {
      return this->walkins_.get ();
    }

    void page_restaurant_services::
    walkins (const walkins_type& x)
    {
      this->walkins_.set (x);
    }

    const page_restaurant_services::groups_type& page_restaurant_services::
    groups () const
    {
      return this->groups_.get ();
    }

    page_restaurant_services::groups_type& page_restaurant_services::
    groups ()
    {
      return this->groups_.get ();
    }

    void page_restaurant_services::
    groups (const groups_type& x)
    {
      this->groups_.set (x);
    }

    const page_restaurant_services::kids_type& page_restaurant_services::
    kids () const
    {
      return this->kids_.get ();
    }

    page_restaurant_services::kids_type& page_restaurant_services::
    kids ()
    {
      return this->kids_.get ();
    }

    void page_restaurant_services::
    kids (const kids_type& x)
    {
      this->kids_.set (x);
    }

    const page_restaurant_services::takeout_type& page_restaurant_services::
    takeout () const
    {
      return this->takeout_.get ();
    }

    page_restaurant_services::takeout_type& page_restaurant_services::
    takeout ()
    {
      return this->takeout_.get ();
    }

    void page_restaurant_services::
    takeout (const takeout_type& x)
    {
      this->takeout_.set (x);
    }

    const page_restaurant_services::delivery_type& page_restaurant_services::
    delivery () const
    {
      return this->delivery_.get ();
    }

    page_restaurant_services::delivery_type& page_restaurant_services::
    delivery ()
    {
      return this->delivery_.get ();
    }

    void page_restaurant_services::
    delivery (const delivery_type& x)
    {
      this->delivery_.set (x);
    }

    const page_restaurant_services::catering_type& page_restaurant_services::
    catering () const
    {
      return this->catering_.get ();
    }

    page_restaurant_services::catering_type& page_restaurant_services::
    catering ()
    {
      return this->catering_.get ();
    }

    void page_restaurant_services::
    catering (const catering_type& x)
    {
      this->catering_.set (x);
    }

    const page_restaurant_services::waiter_type& page_restaurant_services::
    waiter () const
    {
      return this->waiter_.get ();
    }

    page_restaurant_services::waiter_type& page_restaurant_services::
    waiter ()
    {
      return this->waiter_.get ();
    }

    void page_restaurant_services::
    waiter (const waiter_type& x)
    {
      this->waiter_.set (x);
    }

    const page_restaurant_services::outdoor_type& page_restaurant_services::
    outdoor () const
    {
      return this->outdoor_.get ();
    }

    page_restaurant_services::outdoor_type& page_restaurant_services::
    outdoor ()
    {
      return this->outdoor_.get ();
    }

    void page_restaurant_services::
    outdoor (const outdoor_type& x)
    {
      this->outdoor_.set (x);
    }


    // page_restaurant_specialties
    // 

    const page_restaurant_specialties::breakfast_type& page_restaurant_specialties::
    breakfast () const
    {
      return this->breakfast_.get ();
    }

    page_restaurant_specialties::breakfast_type& page_restaurant_specialties::
    breakfast ()
    {
      return this->breakfast_.get ();
    }

    void page_restaurant_specialties::
    breakfast (const breakfast_type& x)
    {
      this->breakfast_.set (x);
    }

    const page_restaurant_specialties::lunch_type& page_restaurant_specialties::
    lunch () const
    {
      return this->lunch_.get ();
    }

    page_restaurant_specialties::lunch_type& page_restaurant_specialties::
    lunch ()
    {
      return this->lunch_.get ();
    }

    void page_restaurant_specialties::
    lunch (const lunch_type& x)
    {
      this->lunch_.set (x);
    }

    const page_restaurant_specialties::dinner_type& page_restaurant_specialties::
    dinner () const
    {
      return this->dinner_.get ();
    }

    page_restaurant_specialties::dinner_type& page_restaurant_specialties::
    dinner ()
    {
      return this->dinner_.get ();
    }

    void page_restaurant_specialties::
    dinner (const dinner_type& x)
    {
      this->dinner_.set (x);
    }

    const page_restaurant_specialties::coffee_type& page_restaurant_specialties::
    coffee () const
    {
      return this->coffee_.get ();
    }

    page_restaurant_specialties::coffee_type& page_restaurant_specialties::
    coffee ()
    {
      return this->coffee_.get ();
    }

    void page_restaurant_specialties::
    coffee (const coffee_type& x)
    {
      this->coffee_.set (x);
    }

    const page_restaurant_specialties::drinks_type& page_restaurant_specialties::
    drinks () const
    {
      return this->drinks_.get ();
    }

    page_restaurant_specialties::drinks_type& page_restaurant_specialties::
    drinks ()
    {
      return this->drinks_.get ();
    }

    void page_restaurant_specialties::
    drinks (const drinks_type& x)
    {
      this->drinks_.set (x);
    }


    // page_payment_options
    // 

    const page_payment_options::cash_only_type& page_payment_options::
    cash_only () const
    {
      return this->cash_only_.get ();
    }

    page_payment_options::cash_only_type& page_payment_options::
    cash_only ()
    {
      return this->cash_only_.get ();
    }

    void page_payment_options::
    cash_only (const cash_only_type& x)
    {
      this->cash_only_.set (x);
    }

    const page_payment_options::visa_type& page_payment_options::
    visa () const
    {
      return this->visa_.get ();
    }

    page_payment_options::visa_type& page_payment_options::
    visa ()
    {
      return this->visa_.get ();
    }

    void page_payment_options::
    visa (const visa_type& x)
    {
      this->visa_.set (x);
    }

    const page_payment_options::amex_type& page_payment_options::
    amex () const
    {
      return this->amex_.get ();
    }

    page_payment_options::amex_type& page_payment_options::
    amex ()
    {
      return this->amex_.get ();
    }

    void page_payment_options::
    amex (const amex_type& x)
    {
      this->amex_.set (x);
    }

    const page_payment_options::mastercard_type& page_payment_options::
    mastercard () const
    {
      return this->mastercard_.get ();
    }

    page_payment_options::mastercard_type& page_payment_options::
    mastercard ()
    {
      return this->mastercard_.get ();
    }

    void page_payment_options::
    mastercard (const mastercard_type& x)
    {
      this->mastercard_.set (x);
    }

    const page_payment_options::discover_type& page_payment_options::
    discover () const
    {
      return this->discover_.get ();
    }

    page_payment_options::discover_type& page_payment_options::
    discover ()
    {
      return this->discover_.get ();
    }

    void page_payment_options::
    discover (const discover_type& x)
    {
      this->discover_.set (x);
    }


    // page
    // 

    const page::page_id_optional& page::
    page_id () const
    {
      return this->page_id_;
    }

    page::page_id_optional& page::
    page_id ()
    {
      return this->page_id_;
    }

    void page::
    page_id (const page_id_type& x)
    {
      this->page_id_.set (x);
    }

    void page::
    page_id (const page_id_optional& x)
    {
      this->page_id_ = x;
    }

    void page::
    page_id (::std::auto_ptr< page_id_type > x)
    {
      this->page_id_.set (x);
    }

    const page::name_optional& page::
    name () const
    {
      return this->name_;
    }

    page::name_optional& page::
    name ()
    {
      return this->name_;
    }

    void page::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void page::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void page::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const page::pic_small_optional& page::
    pic_small () const
    {
      return this->pic_small_;
    }

    page::pic_small_optional& page::
    pic_small ()
    {
      return this->pic_small_;
    }

    void page::
    pic_small (const pic_small_type& x)
    {
      this->pic_small_.set (x);
    }

    void page::
    pic_small (const pic_small_optional& x)
    {
      this->pic_small_ = x;
    }

    void page::
    pic_small (::std::auto_ptr< pic_small_type > x)
    {
      this->pic_small_.set (x);
    }

    const page::pic_big_optional& page::
    pic_big () const
    {
      return this->pic_big_;
    }

    page::pic_big_optional& page::
    pic_big ()
    {
      return this->pic_big_;
    }

    void page::
    pic_big (const pic_big_type& x)
    {
      this->pic_big_.set (x);
    }

    void page::
    pic_big (const pic_big_optional& x)
    {
      this->pic_big_ = x;
    }

    void page::
    pic_big (::std::auto_ptr< pic_big_type > x)
    {
      this->pic_big_.set (x);
    }

    const page::pic_square_optional& page::
    pic_square () const
    {
      return this->pic_square_;
    }

    page::pic_square_optional& page::
    pic_square ()
    {
      return this->pic_square_;
    }

    void page::
    pic_square (const pic_square_type& x)
    {
      this->pic_square_.set (x);
    }

    void page::
    pic_square (const pic_square_optional& x)
    {
      this->pic_square_ = x;
    }

    void page::
    pic_square (::std::auto_ptr< pic_square_type > x)
    {
      this->pic_square_.set (x);
    }

    const page::pic_optional& page::
    pic () const
    {
      return this->pic_;
    }

    page::pic_optional& page::
    pic ()
    {
      return this->pic_;
    }

    void page::
    pic (const pic_type& x)
    {
      this->pic_.set (x);
    }

    void page::
    pic (const pic_optional& x)
    {
      this->pic_ = x;
    }

    void page::
    pic (::std::auto_ptr< pic_type > x)
    {
      this->pic_.set (x);
    }

    const page::pic_large_optional& page::
    pic_large () const
    {
      return this->pic_large_;
    }

    page::pic_large_optional& page::
    pic_large ()
    {
      return this->pic_large_;
    }

    void page::
    pic_large (const pic_large_type& x)
    {
      this->pic_large_.set (x);
    }

    void page::
    pic_large (const pic_large_optional& x)
    {
      this->pic_large_ = x;
    }

    void page::
    pic_large (::std::auto_ptr< pic_large_type > x)
    {
      this->pic_large_.set (x);
    }

    const page::status_optional& page::
    status () const
    {
      return this->status_;
    }

    page::status_optional& page::
    status ()
    {
      return this->status_;
    }

    void page::
    status (const status_type& x)
    {
      this->status_.set (x);
    }

    void page::
    status (const status_optional& x)
    {
      this->status_ = x;
    }

    void page::
    status (::std::auto_ptr< status_type > x)
    {
      this->status_.set (x);
    }

    const page::type_optional& page::
    type () const
    {
      return this->type_;
    }

    page::type_optional& page::
    type ()
    {
      return this->type_;
    }

    void page::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void page::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void page::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const page::website_optional& page::
    website () const
    {
      return this->website_;
    }

    page::website_optional& page::
    website ()
    {
      return this->website_;
    }

    void page::
    website (const website_type& x)
    {
      this->website_.set (x);
    }

    void page::
    website (const website_optional& x)
    {
      this->website_ = x;
    }

    void page::
    website (::std::auto_ptr< website_type > x)
    {
      this->website_.set (x);
    }

    const page::has_added_app_optional& page::
    has_added_app () const
    {
      return this->has_added_app_;
    }

    page::has_added_app_optional& page::
    has_added_app ()
    {
      return this->has_added_app_;
    }

    void page::
    has_added_app (const has_added_app_type& x)
    {
      this->has_added_app_.set (x);
    }

    void page::
    has_added_app (const has_added_app_optional& x)
    {
      this->has_added_app_ = x;
    }

    const page::founded_optional& page::
    founded () const
    {
      return this->founded_;
    }

    page::founded_optional& page::
    founded ()
    {
      return this->founded_;
    }

    void page::
    founded (const founded_type& x)
    {
      this->founded_.set (x);
    }

    void page::
    founded (const founded_optional& x)
    {
      this->founded_ = x;
    }

    void page::
    founded (::std::auto_ptr< founded_type > x)
    {
      this->founded_.set (x);
    }

    const page::company_overview_optional& page::
    company_overview () const
    {
      return this->company_overview_;
    }

    page::company_overview_optional& page::
    company_overview ()
    {
      return this->company_overview_;
    }

    void page::
    company_overview (const company_overview_type& x)
    {
      this->company_overview_.set (x);
    }

    void page::
    company_overview (const company_overview_optional& x)
    {
      this->company_overview_ = x;
    }

    void page::
    company_overview (::std::auto_ptr< company_overview_type > x)
    {
      this->company_overview_.set (x);
    }

    const page::mission_optional& page::
    mission () const
    {
      return this->mission_;
    }

    page::mission_optional& page::
    mission ()
    {
      return this->mission_;
    }

    void page::
    mission (const mission_type& x)
    {
      this->mission_.set (x);
    }

    void page::
    mission (const mission_optional& x)
    {
      this->mission_ = x;
    }

    void page::
    mission (::std::auto_ptr< mission_type > x)
    {
      this->mission_.set (x);
    }

    const page::products_optional& page::
    products () const
    {
      return this->products_;
    }

    page::products_optional& page::
    products ()
    {
      return this->products_;
    }

    void page::
    products (const products_type& x)
    {
      this->products_.set (x);
    }

    void page::
    products (const products_optional& x)
    {
      this->products_ = x;
    }

    void page::
    products (::std::auto_ptr< products_type > x)
    {
      this->products_.set (x);
    }

    const page::location_optional& page::
    location () const
    {
      return this->location_;
    }

    page::location_optional& page::
    location ()
    {
      return this->location_;
    }

    void page::
    location (const location_type& x)
    {
      this->location_.set (x);
    }

    void page::
    location (const location_optional& x)
    {
      this->location_ = x;
    }

    void page::
    location (::std::auto_ptr< location_type > x)
    {
      this->location_.set (x);
    }

    const page::parking_optional& page::
    parking () const
    {
      return this->parking_;
    }

    page::parking_optional& page::
    parking ()
    {
      return this->parking_;
    }

    void page::
    parking (const parking_type& x)
    {
      this->parking_.set (x);
    }

    void page::
    parking (const parking_optional& x)
    {
      this->parking_ = x;
    }

    void page::
    parking (::std::auto_ptr< parking_type > x)
    {
      this->parking_.set (x);
    }

    const page::public_transit_optional& page::
    public_transit () const
    {
      return this->public_transit_;
    }

    page::public_transit_optional& page::
    public_transit ()
    {
      return this->public_transit_;
    }

    void page::
    public_transit (const public_transit_type& x)
    {
      this->public_transit_.set (x);
    }

    void page::
    public_transit (const public_transit_optional& x)
    {
      this->public_transit_ = x;
    }

    void page::
    public_transit (::std::auto_ptr< public_transit_type > x)
    {
      this->public_transit_.set (x);
    }

    const page::hours_optional& page::
    hours () const
    {
      return this->hours_;
    }

    page::hours_optional& page::
    hours ()
    {
      return this->hours_;
    }

    void page::
    hours (const hours_type& x)
    {
      this->hours_.set (x);
    }

    void page::
    hours (const hours_optional& x)
    {
      this->hours_ = x;
    }

    void page::
    hours (::std::auto_ptr< hours_type > x)
    {
      this->hours_.set (x);
    }

    const page::attire_optional& page::
    attire () const
    {
      return this->attire_;
    }

    page::attire_optional& page::
    attire ()
    {
      return this->attire_;
    }

    void page::
    attire (const attire_type& x)
    {
      this->attire_.set (x);
    }

    void page::
    attire (const attire_optional& x)
    {
      this->attire_ = x;
    }

    void page::
    attire (::std::auto_ptr< attire_type > x)
    {
      this->attire_.set (x);
    }

    const page::payment_options_optional& page::
    payment_options () const
    {
      return this->payment_options_;
    }

    page::payment_options_optional& page::
    payment_options ()
    {
      return this->payment_options_;
    }

    void page::
    payment_options (const payment_options_type& x)
    {
      this->payment_options_.set (x);
    }

    void page::
    payment_options (const payment_options_optional& x)
    {
      this->payment_options_ = x;
    }

    void page::
    payment_options (::std::auto_ptr< payment_options_type > x)
    {
      this->payment_options_.set (x);
    }

    const page::culinary_team_optional& page::
    culinary_team () const
    {
      return this->culinary_team_;
    }

    page::culinary_team_optional& page::
    culinary_team ()
    {
      return this->culinary_team_;
    }

    void page::
    culinary_team (const culinary_team_type& x)
    {
      this->culinary_team_.set (x);
    }

    void page::
    culinary_team (const culinary_team_optional& x)
    {
      this->culinary_team_ = x;
    }

    void page::
    culinary_team (::std::auto_ptr< culinary_team_type > x)
    {
      this->culinary_team_.set (x);
    }

    const page::general_manager_optional& page::
    general_manager () const
    {
      return this->general_manager_;
    }

    page::general_manager_optional& page::
    general_manager ()
    {
      return this->general_manager_;
    }

    void page::
    general_manager (const general_manager_type& x)
    {
      this->general_manager_.set (x);
    }

    void page::
    general_manager (const general_manager_optional& x)
    {
      this->general_manager_ = x;
    }

    void page::
    general_manager (::std::auto_ptr< general_manager_type > x)
    {
      this->general_manager_.set (x);
    }

    const page::price_range_optional& page::
    price_range () const
    {
      return this->price_range_;
    }

    page::price_range_optional& page::
    price_range ()
    {
      return this->price_range_;
    }

    void page::
    price_range (const price_range_type& x)
    {
      this->price_range_.set (x);
    }

    void page::
    price_range (const price_range_optional& x)
    {
      this->price_range_ = x;
    }

    void page::
    price_range (::std::auto_ptr< price_range_type > x)
    {
      this->price_range_.set (x);
    }

    const page::restaurant_services_optional& page::
    restaurant_services () const
    {
      return this->restaurant_services_;
    }

    page::restaurant_services_optional& page::
    restaurant_services ()
    {
      return this->restaurant_services_;
    }

    void page::
    restaurant_services (const restaurant_services_type& x)
    {
      this->restaurant_services_.set (x);
    }

    void page::
    restaurant_services (const restaurant_services_optional& x)
    {
      this->restaurant_services_ = x;
    }

    void page::
    restaurant_services (::std::auto_ptr< restaurant_services_type > x)
    {
      this->restaurant_services_.set (x);
    }

    const page::restaurant_specialties_optional& page::
    restaurant_specialties () const
    {
      return this->restaurant_specialties_;
    }

    page::restaurant_specialties_optional& page::
    restaurant_specialties ()
    {
      return this->restaurant_specialties_;
    }

    void page::
    restaurant_specialties (const restaurant_specialties_type& x)
    {
      this->restaurant_specialties_.set (x);
    }

    void page::
    restaurant_specialties (const restaurant_specialties_optional& x)
    {
      this->restaurant_specialties_ = x;
    }

    void page::
    restaurant_specialties (::std::auto_ptr< restaurant_specialties_type > x)
    {
      this->restaurant_specialties_.set (x);
    }

    const page::release_date_optional& page::
    release_date () const
    {
      return this->release_date_;
    }

    page::release_date_optional& page::
    release_date ()
    {
      return this->release_date_;
    }

    void page::
    release_date (const release_date_type& x)
    {
      this->release_date_.set (x);
    }

    void page::
    release_date (const release_date_optional& x)
    {
      this->release_date_ = x;
    }

    void page::
    release_date (::std::auto_ptr< release_date_type > x)
    {
      this->release_date_.set (x);
    }

    const page::genre_optional& page::
    genre () const
    {
      return this->genre_;
    }

    page::genre_optional& page::
    genre ()
    {
      return this->genre_;
    }

    void page::
    genre (const genre_type& x)
    {
      this->genre_.set (x);
    }

    void page::
    genre (const genre_optional& x)
    {
      this->genre_ = x;
    }

    void page::
    genre (::std::auto_ptr< genre_type > x)
    {
      this->genre_.set (x);
    }

    const page::starring_optional& page::
    starring () const
    {
      return this->starring_;
    }

    page::starring_optional& page::
    starring ()
    {
      return this->starring_;
    }

    void page::
    starring (const starring_type& x)
    {
      this->starring_.set (x);
    }

    void page::
    starring (const starring_optional& x)
    {
      this->starring_ = x;
    }

    void page::
    starring (::std::auto_ptr< starring_type > x)
    {
      this->starring_.set (x);
    }

    const page::screenplay_by_optional& page::
    screenplay_by () const
    {
      return this->screenplay_by_;
    }

    page::screenplay_by_optional& page::
    screenplay_by ()
    {
      return this->screenplay_by_;
    }

    void page::
    screenplay_by (const screenplay_by_type& x)
    {
      this->screenplay_by_.set (x);
    }

    void page::
    screenplay_by (const screenplay_by_optional& x)
    {
      this->screenplay_by_ = x;
    }

    void page::
    screenplay_by (::std::auto_ptr< screenplay_by_type > x)
    {
      this->screenplay_by_.set (x);
    }

    const page::directed_by_optional& page::
    directed_by () const
    {
      return this->directed_by_;
    }

    page::directed_by_optional& page::
    directed_by ()
    {
      return this->directed_by_;
    }

    void page::
    directed_by (const directed_by_type& x)
    {
      this->directed_by_.set (x);
    }

    void page::
    directed_by (const directed_by_optional& x)
    {
      this->directed_by_ = x;
    }

    void page::
    directed_by (::std::auto_ptr< directed_by_type > x)
    {
      this->directed_by_.set (x);
    }

    const page::produced_by_optional& page::
    produced_by () const
    {
      return this->produced_by_;
    }

    page::produced_by_optional& page::
    produced_by ()
    {
      return this->produced_by_;
    }

    void page::
    produced_by (const produced_by_type& x)
    {
      this->produced_by_.set (x);
    }

    void page::
    produced_by (const produced_by_optional& x)
    {
      this->produced_by_ = x;
    }

    void page::
    produced_by (::std::auto_ptr< produced_by_type > x)
    {
      this->produced_by_.set (x);
    }

    const page::studio_optional& page::
    studio () const
    {
      return this->studio_;
    }

    page::studio_optional& page::
    studio ()
    {
      return this->studio_;
    }

    void page::
    studio (const studio_type& x)
    {
      this->studio_.set (x);
    }

    void page::
    studio (const studio_optional& x)
    {
      this->studio_ = x;
    }

    void page::
    studio (::std::auto_ptr< studio_type > x)
    {
      this->studio_.set (x);
    }

    const page::awards_optional& page::
    awards () const
    {
      return this->awards_;
    }

    page::awards_optional& page::
    awards ()
    {
      return this->awards_;
    }

    void page::
    awards (const awards_type& x)
    {
      this->awards_.set (x);
    }

    void page::
    awards (const awards_optional& x)
    {
      this->awards_ = x;
    }

    void page::
    awards (::std::auto_ptr< awards_type > x)
    {
      this->awards_.set (x);
    }

    const page::plot_outline_optional& page::
    plot_outline () const
    {
      return this->plot_outline_;
    }

    page::plot_outline_optional& page::
    plot_outline ()
    {
      return this->plot_outline_;
    }

    void page::
    plot_outline (const plot_outline_type& x)
    {
      this->plot_outline_.set (x);
    }

    void page::
    plot_outline (const plot_outline_optional& x)
    {
      this->plot_outline_ = x;
    }

    void page::
    plot_outline (::std::auto_ptr< plot_outline_type > x)
    {
      this->plot_outline_.set (x);
    }

    const page::network_optional& page::
    network () const
    {
      return this->network_;
    }

    page::network_optional& page::
    network ()
    {
      return this->network_;
    }

    void page::
    network (const network_type& x)
    {
      this->network_.set (x);
    }

    void page::
    network (const network_optional& x)
    {
      this->network_ = x;
    }

    void page::
    network (::std::auto_ptr< network_type > x)
    {
      this->network_.set (x);
    }

    const page::season_optional& page::
    season () const
    {
      return this->season_;
    }

    page::season_optional& page::
    season ()
    {
      return this->season_;
    }

    void page::
    season (const season_type& x)
    {
      this->season_.set (x);
    }

    void page::
    season (const season_optional& x)
    {
      this->season_ = x;
    }

    void page::
    season (::std::auto_ptr< season_type > x)
    {
      this->season_.set (x);
    }

    const page::schedule_optional& page::
    schedule () const
    {
      return this->schedule_;
    }

    page::schedule_optional& page::
    schedule ()
    {
      return this->schedule_;
    }

    void page::
    schedule (const schedule_type& x)
    {
      this->schedule_.set (x);
    }

    void page::
    schedule (const schedule_optional& x)
    {
      this->schedule_ = x;
    }

    void page::
    schedule (::std::auto_ptr< schedule_type > x)
    {
      this->schedule_.set (x);
    }

    const page::written_by_optional& page::
    written_by () const
    {
      return this->written_by_;
    }

    page::written_by_optional& page::
    written_by ()
    {
      return this->written_by_;
    }

    void page::
    written_by (const written_by_type& x)
    {
      this->written_by_.set (x);
    }

    void page::
    written_by (const written_by_optional& x)
    {
      this->written_by_ = x;
    }

    void page::
    written_by (::std::auto_ptr< written_by_type > x)
    {
      this->written_by_.set (x);
    }

    const page::band_members_optional& page::
    band_members () const
    {
      return this->band_members_;
    }

    page::band_members_optional& page::
    band_members ()
    {
      return this->band_members_;
    }

    void page::
    band_members (const band_members_type& x)
    {
      this->band_members_.set (x);
    }

    void page::
    band_members (const band_members_optional& x)
    {
      this->band_members_ = x;
    }

    void page::
    band_members (::std::auto_ptr< band_members_type > x)
    {
      this->band_members_.set (x);
    }

    const page::hometown_optional& page::
    hometown () const
    {
      return this->hometown_;
    }

    page::hometown_optional& page::
    hometown ()
    {
      return this->hometown_;
    }

    void page::
    hometown (const hometown_type& x)
    {
      this->hometown_.set (x);
    }

    void page::
    hometown (const hometown_optional& x)
    {
      this->hometown_ = x;
    }

    void page::
    hometown (::std::auto_ptr< hometown_type > x)
    {
      this->hometown_.set (x);
    }

    const page::current_location_optional& page::
    current_location () const
    {
      return this->current_location_;
    }

    page::current_location_optional& page::
    current_location ()
    {
      return this->current_location_;
    }

    void page::
    current_location (const current_location_type& x)
    {
      this->current_location_.set (x);
    }

    void page::
    current_location (const current_location_optional& x)
    {
      this->current_location_ = x;
    }

    void page::
    current_location (::std::auto_ptr< current_location_type > x)
    {
      this->current_location_.set (x);
    }

    const page::record_label_optional& page::
    record_label () const
    {
      return this->record_label_;
    }

    page::record_label_optional& page::
    record_label ()
    {
      return this->record_label_;
    }

    void page::
    record_label (const record_label_type& x)
    {
      this->record_label_.set (x);
    }

    void page::
    record_label (const record_label_optional& x)
    {
      this->record_label_ = x;
    }

    void page::
    record_label (::std::auto_ptr< record_label_type > x)
    {
      this->record_label_.set (x);
    }

    const page::booking_agent_optional& page::
    booking_agent () const
    {
      return this->booking_agent_;
    }

    page::booking_agent_optional& page::
    booking_agent ()
    {
      return this->booking_agent_;
    }

    void page::
    booking_agent (const booking_agent_type& x)
    {
      this->booking_agent_.set (x);
    }

    void page::
    booking_agent (const booking_agent_optional& x)
    {
      this->booking_agent_ = x;
    }

    void page::
    booking_agent (::std::auto_ptr< booking_agent_type > x)
    {
      this->booking_agent_.set (x);
    }

    const page::artists_we_like_optional& page::
    artists_we_like () const
    {
      return this->artists_we_like_;
    }

    page::artists_we_like_optional& page::
    artists_we_like ()
    {
      return this->artists_we_like_;
    }

    void page::
    artists_we_like (const artists_we_like_type& x)
    {
      this->artists_we_like_.set (x);
    }

    void page::
    artists_we_like (const artists_we_like_optional& x)
    {
      this->artists_we_like_ = x;
    }

    void page::
    artists_we_like (::std::auto_ptr< artists_we_like_type > x)
    {
      this->artists_we_like_.set (x);
    }

    const page::influences_optional& page::
    influences () const
    {
      return this->influences_;
    }

    page::influences_optional& page::
    influences ()
    {
      return this->influences_;
    }

    void page::
    influences (const influences_type& x)
    {
      this->influences_.set (x);
    }

    void page::
    influences (const influences_optional& x)
    {
      this->influences_ = x;
    }

    void page::
    influences (::std::auto_ptr< influences_type > x)
    {
      this->influences_.set (x);
    }

    const page::band_interests_optional& page::
    band_interests () const
    {
      return this->band_interests_;
    }

    page::band_interests_optional& page::
    band_interests ()
    {
      return this->band_interests_;
    }

    void page::
    band_interests (const band_interests_type& x)
    {
      this->band_interests_.set (x);
    }

    void page::
    band_interests (const band_interests_optional& x)
    {
      this->band_interests_ = x;
    }

    void page::
    band_interests (::std::auto_ptr< band_interests_type > x)
    {
      this->band_interests_.set (x);
    }

    const page::bio_optional& page::
    bio () const
    {
      return this->bio_;
    }

    page::bio_optional& page::
    bio ()
    {
      return this->bio_;
    }

    void page::
    bio (const bio_type& x)
    {
      this->bio_.set (x);
    }

    void page::
    bio (const bio_optional& x)
    {
      this->bio_ = x;
    }

    void page::
    bio (::std::auto_ptr< bio_type > x)
    {
      this->bio_.set (x);
    }

    const page::affiliation_optional& page::
    affiliation () const
    {
      return this->affiliation_;
    }

    page::affiliation_optional& page::
    affiliation ()
    {
      return this->affiliation_;
    }

    void page::
    affiliation (const affiliation_type& x)
    {
      this->affiliation_.set (x);
    }

    void page::
    affiliation (const affiliation_optional& x)
    {
      this->affiliation_ = x;
    }

    void page::
    affiliation (::std::auto_ptr< affiliation_type > x)
    {
      this->affiliation_.set (x);
    }

    const page::birthday_optional& page::
    birthday () const
    {
      return this->birthday_;
    }

    page::birthday_optional& page::
    birthday ()
    {
      return this->birthday_;
    }

    void page::
    birthday (const birthday_type& x)
    {
      this->birthday_.set (x);
    }

    void page::
    birthday (const birthday_optional& x)
    {
      this->birthday_ = x;
    }

    void page::
    birthday (::std::auto_ptr< birthday_type > x)
    {
      this->birthday_.set (x);
    }

    const page::personal_info_optional& page::
    personal_info () const
    {
      return this->personal_info_;
    }

    page::personal_info_optional& page::
    personal_info ()
    {
      return this->personal_info_;
    }

    void page::
    personal_info (const personal_info_type& x)
    {
      this->personal_info_.set (x);
    }

    void page::
    personal_info (const personal_info_optional& x)
    {
      this->personal_info_ = x;
    }

    void page::
    personal_info (::std::auto_ptr< personal_info_type > x)
    {
      this->personal_info_.set (x);
    }

    const page::personal_interests_optional& page::
    personal_interests () const
    {
      return this->personal_interests_;
    }

    page::personal_interests_optional& page::
    personal_interests ()
    {
      return this->personal_interests_;
    }

    void page::
    personal_interests (const personal_interests_type& x)
    {
      this->personal_interests_.set (x);
    }

    void page::
    personal_interests (const personal_interests_optional& x)
    {
      this->personal_interests_ = x;
    }

    void page::
    personal_interests (::std::auto_ptr< personal_interests_type > x)
    {
      this->personal_interests_.set (x);
    }

    const page::members_optional& page::
    members () const
    {
      return this->members_;
    }

    page::members_optional& page::
    members ()
    {
      return this->members_;
    }

    void page::
    members (const members_type& x)
    {
      this->members_.set (x);
    }

    void page::
    members (const members_optional& x)
    {
      this->members_ = x;
    }

    void page::
    members (::std::auto_ptr< members_type > x)
    {
      this->members_.set (x);
    }

    const page::built_optional& page::
    built () const
    {
      return this->built_;
    }

    page::built_optional& page::
    built ()
    {
      return this->built_;
    }

    void page::
    built (const built_type& x)
    {
      this->built_.set (x);
    }

    void page::
    built (const built_optional& x)
    {
      this->built_ = x;
    }

    void page::
    built (::std::auto_ptr< built_type > x)
    {
      this->built_.set (x);
    }

    const page::features_optional& page::
    features () const
    {
      return this->features_;
    }

    page::features_optional& page::
    features ()
    {
      return this->features_;
    }

    void page::
    features (const features_type& x)
    {
      this->features_.set (x);
    }

    void page::
    features (const features_optional& x)
    {
      this->features_ = x;
    }

    void page::
    features (::std::auto_ptr< features_type > x)
    {
      this->features_.set (x);
    }

    const page::mpg_optional& page::
    mpg () const
    {
      return this->mpg_;
    }

    page::mpg_optional& page::
    mpg ()
    {
      return this->mpg_;
    }

    void page::
    mpg (const mpg_type& x)
    {
      this->mpg_.set (x);
    }

    void page::
    mpg (const mpg_optional& x)
    {
      this->mpg_ = x;
    }

    void page::
    mpg (::std::auto_ptr< mpg_type > x)
    {
      this->mpg_.set (x);
    }

    const page::general_info_optional& page::
    general_info () const
    {
      return this->general_info_;
    }

    page::general_info_optional& page::
    general_info ()
    {
      return this->general_info_;
    }

    void page::
    general_info (const general_info_type& x)
    {
      this->general_info_.set (x);
    }

    void page::
    general_info (const general_info_optional& x)
    {
      this->general_info_ = x;
    }

    void page::
    general_info (::std::auto_ptr< general_info_type > x)
    {
      this->general_info_.set (x);
    }


    // cookie
    // 

    const cookie::uid_type& cookie::
    uid () const
    {
      return this->uid_.get ();
    }

    cookie::uid_type& cookie::
    uid ()
    {
      return this->uid_.get ();
    }

    void cookie::
    uid (const uid_type& x)
    {
      this->uid_.set (x);
    }

    void cookie::
    uid (::std::auto_ptr< uid_type > x)
    {
      this->uid_.set (x);
    }

    const cookie::name_type& cookie::
    name () const
    {
      return this->name_.get ();
    }

    cookie::name_type& cookie::
    name ()
    {
      return this->name_.get ();
    }

    void cookie::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void cookie::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const cookie::value_type& cookie::
    value () const
    {
      return this->value_.get ();
    }

    cookie::value_type& cookie::
    value ()
    {
      return this->value_.get ();
    }

    void cookie::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void cookie::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }

    const cookie::expires_type& cookie::
    expires () const
    {
      return this->expires_.get ();
    }

    cookie::expires_type& cookie::
    expires ()
    {
      return this->expires_.get ();
    }

    void cookie::
    expires (const expires_type& x)
    {
      this->expires_.set (x);
    }

    const cookie::path_type& cookie::
    path () const
    {
      return this->path_.get ();
    }

    cookie::path_type& cookie::
    path ()
    {
      return this->path_.get ();
    }

    void cookie::
    path (const path_type& x)
    {
      this->path_.set (x);
    }

    void cookie::
    path (::std::auto_ptr< path_type > x)
    {
      this->path_.set (x);
    }


    // phrase
    // 

    const phrase::description_type& phrase::
    description () const
    {
      return this->description_.get ();
    }

    phrase::description_type& phrase::
    description ()
    {
      return this->description_.get ();
    }

    void phrase::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void phrase::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }

    const phrase::text_type& phrase::
    text () const
    {
      return this->text_.get ();
    }

    phrase::text_type& phrase::
    text ()
    {
      return this->text_.get ();
    }

    void phrase::
    text (const text_type& x)
    {
      this->text_.set (x);
    }

    void phrase::
    text (::std::auto_ptr< text_type > x)
    {
      this->text_.set (x);
    }


    // request_args
    // 

    const request_args::arg_sequence& request_args::
    arg () const
    {
      return this->arg_;
    }

    request_args::arg_sequence& request_args::
    arg ()
    {
      return this->arg_;
    }

    void request_args::
    arg (const arg_sequence& s)
    {
      this->arg_ = s;
    }

    const request_args::list_optional& request_args::
    list () const
    {
      return this->list_;
    }

    request_args::list_optional& request_args::
    list ()
    {
      return this->list_;
    }

    void request_args::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void request_args::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // positions
    // 

    const positions::member_type_sequence& positions::
    member_type () const
    {
      return this->member_type_;
    }

    positions::member_type_sequence& positions::
    member_type ()
    {
      return this->member_type_;
    }

    void positions::
    member_type (const member_type_sequence& s)
    {
      this->member_type_ = s;
    }

    const positions::list_optional& positions::
    list () const
    {
      return this->list_;
    }

    positions::list_optional& positions::
    list ()
    {
      return this->list_;
    }

    void positions::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void positions::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // members
    // 

    const members::uid_sequence& members::
    uid () const
    {
      return this->uid_;
    }

    members::uid_sequence& members::
    uid ()
    {
      return this->uid_;
    }

    void members::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const members::list_optional& members::
    list () const
    {
      return this->list_;
    }

    members::list_optional& members::
    list ()
    {
      return this->list_;
    }

    void members::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void members::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // admins
    // 

    const admins::uid_sequence& admins::
    uid () const
    {
      return this->uid_;
    }

    admins::uid_sequence& admins::
    uid ()
    {
      return this->uid_;
    }

    void admins::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const admins::list_optional& admins::
    list () const
    {
      return this->list_;
    }

    admins::list_optional& admins::
    list ()
    {
      return this->list_;
    }

    void admins::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void admins::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // officers
    // 

    const officers::uid_sequence& officers::
    uid () const
    {
      return this->uid_;
    }

    officers::uid_sequence& officers::
    uid ()
    {
      return this->uid_;
    }

    void officers::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const officers::list_optional& officers::
    list () const
    {
      return this->list_;
    }

    officers::list_optional& officers::
    list ()
    {
      return this->list_;
    }

    void officers::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void officers::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // not_replied
    // 

    const not_replied::uid_sequence& not_replied::
    uid () const
    {
      return this->uid_;
    }

    not_replied::uid_sequence& not_replied::
    uid ()
    {
      return this->uid_;
    }

    void not_replied::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const not_replied::list_optional& not_replied::
    list () const
    {
      return this->list_;
    }

    not_replied::list_optional& not_replied::
    list ()
    {
      return this->list_;
    }

    void not_replied::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void not_replied::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // attending
    // 

    const attending::uid_sequence& attending::
    uid () const
    {
      return this->uid_;
    }

    attending::uid_sequence& attending::
    uid ()
    {
      return this->uid_;
    }

    void attending::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const attending::list_optional& attending::
    list () const
    {
      return this->list_;
    }

    attending::list_optional& attending::
    list ()
    {
      return this->list_;
    }

    void attending::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void attending::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // unsure
    // 

    const unsure::uid_sequence& unsure::
    uid () const
    {
      return this->uid_;
    }

    unsure::uid_sequence& unsure::
    uid ()
    {
      return this->uid_;
    }

    void unsure::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const unsure::list_optional& unsure::
    list () const
    {
      return this->list_;
    }

    unsure::list_optional& unsure::
    list ()
    {
      return this->list_;
    }

    void unsure::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void unsure::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // declined
    // 

    const declined::uid_sequence& declined::
    uid () const
    {
      return this->uid_;
    }

    declined::uid_sequence& declined::
    uid ()
    {
      return this->uid_;
    }

    void declined::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const declined::list_optional& declined::
    list () const
    {
      return this->list_;
    }

    declined::list_optional& declined::
    list ()
    {
      return this->list_;
    }

    void declined::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void declined::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // not_replied1
    // 

    const not_replied1::uid_sequence& not_replied1::
    uid () const
    {
      return this->uid_;
    }

    not_replied1::uid_sequence& not_replied1::
    uid ()
    {
      return this->uid_;
    }

    void not_replied1::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const not_replied1::list_optional& not_replied1::
    list () const
    {
      return this->list_;
    }

    not_replied1::list_optional& not_replied1::
    list ()
    {
      return this->list_;
    }

    void not_replied1::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void not_replied1::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // friend_requests
    // 

    const friend_requests::uid_sequence& friend_requests::
    uid () const
    {
      return this->uid_;
    }

    friend_requests::uid_sequence& friend_requests::
    uid ()
    {
      return this->uid_;
    }

    void friend_requests::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const friend_requests::list_optional& friend_requests::
    list () const
    {
      return this->list_;
    }

    friend_requests::list_optional& friend_requests::
    list ()
    {
      return this->list_;
    }

    void friend_requests::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void friend_requests::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // group_invites
    // 

    const group_invites::gid_sequence& group_invites::
    gid () const
    {
      return this->gid_;
    }

    group_invites::gid_sequence& group_invites::
    gid ()
    {
      return this->gid_;
    }

    void group_invites::
    gid (const gid_sequence& s)
    {
      this->gid_ = s;
    }

    const group_invites::list_optional& group_invites::
    list () const
    {
      return this->list_;
    }

    group_invites::list_optional& group_invites::
    list ()
    {
      return this->list_;
    }

    void group_invites::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void group_invites::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // event_invites
    // 

    const event_invites::eid_sequence& event_invites::
    eid () const
    {
      return this->eid_;
    }

    event_invites::eid_sequence& event_invites::
    eid ()
    {
      return this->eid_;
    }

    void event_invites::
    eid (const eid_sequence& s)
    {
      this->eid_ = s;
    }

    const event_invites::list_optional& event_invites::
    list () const
    {
      return this->list_;
    }

    event_invites::list_optional& event_invites::
    list ()
    {
      return this->list_;
    }

    void event_invites::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void event_invites::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // concentrations
    // 

    const concentrations::concentration_sequence& concentrations::
    concentration () const
    {
      return this->concentration_;
    }

    concentrations::concentration_sequence& concentrations::
    concentration ()
    {
      return this->concentration_;
    }

    void concentrations::
    concentration (const concentration_sequence& s)
    {
      this->concentration_ = s;
    }

    const concentrations::list_optional& concentrations::
    list () const
    {
      return this->list_;
    }

    concentrations::list_optional& concentrations::
    list ()
    {
      return this->list_;
    }

    void concentrations::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void concentrations::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // affiliations
    // 

    const affiliations::affiliation_sequence& affiliations::
    affiliation () const
    {
      return this->affiliation_;
    }

    affiliations::affiliation_sequence& affiliations::
    affiliation ()
    {
      return this->affiliation_;
    }

    void affiliations::
    affiliation (const affiliation_sequence& s)
    {
      this->affiliation_ = s;
    }

    const affiliations::list_optional& affiliations::
    list () const
    {
      return this->list_;
    }

    affiliations::list_optional& affiliations::
    list ()
    {
      return this->list_;
    }

    void affiliations::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void affiliations::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // education_history
    // 

    const education_history::education_info_sequence& education_history::
    education_info () const
    {
      return this->education_info_;
    }

    education_history::education_info_sequence& education_history::
    education_info ()
    {
      return this->education_info_;
    }

    void education_history::
    education_info (const education_info_sequence& s)
    {
      this->education_info_ = s;
    }

    const education_history::list_optional& education_history::
    list () const
    {
      return this->list_;
    }

    education_history::list_optional& education_history::
    list ()
    {
      return this->list_;
    }

    void education_history::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void education_history::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // meeting_for
    // 

    const meeting_for::seeking_sequence& meeting_for::
    seeking () const
    {
      return this->seeking_;
    }

    meeting_for::seeking_sequence& meeting_for::
    seeking ()
    {
      return this->seeking_;
    }

    void meeting_for::
    seeking (const seeking_sequence& s)
    {
      this->seeking_ = s;
    }

    const meeting_for::list_optional& meeting_for::
    list () const
    {
      return this->list_;
    }

    meeting_for::list_optional& meeting_for::
    list ()
    {
      return this->list_;
    }

    void meeting_for::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void meeting_for::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // meeting_sex
    // 

    const meeting_sex::sex_sequence& meeting_sex::
    sex () const
    {
      return this->sex_;
    }

    meeting_sex::sex_sequence& meeting_sex::
    sex ()
    {
      return this->sex_;
    }

    void meeting_sex::
    sex (const sex_sequence& s)
    {
      this->sex_ = s;
    }

    const meeting_sex::list_optional& meeting_sex::
    list () const
    {
      return this->list_;
    }

    meeting_sex::list_optional& meeting_sex::
    list ()
    {
      return this->list_;
    }

    void meeting_sex::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void meeting_sex::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // work_history
    // 

    const work_history::work_info_sequence& work_history::
    work_info () const
    {
      return this->work_info_;
    }

    work_history::work_info_sequence& work_history::
    work_info ()
    {
      return this->work_info_;
    }

    void work_history::
    work_info (const work_info_sequence& s)
    {
      this->work_info_ = s;
    }

    const work_history::list_optional& work_history::
    list () const
    {
      return this->list_;
    }

    work_history::list_optional& work_history::
    list ()
    {
      return this->list_;
    }

    void work_history::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void work_history::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // image_urls
    // 

    const image_urls::image_urls_elt_sequence& image_urls::
    image_urls_elt () const
    {
      return this->image_urls_elt_;
    }

    image_urls::image_urls_elt_sequence& image_urls::
    image_urls_elt ()
    {
      return this->image_urls_elt_;
    }

    void image_urls::
    image_urls_elt (const image_urls_elt_sequence& s)
    {
      this->image_urls_elt_ = s;
    }

    const image_urls::list_optional& image_urls::
    list () const
    {
      return this->list_;
    }

    image_urls::list_optional& image_urls::
    list ()
    {
      return this->list_;
    }

    void image_urls::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void image_urls::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // events_get_response
    // 

    const events_get_response::event_sequence& events_get_response::
    event () const
    {
      return this->event_;
    }

    events_get_response::event_sequence& events_get_response::
    event ()
    {
      return this->event_;
    }

    void events_get_response::
    event (const event_sequence& s)
    {
      this->event_ = s;
    }

    const events_get_response::list_optional& events_get_response::
    list () const
    {
      return this->list_;
    }

    events_get_response::list_optional& events_get_response::
    list ()
    {
      return this->list_;
    }

    void events_get_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void events_get_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // friends_areFriends_response
    // 

    const friends_areFriends_response::friend_info_sequence& friends_areFriends_response::
    friend_info () const
    {
      return this->friend_info_;
    }

    friends_areFriends_response::friend_info_sequence& friends_areFriends_response::
    friend_info ()
    {
      return this->friend_info_;
    }

    void friends_areFriends_response::
    friend_info (const friend_info_sequence& s)
    {
      this->friend_info_ = s;
    }

    const friends_areFriends_response::list_optional& friends_areFriends_response::
    list () const
    {
      return this->list_;
    }

    friends_areFriends_response::list_optional& friends_areFriends_response::
    list ()
    {
      return this->list_;
    }

    void friends_areFriends_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void friends_areFriends_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // friends_get_response
    // 

    const friends_get_response::uid_sequence& friends_get_response::
    uid () const
    {
      return this->uid_;
    }

    friends_get_response::uid_sequence& friends_get_response::
    uid ()
    {
      return this->uid_;
    }

    void friends_get_response::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const friends_get_response::list_optional& friends_get_response::
    list () const
    {
      return this->list_;
    }

    friends_get_response::list_optional& friends_get_response::
    list ()
    {
      return this->list_;
    }

    void friends_get_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void friends_get_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // friends_getAppUsers_response
    // 

    const friends_getAppUsers_response::uid_sequence& friends_getAppUsers_response::
    uid () const
    {
      return this->uid_;
    }

    friends_getAppUsers_response::uid_sequence& friends_getAppUsers_response::
    uid ()
    {
      return this->uid_;
    }

    void friends_getAppUsers_response::
    uid (const uid_sequence& s)
    {
      this->uid_ = s;
    }

    const friends_getAppUsers_response::list_optional& friends_getAppUsers_response::
    list () const
    {
      return this->list_;
    }

    friends_getAppUsers_response::list_optional& friends_getAppUsers_response::
    list ()
    {
      return this->list_;
    }

    void friends_getAppUsers_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void friends_getAppUsers_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // friends_getLists_response
    // 

    const friends_getLists_response::friendlist_sequence& friends_getLists_response::
    friendlist () const
    {
      return this->friendlist_;
    }

    friends_getLists_response::friendlist_sequence& friends_getLists_response::
    friendlist ()
    {
      return this->friendlist_;
    }

    void friends_getLists_response::
    friendlist (const friendlist_sequence& s)
    {
      this->friendlist_ = s;
    }

    const friends_getLists_response::list_optional& friends_getLists_response::
    list () const
    {
      return this->list_;
    }

    friends_getLists_response::list_optional& friends_getLists_response::
    list ()
    {
      return this->list_;
    }

    void friends_getLists_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void friends_getLists_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // groups_get_response
    // 

    const groups_get_response::group_sequence& groups_get_response::
    group () const
    {
      return this->group_;
    }

    groups_get_response::group_sequence& groups_get_response::
    group ()
    {
      return this->group_;
    }

    void groups_get_response::
    group (const group_sequence& s)
    {
      this->group_ = s;
    }

    const groups_get_response::list_optional& groups_get_response::
    list () const
    {
      return this->list_;
    }

    groups_get_response::list_optional& groups_get_response::
    list ()
    {
      return this->list_;
    }

    void groups_get_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void groups_get_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getCookies_response
    // 

    const data_getCookies_response::cookie_sequence& data_getCookies_response::
    cookie () const
    {
      return this->cookie_;
    }

    data_getCookies_response::cookie_sequence& data_getCookies_response::
    cookie ()
    {
      return this->cookie_;
    }

    void data_getCookies_response::
    cookie (const cookie_sequence& s)
    {
      this->cookie_ = s;
    }

    const data_getCookies_response::list_optional& data_getCookies_response::
    list () const
    {
      return this->list_;
    }

    data_getCookies_response::list_optional& data_getCookies_response::
    list ()
    {
      return this->list_;
    }

    void data_getCookies_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getCookies_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // marketplace_getCategories_response
    // 

    const marketplace_getCategories_response::marketplace_category_sequence& marketplace_getCategories_response::
    marketplace_category () const
    {
      return this->marketplace_category_;
    }

    marketplace_getCategories_response::marketplace_category_sequence& marketplace_getCategories_response::
    marketplace_category ()
    {
      return this->marketplace_category_;
    }

    void marketplace_getCategories_response::
    marketplace_category (const marketplace_category_sequence& s)
    {
      this->marketplace_category_ = s;
    }

    const marketplace_getCategories_response::list_optional& marketplace_getCategories_response::
    list () const
    {
      return this->list_;
    }

    marketplace_getCategories_response::list_optional& marketplace_getCategories_response::
    list ()
    {
      return this->list_;
    }

    void marketplace_getCategories_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void marketplace_getCategories_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // marketplace_getSubCategories_response
    // 

    const marketplace_getSubCategories_response::marketplace_subcategory_sequence& marketplace_getSubCategories_response::
    marketplace_subcategory () const
    {
      return this->marketplace_subcategory_;
    }

    marketplace_getSubCategories_response::marketplace_subcategory_sequence& marketplace_getSubCategories_response::
    marketplace_subcategory ()
    {
      return this->marketplace_subcategory_;
    }

    void marketplace_getSubCategories_response::
    marketplace_subcategory (const marketplace_subcategory_sequence& s)
    {
      this->marketplace_subcategory_ = s;
    }

    const marketplace_getSubCategories_response::list_optional& marketplace_getSubCategories_response::
    list () const
    {
      return this->list_;
    }

    marketplace_getSubCategories_response::list_optional& marketplace_getSubCategories_response::
    list ()
    {
      return this->list_;
    }

    void marketplace_getSubCategories_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void marketplace_getSubCategories_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // marketplace_getListings_response
    // 

    const marketplace_getListings_response::listing_sequence& marketplace_getListings_response::
    listing () const
    {
      return this->listing_;
    }

    marketplace_getListings_response::listing_sequence& marketplace_getListings_response::
    listing ()
    {
      return this->listing_;
    }

    void marketplace_getListings_response::
    listing (const listing_sequence& s)
    {
      this->listing_ = s;
    }

    const marketplace_getListings_response::list_optional& marketplace_getListings_response::
    list () const
    {
      return this->list_;
    }

    marketplace_getListings_response::list_optional& marketplace_getListings_response::
    list ()
    {
      return this->list_;
    }

    void marketplace_getListings_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void marketplace_getListings_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // marketplace_search_response
    // 

    const marketplace_search_response::listing_sequence& marketplace_search_response::
    listing () const
    {
      return this->listing_;
    }

    marketplace_search_response::listing_sequence& marketplace_search_response::
    listing ()
    {
      return this->listing_;
    }

    void marketplace_search_response::
    listing (const listing_sequence& s)
    {
      this->listing_ = s;
    }

    const marketplace_search_response::list_optional& marketplace_search_response::
    list () const
    {
      return this->list_;
    }

    marketplace_search_response::list_optional& marketplace_search_response::
    list ()
    {
      return this->list_;
    }

    void marketplace_search_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void marketplace_search_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // photos_get_response
    // 

    const photos_get_response::photo_sequence& photos_get_response::
    photo () const
    {
      return this->photo_;
    }

    photos_get_response::photo_sequence& photos_get_response::
    photo ()
    {
      return this->photo_;
    }

    void photos_get_response::
    photo (const photo_sequence& s)
    {
      this->photo_ = s;
    }

    const photos_get_response::list_optional& photos_get_response::
    list () const
    {
      return this->list_;
    }

    photos_get_response::list_optional& photos_get_response::
    list ()
    {
      return this->list_;
    }

    void photos_get_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void photos_get_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // photos_getAlbums_response
    // 

    const photos_getAlbums_response::album_sequence& photos_getAlbums_response::
    album () const
    {
      return this->album_;
    }

    photos_getAlbums_response::album_sequence& photos_getAlbums_response::
    album ()
    {
      return this->album_;
    }

    void photos_getAlbums_response::
    album (const album_sequence& s)
    {
      this->album_ = s;
    }

    const photos_getAlbums_response::list_optional& photos_getAlbums_response::
    list () const
    {
      return this->list_;
    }

    photos_getAlbums_response::list_optional& photos_getAlbums_response::
    list ()
    {
      return this->list_;
    }

    void photos_getAlbums_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void photos_getAlbums_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // photos_getTags_response
    // 

    const photos_getTags_response::photo_tag_sequence& photos_getTags_response::
    photo_tag () const
    {
      return this->photo_tag_;
    }

    photos_getTags_response::photo_tag_sequence& photos_getTags_response::
    photo_tag ()
    {
      return this->photo_tag_;
    }

    void photos_getTags_response::
    photo_tag (const photo_tag_sequence& s)
    {
      this->photo_tag_ = s;
    }

    const photos_getTags_response::list_optional& photos_getTags_response::
    list () const
    {
      return this->list_;
    }

    photos_getTags_response::list_optional& photos_getTags_response::
    list ()
    {
      return this->list_;
    }

    void photos_getTags_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void photos_getTags_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // update_decodeIDs_response
    // 

    const update_decodeIDs_response::id_map_sequence& update_decodeIDs_response::
    id_map () const
    {
      return this->id_map_;
    }

    update_decodeIDs_response::id_map_sequence& update_decodeIDs_response::
    id_map ()
    {
      return this->id_map_;
    }

    void update_decodeIDs_response::
    id_map (const id_map_sequence& s)
    {
      this->id_map_ = s;
    }

    const update_decodeIDs_response::list_optional& update_decodeIDs_response::
    list () const
    {
      return this->list_;
    }

    update_decodeIDs_response::list_optional& update_decodeIDs_response::
    list ()
    {
      return this->list_;
    }

    void update_decodeIDs_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void update_decodeIDs_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // users_getInfo_response
    // 

    const users_getInfo_response::user_sequence& users_getInfo_response::
    user () const
    {
      return this->user_;
    }

    users_getInfo_response::user_sequence& users_getInfo_response::
    user ()
    {
      return this->user_;
    }

    void users_getInfo_response::
    user (const user_sequence& s)
    {
      this->user_ = s;
    }

    const users_getInfo_response::list_optional& users_getInfo_response::
    list () const
    {
      return this->list_;
    }

    users_getInfo_response::list_optional& users_getInfo_response::
    list ()
    {
      return this->list_;
    }

    void users_getInfo_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void users_getInfo_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // pages_getInfo_response
    // 

    const pages_getInfo_response::page_sequence& pages_getInfo_response::
    page () const
    {
      return this->page_;
    }

    pages_getInfo_response::page_sequence& pages_getInfo_response::
    page ()
    {
      return this->page_;
    }

    void pages_getInfo_response::
    page (const page_sequence& s)
    {
      this->page_ = s;
    }

    const pages_getInfo_response::list_optional& pages_getInfo_response::
    list () const
    {
      return this->list_;
    }

    pages_getInfo_response::list_optional& pages_getInfo_response::
    list ()
    {
      return this->list_;
    }

    void pages_getInfo_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void pages_getInfo_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getUserPreferences_response
    // 

    const data_getUserPreferences_response::preference_sequence& data_getUserPreferences_response::
    preference () const
    {
      return this->preference_;
    }

    data_getUserPreferences_response::preference_sequence& data_getUserPreferences_response::
    preference ()
    {
      return this->preference_;
    }

    void data_getUserPreferences_response::
    preference (const preference_sequence& s)
    {
      this->preference_ = s;
    }

    const data_getUserPreferences_response::list_optional& data_getUserPreferences_response::
    list () const
    {
      return this->list_;
    }

    data_getUserPreferences_response::list_optional& data_getUserPreferences_response::
    list ()
    {
      return this->list_;
    }

    void data_getUserPreferences_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getUserPreferences_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getObjectTypes_response
    // 

    const data_getObjectTypes_response::object_type_info_sequence& data_getObjectTypes_response::
    object_type_info () const
    {
      return this->object_type_info_;
    }

    data_getObjectTypes_response::object_type_info_sequence& data_getObjectTypes_response::
    object_type_info ()
    {
      return this->object_type_info_;
    }

    void data_getObjectTypes_response::
    object_type_info (const object_type_info_sequence& s)
    {
      this->object_type_info_ = s;
    }

    const data_getObjectTypes_response::list_optional& data_getObjectTypes_response::
    list () const
    {
      return this->list_;
    }

    data_getObjectTypes_response::list_optional& data_getObjectTypes_response::
    list ()
    {
      return this->list_;
    }

    void data_getObjectTypes_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getObjectTypes_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getObjectType_response
    // 

    const data_getObjectType_response::object_property_info_sequence& data_getObjectType_response::
    object_property_info () const
    {
      return this->object_property_info_;
    }

    data_getObjectType_response::object_property_info_sequence& data_getObjectType_response::
    object_property_info ()
    {
      return this->object_property_info_;
    }

    void data_getObjectType_response::
    object_property_info (const object_property_info_sequence& s)
    {
      this->object_property_info_ = s;
    }

    const data_getObjectType_response::list_optional& data_getObjectType_response::
    list () const
    {
      return this->list_;
    }

    data_getObjectType_response::list_optional& data_getObjectType_response::
    list ()
    {
      return this->list_;
    }

    void data_getObjectType_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getObjectType_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getObjects_response
    // 

    const data_getObjects_response::data_getObjects_response_elt_sequence& data_getObjects_response::
    data_getObjects_response_elt () const
    {
      return this->data_getObjects_response_elt_;
    }

    data_getObjects_response::data_getObjects_response_elt_sequence& data_getObjects_response::
    data_getObjects_response_elt ()
    {
      return this->data_getObjects_response_elt_;
    }

    void data_getObjects_response::
    data_getObjects_response_elt (const data_getObjects_response_elt_sequence& s)
    {
      this->data_getObjects_response_elt_ = s;
    }

    const data_getObjects_response::list_optional& data_getObjects_response::
    list () const
    {
      return this->list_;
    }

    data_getObjects_response::list_optional& data_getObjects_response::
    list ()
    {
      return this->list_;
    }

    void data_getObjects_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getObjects_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getAssociationDefinitions_response
    // 

    const data_getAssociationDefinitions_response::object_assoc_info_sequence& data_getAssociationDefinitions_response::
    object_assoc_info () const
    {
      return this->object_assoc_info_;
    }

    data_getAssociationDefinitions_response::object_assoc_info_sequence& data_getAssociationDefinitions_response::
    object_assoc_info ()
    {
      return this->object_assoc_info_;
    }

    void data_getAssociationDefinitions_response::
    object_assoc_info (const object_assoc_info_sequence& s)
    {
      this->object_assoc_info_ = s;
    }

    const data_getAssociationDefinitions_response::list_optional& data_getAssociationDefinitions_response::
    list () const
    {
      return this->list_;
    }

    data_getAssociationDefinitions_response::list_optional& data_getAssociationDefinitions_response::
    list ()
    {
      return this->list_;
    }

    void data_getAssociationDefinitions_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getAssociationDefinitions_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getAssociatedObjects_response
    // 

    const data_getAssociatedObjects_response::object_association_sequence& data_getAssociatedObjects_response::
    object_association () const
    {
      return this->object_association_;
    }

    data_getAssociatedObjects_response::object_association_sequence& data_getAssociatedObjects_response::
    object_association ()
    {
      return this->object_association_;
    }

    void data_getAssociatedObjects_response::
    object_association (const object_association_sequence& s)
    {
      this->object_association_ = s;
    }

    const data_getAssociatedObjects_response::list_optional& data_getAssociatedObjects_response::
    list () const
    {
      return this->list_;
    }

    data_getAssociatedObjects_response::list_optional& data_getAssociatedObjects_response::
    list ()
    {
      return this->list_;
    }

    void data_getAssociatedObjects_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getAssociatedObjects_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getAssociatedObjectCounts_response
    // 

    const data_getAssociatedObjectCounts_response::data_getAssociatedObjectCounts_response_elt_sequence& data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response_elt () const
    {
      return this->data_getAssociatedObjectCounts_response_elt_;
    }

    data_getAssociatedObjectCounts_response::data_getAssociatedObjectCounts_response_elt_sequence& data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response_elt ()
    {
      return this->data_getAssociatedObjectCounts_response_elt_;
    }

    void data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response_elt (const data_getAssociatedObjectCounts_response_elt_sequence& s)
    {
      this->data_getAssociatedObjectCounts_response_elt_ = s;
    }

    const data_getAssociatedObjectCounts_response::list_optional& data_getAssociatedObjectCounts_response::
    list () const
    {
      return this->list_;
    }

    data_getAssociatedObjectCounts_response::list_optional& data_getAssociatedObjectCounts_response::
    list ()
    {
      return this->list_;
    }

    void data_getAssociatedObjectCounts_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getAssociatedObjectCounts_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }


    // data_getAssociations_response
    // 

    const data_getAssociations_response::object_association_sequence& data_getAssociations_response::
    object_association () const
    {
      return this->object_association_;
    }

    data_getAssociations_response::object_association_sequence& data_getAssociations_response::
    object_association ()
    {
      return this->object_association_;
    }

    void data_getAssociations_response::
    object_association (const object_association_sequence& s)
    {
      this->object_association_ = s;
    }

    const data_getAssociations_response::list_optional& data_getAssociations_response::
    list () const
    {
      return this->list_;
    }

    data_getAssociations_response::list_optional& data_getAssociations_response::
    list ()
    {
      return this->list_;
    }

    void data_getAssociations_response::
    list (const list_type& x)
    {
      this->list_.set (x);
    }

    void data_getAssociations_response::
    list (const list_optional& x)
    {
      this->list_ = x;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace FacebookCpp
{
  namespace XSD
  {
    // container
    //

    container::
    container ()
    : ::xml_schema::string ()
    {
    }

    container::
    container (const char* string)
    : ::xml_schema::string (string)
    {
    }

    container::
    container (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    container::
    container (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    container::
    container (const container& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    container::
    container (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    container::
    container (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    container::
    container (const ::std::string& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    container* container::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new container (*this, f, c);
    }

    container::
    ~container ()
    {
    }

    // aid
    //

    aid::
    aid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    aid::
    aid (const aid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    aid::
    aid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    aid::
    aid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    aid::
    aid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    aid* aid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new aid (*this, f, c);
    }

    aid::
    ~aid ()
    {
    }

    // pid
    //

    pid::
    pid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    pid::
    pid (const pid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    pid::
    pid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    pid::
    pid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    pid::
    pid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    pid* pid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new pid (*this, f, c);
    }

    pid::
    ~pid ()
    {
    }

    // eid
    //

    eid::
    eid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    eid::
    eid (const eid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    eid::
    eid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    eid::
    eid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    eid::
    eid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    eid* eid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new eid (*this, f, c);
    }

    eid::
    ~eid ()
    {
    }

    // gid
    //

    gid::
    gid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    gid::
    gid (const gid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    gid::
    gid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    gid::
    gid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    gid::
    gid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    gid* gid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new gid (*this, f, c);
    }

    gid::
    ~gid ()
    {
    }

    // nid
    //

    nid::
    nid (const ::xml_schema::int_& int_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (int_)
    {
    }

    nid::
    nid (const nid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    nid::
    nid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    nid::
    nid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    nid::
    nid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    nid* nid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new nid (*this, f, c);
    }

    nid::
    ~nid ()
    {
    }

    // hsid
    //

    hsid::
    hsid (const ::xml_schema::int_& int_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (int_)
    {
    }

    hsid::
    hsid (const hsid& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    hsid::
    hsid (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    hsid::
    hsid (const xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    hsid::
    hsid (const ::std::string& s,
          const xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    hsid* hsid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new hsid (*this, f, c);
    }

    hsid::
    ~hsid ()
    {
    }

    // uid
    //

    uid::
    uid (const ::xml_schema::int_& int_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (int_)
    {
    }

    uid::
    uid (const uid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    uid::
    uid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    uid::
    uid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    uid::
    uid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    uid* uid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new uid (*this, f, c);
    }

    uid::
    ~uid ()
    {
    }

    // flid
    //

    flid::
    flid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    flid::
    flid (const flid& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    flid::
    flid (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    flid::
    flid (const xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    flid::
    flid (const ::std::string& s,
          const xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    flid* flid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new flid (*this, f, c);
    }

    flid::
    ~flid ()
    {
    }

    // id
    //

    id::
    id (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    id::
    id (const id& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    id::
    id (const xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    id::
    id (const xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    id::
    id (const ::std::string& s,
        const xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    id* id::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new id (*this, f, c);
    }

    id::
    ~id ()
    {
    }

    // lid
    //

    lid::
    lid (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    lid::
    lid (const lid& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    lid::
    lid (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    lid::
    lid (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    lid::
    lid (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    lid* lid::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new lid (*this, f, c);
    }

    lid::
    ~lid ()
    {
    }

    // page_id
    //

    page_id::
    page_id (const ::xml_schema::long_& long_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (long_)
    {
    }

    page_id::
    page_id (const page_id& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    page_id::
    page_id (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    page_id::
    page_id (const xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    page_id::
    page_id (const ::std::string& s,
             const xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    page_id* page_id::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_id (*this, f, c);
    }

    page_id::
    ~page_id ()
    {
    }

    // old_id_list
    //

    old_id_list::
    old_id_list ()
    : ::xml_schema::string ()
    {
    }

    old_id_list::
    old_id_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    old_id_list::
    old_id_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    old_id_list::
    old_id_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    old_id_list::
    old_id_list (const old_id_list& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    old_id_list::
    old_id_list (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    old_id_list::
    old_id_list (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    old_id_list::
    old_id_list (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    old_id_list* old_id_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new old_id_list (*this, f, c);
    }

    old_id_list::
    ~old_id_list ()
    {
    }

    // aid_list
    //

    aid_list::
    aid_list ()
    : ::xml_schema::string ()
    {
    }

    aid_list::
    aid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    aid_list::
    aid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    aid_list::
    aid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    aid_list::
    aid_list (const aid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    aid_list::
    aid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    aid_list::
    aid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    aid_list::
    aid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    aid_list* aid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new aid_list (*this, f, c);
    }

    aid_list::
    ~aid_list ()
    {
    }

    // pid_list
    //

    pid_list::
    pid_list ()
    : ::xml_schema::string ()
    {
    }

    pid_list::
    pid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    pid_list::
    pid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    pid_list::
    pid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    pid_list::
    pid_list (const pid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    pid_list::
    pid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    pid_list::
    pid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    pid_list::
    pid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    pid_list* pid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new pid_list (*this, f, c);
    }

    pid_list::
    ~pid_list ()
    {
    }

    // gid_list
    //

    gid_list::
    gid_list ()
    : ::xml_schema::string ()
    {
    }

    gid_list::
    gid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    gid_list::
    gid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    gid_list::
    gid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    gid_list::
    gid_list (const gid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    gid_list::
    gid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    gid_list::
    gid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    gid_list::
    gid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    gid_list* gid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new gid_list (*this, f, c);
    }

    gid_list::
    ~gid_list ()
    {
    }

    // eid_list
    //

    eid_list::
    eid_list ()
    : ::xml_schema::string ()
    {
    }

    eid_list::
    eid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    eid_list::
    eid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    eid_list::
    eid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    eid_list::
    eid_list (const eid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    eid_list::
    eid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    eid_list::
    eid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    eid_list::
    eid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    eid_list* eid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new eid_list (*this, f, c);
    }

    eid_list::
    ~eid_list ()
    {
    }

    // uid_list
    //

    uid_list::
    uid_list ()
    : ::xml_schema::string ()
    {
    }

    uid_list::
    uid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    uid_list::
    uid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    uid_list::
    uid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    uid_list::
    uid_list (const uid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    uid_list::
    uid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    uid_list::
    uid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    uid_list::
    uid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    uid_list* uid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new uid_list (*this, f, c);
    }

    uid_list::
    ~uid_list ()
    {
    }

    // field_list
    //

    field_list::
    field_list ()
    : ::xml_schema::string ()
    {
    }

    field_list::
    field_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    field_list::
    field_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    field_list::
    field_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    field_list::
    field_list (const field_list& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    field_list::
    field_list (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    field_list::
    field_list (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    field_list::
    field_list (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    field_list* field_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new field_list (*this, f, c);
    }

    field_list::
    ~field_list ()
    {
    }

    // tag_list
    //

    tag_list::
    tag_list ()
    : ::xml_schema::string ()
    {
    }

    tag_list::
    tag_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    tag_list::
    tag_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    tag_list::
    tag_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    tag_list::
    tag_list (const tag_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    tag_list::
    tag_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    tag_list::
    tag_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    tag_list::
    tag_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    tag_list* tag_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new tag_list (*this, f, c);
    }

    tag_list::
    ~tag_list ()
    {
    }

    // lid_list
    //

    lid_list::
    lid_list ()
    : ::xml_schema::string ()
    {
    }

    lid_list::
    lid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    lid_list::
    lid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    lid_list::
    lid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    lid_list::
    lid_list (const lid_list& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    lid_list::
    lid_list (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    lid_list::
    lid_list (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    lid_list::
    lid_list (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    lid_list* lid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new lid_list (*this, f, c);
    }

    lid_list::
    ~lid_list ()
    {
    }

    // pageid_list
    //

    pageid_list::
    pageid_list ()
    : ::xml_schema::string ()
    {
    }

    pageid_list::
    pageid_list (const char* string)
    : ::xml_schema::string (string)
    {
    }

    pageid_list::
    pageid_list (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    pageid_list::
    pageid_list (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    pageid_list::
    pageid_list (const pageid_list& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    pageid_list::
    pageid_list (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    pageid_list::
    pageid_list (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    pageid_list::
    pageid_list (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    pageid_list* pageid_list::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new pageid_list (*this, f, c);
    }

    pageid_list::
    ~pageid_list ()
    {
    }

    // time
    //

    time::
    time (const ::xml_schema::int_& int_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (int_)
    {
    }

    time::
    time (const time& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    time::
    time (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    time::
    time (const xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    time::
    time (const ::std::string& s,
          const xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    time* time::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new time (*this, f, c);
    }

    time::
    ~time ()
    {
    }

    // date
    //

    date::
    date ()
    : ::xml_schema::string ()
    {
    }

    date::
    date (const char* string)
    : ::xml_schema::string (string)
    {
    }

    date::
    date (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    date::
    date (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    date::
    date (const date& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    date::
    date (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    date::
    date (const xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    date::
    date (const ::std::string& s,
          const xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    date* date::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new date (*this, f, c);
    }

    date::
    ~date ()
    {
    }

    // year
    //

    year::
    year (const ::xml_schema::int_& int_)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (int_)
    {
    }

    year::
    year (const year& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    year::
    year (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    year::
    year (const xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    year::
    year (const ::std::string& s,
          const xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    year* year::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new year (*this, f, c);
    }

    year::
    ~year ()
    {
    }

    // auth_token
    //

    auth_token::
    auth_token ()
    : ::xml_schema::string ()
    {
    }

    auth_token::
    auth_token (const char* string)
    : ::xml_schema::string (string)
    {
    }

    auth_token::
    auth_token (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    auth_token::
    auth_token (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    auth_token::
    auth_token (const auth_token& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    auth_token::
    auth_token (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    auth_token::
    auth_token (const xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    auth_token::
    auth_token (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    auth_token* auth_token::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new auth_token (*this, f, c);
    }

    auth_token::
    ~auth_token ()
    {
    }

    // session_key
    //

    session_key::
    session_key ()
    : ::xml_schema::string ()
    {
    }

    session_key::
    session_key (const char* string)
    : ::xml_schema::string (string)
    {
    }

    session_key::
    session_key (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    session_key::
    session_key (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    session_key::
    session_key (const session_key& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    session_key::
    session_key (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    session_key::
    session_key (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    session_key::
    session_key (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    session_key* session_key::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new session_key (*this, f, c);
    }

    session_key::
    ~session_key ()
    {
    }

    // friend_link
    //

    friend_link::
    friend_link ()
    : ::xml_schema::string ()
    {
    }

    friend_link::
    friend_link (const char* string)
    : ::xml_schema::string (string)
    {
    }

    friend_link::
    friend_link (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    friend_link::
    friend_link (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    friend_link::
    friend_link (const friend_link& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    friend_link::
    friend_link (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    friend_link::
    friend_link (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    friend_link::
    friend_link (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    friend_link* friend_link::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friend_link (*this, f, c);
    }

    friend_link::
    ~friend_link ()
    {
    }

    // member_type
    //

    member_type::
    member_type ()
    : ::xml_schema::string ()
    {
    }

    member_type::
    member_type (const char* string)
    : ::xml_schema::string (string)
    {
    }

    member_type::
    member_type (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    member_type::
    member_type (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    member_type::
    member_type (const member_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    member_type::
    member_type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    member_type::
    member_type (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    member_type::
    member_type (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    member_type* member_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new member_type (*this, f, c);
    }

    member_type::
    ~member_type ()
    {
    }

    // old_id
    //

    old_id::
    old_id ()
    : ::xml_schema::string ()
    {
    }

    old_id::
    old_id (const char* string)
    : ::xml_schema::string (string)
    {
    }

    old_id::
    old_id (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    old_id::
    old_id (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    old_id::
    old_id (const old_id& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    old_id::
    old_id (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    old_id::
    old_id (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    old_id::
    old_id (const ::std::string& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    old_id* old_id::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new old_id (*this, f, c);
    }

    old_id::
    ~old_id ()
    {
    }

    // marketplace_category
    //

    marketplace_category::
    marketplace_category ()
    : ::xml_schema::string ()
    {
    }

    marketplace_category::
    marketplace_category (const char* string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_category::
    marketplace_category (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_category::
    marketplace_category (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_category::
    marketplace_category (const marketplace_category& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    marketplace_category::
    marketplace_category (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    marketplace_category::
    marketplace_category (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    marketplace_category::
    marketplace_category (const ::std::string& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    marketplace_category* marketplace_category::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_category (*this, f, c);
    }

    marketplace_category::
    ~marketplace_category ()
    {
    }

    // marketplace_subcategory
    //

    marketplace_subcategory::
    marketplace_subcategory ()
    : ::xml_schema::string ()
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const char* string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const marketplace_subcategory& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    marketplace_subcategory::
    marketplace_subcategory (const ::std::string& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    marketplace_subcategory* marketplace_subcategory::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_subcategory (*this, f, c);
    }

    marketplace_subcategory::
    ~marketplace_subcategory ()
    {
    }

    // json_string
    //

    json_string::
    json_string ()
    : ::xml_schema::string ()
    {
    }

    json_string::
    json_string (const char* string)
    : ::xml_schema::string (string)
    {
    }

    json_string::
    json_string (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    json_string::
    json_string (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    json_string::
    json_string (const json_string& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    json_string::
    json_string (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    json_string::
    json_string (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    json_string::
    json_string (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    json_string* json_string::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new json_string (*this, f, c);
    }

    json_string::
    ~json_string ()
    {
    }

    // concentration
    //

    concentration::
    concentration ()
    : ::xml_schema::string ()
    {
    }

    concentration::
    concentration (const char* string)
    : ::xml_schema::string (string)
    {
    }

    concentration::
    concentration (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    concentration::
    concentration (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    concentration::
    concentration (const concentration& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    concentration::
    concentration (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    concentration::
    concentration (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    concentration::
    concentration (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    concentration* concentration::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new concentration (*this, f, c);
    }

    concentration::
    ~concentration ()
    {
    }

    // sex
    //

    sex::
    sex ()
    : ::xml_schema::string ()
    {
    }

    sex::
    sex (const char* string)
    : ::xml_schema::string (string)
    {
    }

    sex::
    sex (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    sex::
    sex (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    sex::
    sex (const sex& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    sex::
    sex (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    sex::
    sex (const xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    sex::
    sex (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    sex* sex::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new sex (*this, f, c);
    }

    sex::
    ~sex ()
    {
    }

    // seeking
    //

    seeking::
    seeking ()
    : ::xml_schema::string ()
    {
    }

    seeking::
    seeking (const char* string)
    : ::xml_schema::string (string)
    {
    }

    seeking::
    seeking (const ::std::string& string)
    : ::xml_schema::string (string)
    {
    }

    seeking::
    seeking (const ::xml_schema::string& string)
    : ::xml_schema::string (string)
    {
    }

    seeking::
    seeking (const seeking& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c)
    {
    }

    seeking::
    seeking (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    seeking::
    seeking (const xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    seeking::
    seeking (const ::std::string& s,
             const xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    seeking* seeking::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new seeking (*this, f, c);
    }

    seeking::
    ~seeking ()
    {
    }

    // user_status
    //

    user_status::
    user_status (const message_type& message,
                 const time_type& time)
    : ::xml_schema::type (),
      message_ (message, ::xml_schema::flags (), this),
      time_ (time, ::xml_schema::flags (), this)
    {
    }

    user_status::
    user_status (const user_status& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      message_ (x.message_, f, this),
      time_ (x.time_, f, this)
    {
    }

    user_status::
    user_status (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      message_ (f, this),
      time_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void user_status::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // message
        //
        if (n.name () == "message" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< message_type > r (
            message_traits::create (i, f, this));

          if (!message_.present ())
          {
            this->message (r);
            continue;
          }
        }

        // time
        //
        if (n.name () == "time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< time_type > r (
            time_traits::create (i, f, this));

          if (!time_.present ())
          {
            this->time (r);
            continue;
          }
        }

        break;
      }

      if (!message_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "message",
          "http://api.facebook.com/1.0/");
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time",
          "http://api.facebook.com/1.0/");
      }
    }

    user_status* user_status::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new user_status (*this, f, c);
    }

    user_status::
    ~user_status ()
    {
    }

    // id_map
    //

    id_map::
    id_map (const old_id_type& old_id,
            const new_id_type& new_id)
    : ::xml_schema::type (),
      old_id_ (old_id, ::xml_schema::flags (), this),
      new_id_ (new_id, ::xml_schema::flags (), this)
    {
    }

    id_map::
    id_map (const id_map& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      old_id_ (x.old_id_, f, this),
      new_id_ (x.new_id_, f, this)
    {
    }

    id_map::
    id_map (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      old_id_ (f, this),
      new_id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void id_map::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // old_id
        //
        if (n.name () == "old_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< old_id_type > r (
            old_id_traits::create (i, f, this));

          if (!old_id_.present ())
          {
            this->old_id (r);
            continue;
          }
        }

        // new_id
        //
        if (n.name () == "new_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< new_id_type > r (
            new_id_traits::create (i, f, this));

          if (!new_id_.present ())
          {
            this->new_id (r);
            continue;
          }
        }

        break;
      }

      if (!old_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "old_id",
          "http://api.facebook.com/1.0/");
      }

      if (!new_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "new_id",
          "http://api.facebook.com/1.0/");
      }
    }

    id_map* id_map::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new id_map (*this, f, c);
    }

    id_map::
    ~id_map ()
    {
    }

    // arg
    //

    arg::
    arg (const key_type& key,
         const value_type& value)
    : ::xml_schema::type (),
      key_ (key, ::xml_schema::flags (), this),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    arg::
    arg (const arg& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    arg::
    arg (const xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void arg::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // key
        //
        if (n.name () == "key" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< key_type > r (
            key_traits::create (i, f, this));

          if (!key_.present ())
          {
            this->key (r);
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          if (!value_.present ())
          {
            this->value (r);
            continue;
          }
        }

        break;
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "key",
          "http://api.facebook.com/1.0/");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "http://api.facebook.com/1.0/");
      }
    }

    arg* arg::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new arg (*this, f, c);
    }

    arg::
    ~arg ()
    {
    }

    // FacebookApiException
    //

    FacebookApiException::
    FacebookApiException (const error_code_type& error_code,
                          const error_msg_type& error_msg,
                          const request_args_type& request_args)
    : ::xml_schema::type (),
      error_code_ (error_code, ::xml_schema::flags (), this),
      error_msg_ (error_msg, ::xml_schema::flags (), this),
      request_args_ (request_args, ::xml_schema::flags (), this)
    {
    }

    FacebookApiException::
    FacebookApiException (const FacebookApiException& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      error_code_ (x.error_code_, f, this),
      error_msg_ (x.error_msg_, f, this),
      request_args_ (x.request_args_, f, this)
    {
    }

    FacebookApiException::
    FacebookApiException (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      error_code_ (f, this),
      error_msg_ (f, this),
      request_args_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void FacebookApiException::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // error_code
        //
        if (n.name () == "error_code" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!error_code_.present ())
          {
            this->error_code (error_code_traits::create (i, f, this));
            continue;
          }
        }

        // error_msg
        //
        if (n.name () == "error_msg" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< error_msg_type > r (
            error_msg_traits::create (i, f, this));

          if (!error_msg_.present ())
          {
            this->error_msg (r);
            continue;
          }
        }

        // request_args
        //
        if (n.name () == "request_args" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< request_args_type > r (
            request_args_traits::create (i, f, this));

          if (!request_args_.present ())
          {
            this->request_args (r);
            continue;
          }
        }

        break;
      }

      if (!error_code_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "error_code",
          "http://api.facebook.com/1.0/");
      }

      if (!error_msg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "error_msg",
          "http://api.facebook.com/1.0/");
      }

      if (!request_args_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "request_args",
          "http://api.facebook.com/1.0/");
      }
    }

    FacebookApiException* FacebookApiException::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new FacebookApiException (*this, f, c);
    }

    FacebookApiException::
    ~FacebookApiException ()
    {
    }

    // session_info
    //

    session_info::
    session_info (const session_key_type& session_key,
                  const uid_type& uid,
                  const expires_type& expires)
    : ::xml_schema::type (),
      session_key_ (session_key, ::xml_schema::flags (), this),
      uid_ (uid, ::xml_schema::flags (), this),
      expires_ (expires, ::xml_schema::flags (), this),
      secret_ (::xml_schema::flags (), this)
    {
    }

    session_info::
    session_info (const session_info& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      session_key_ (x.session_key_, f, this),
      uid_ (x.uid_, f, this),
      expires_ (x.expires_, f, this),
      secret_ (x.secret_, f, this)
    {
    }

    session_info::
    session_info (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      session_key_ (f, this),
      uid_ (f, this),
      expires_ (f, this),
      secret_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void session_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // session_key
        //
        if (n.name () == "session_key" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< session_key_type > r (
            session_key_traits::create (i, f, this));

          if (!session_key_.present ())
          {
            this->session_key (r);
            continue;
          }
        }

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          if (!uid_.present ())
          {
            this->uid (r);
            continue;
          }
        }

        // expires
        //
        if (n.name () == "expires" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!expires_.present ())
          {
            this->expires (expires_traits::create (i, f, this));
            continue;
          }
        }

        // secret
        //
        if (n.name () == "secret" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< secret_type > r (
            secret_traits::create (i, f, this));

          if (!this->secret ())
          {
            this->secret (r);
            continue;
          }
        }

        break;
      }

      if (!session_key_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "session_key",
          "http://api.facebook.com/1.0/");
      }

      if (!uid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uid",
          "http://api.facebook.com/1.0/");
      }

      if (!expires_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "expires",
          "http://api.facebook.com/1.0/");
      }
    }

    session_info* session_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new session_info (*this, f, c);
    }

    session_info::
    ~session_info ()
    {
    }

    // location
    //

    location::
    location ()
    : ::xml_schema::type (),
      street_ (::xml_schema::flags (), this),
      city_ (::xml_schema::flags (), this),
      state_ (::xml_schema::flags (), this),
      country_ (::xml_schema::flags (), this),
      zip_ (::xml_schema::flags (), this),
      latitude_ (::xml_schema::flags (), this),
      longitude_ (::xml_schema::flags (), this)
    {
    }

    location::
    location (const location& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      street_ (x.street_, f, this),
      city_ (x.city_, f, this),
      state_ (x.state_, f, this),
      country_ (x.country_, f, this),
      zip_ (x.zip_, f, this),
      latitude_ (x.latitude_, f, this),
      longitude_ (x.longitude_, f, this)
    {
    }

    location::
    location (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      street_ (f, this),
      city_ (f, this),
      state_ (f, this),
      country_ (f, this),
      zip_ (f, this),
      latitude_ (f, this),
      longitude_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void location::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // street
        //
        if (n.name () == "street" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< street_type > r (
            street_traits::create (i, f, this));

          if (!this->street ())
          {
            this->street (r);
            continue;
          }
        }

        // city
        //
        if (n.name () == "city" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< city_type > r (
            city_traits::create (i, f, this));

          if (!this->city ())
          {
            this->city (r);
            continue;
          }
        }

        // state
        //
        if (n.name () == "state" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< state_type > r (
            state_traits::create (i, f, this));

          if (!this->state ())
          {
            this->state (r);
            continue;
          }
        }

        // country
        //
        if (n.name () == "country" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< country_type > r (
            country_traits::create (i, f, this));

          if (!this->country ())
          {
            this->country (r);
            continue;
          }
        }

        // zip
        //
        if (n.name () == "zip" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< zip_type > r (
            zip_traits::create (i, f, this));

          if (!this->zip ())
          {
            this->zip (r);
            continue;
          }
        }

        // latitude
        //
        if (n.name () == "latitude" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->latitude ())
          {
            this->latitude (latitude_traits::create (i, f, this));
            continue;
          }
        }

        // longitude
        //
        if (n.name () == "longitude" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->longitude ())
          {
            this->longitude (longitude_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    location* location::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new location (*this, f, c);
    }

    location::
    ~location ()
    {
    }

    // event
    //

    event::
    event (const eid_type& eid,
           const name_type& name,
           const tagline_type& tagline,
           const nid_type& nid,
           const pic_type& pic,
           const pic_big_type& pic_big,
           const pic_small_type& pic_small,
           const host_type& host,
           const description_type& description,
           const event_type_type& event_type,
           const event_subtype_type& event_subtype,
           const start_time_type& start_time,
           const end_time_type& end_time,
           const creator_type& creator,
           const update_time_type& update_time,
           const location_type& location,
           const venue_type& venue)
    : ::xml_schema::type (),
      eid_ (eid, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      tagline_ (tagline, ::xml_schema::flags (), this),
      nid_ (nid, ::xml_schema::flags (), this),
      pic_ (pic, ::xml_schema::flags (), this),
      pic_big_ (pic_big, ::xml_schema::flags (), this),
      pic_small_ (pic_small, ::xml_schema::flags (), this),
      host_ (host, ::xml_schema::flags (), this),
      description_ (description, ::xml_schema::flags (), this),
      event_type_ (event_type, ::xml_schema::flags (), this),
      event_subtype_ (event_subtype, ::xml_schema::flags (), this),
      start_time_ (start_time, ::xml_schema::flags (), this),
      end_time_ (end_time, ::xml_schema::flags (), this),
      creator_ (creator, ::xml_schema::flags (), this),
      update_time_ (update_time, ::xml_schema::flags (), this),
      location_ (location, ::xml_schema::flags (), this),
      venue_ (venue, ::xml_schema::flags (), this)
    {
    }

    event::
    event (const event& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      eid_ (x.eid_, f, this),
      name_ (x.name_, f, this),
      tagline_ (x.tagline_, f, this),
      nid_ (x.nid_, f, this),
      pic_ (x.pic_, f, this),
      pic_big_ (x.pic_big_, f, this),
      pic_small_ (x.pic_small_, f, this),
      host_ (x.host_, f, this),
      description_ (x.description_, f, this),
      event_type_ (x.event_type_, f, this),
      event_subtype_ (x.event_subtype_, f, this),
      start_time_ (x.start_time_, f, this),
      end_time_ (x.end_time_, f, this),
      creator_ (x.creator_, f, this),
      update_time_ (x.update_time_, f, this),
      location_ (x.location_, f, this),
      venue_ (x.venue_, f, this)
    {
    }

    event::
    event (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      eid_ (f, this),
      name_ (f, this),
      tagline_ (f, this),
      nid_ (f, this),
      pic_ (f, this),
      pic_big_ (f, this),
      pic_small_ (f, this),
      host_ (f, this),
      description_ (f, this),
      event_type_ (f, this),
      event_subtype_ (f, this),
      start_time_ (f, this),
      end_time_ (f, this),
      creator_ (f, this),
      update_time_ (f, this),
      location_ (f, this),
      venue_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void event::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // eid
        //
        if (n.name () == "eid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< eid_type > r (
            eid_traits::create (i, f, this));

          if (!eid_.present ())
          {
            this->eid (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // tagline
        //
        if (n.name () == "tagline" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tagline_type > r (
            tagline_traits::create (i, f, this));

          if (!tagline_.present ())
          {
            this->tagline (r);
            continue;
          }
        }

        // nid
        //
        if (n.name () == "nid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< nid_type > r (
            nid_traits::create (i, f, this));

          if (!nid_.present ())
          {
            this->nid (r);
            continue;
          }
        }

        // pic
        //
        if (n.name () == "pic" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_type > r (
            pic_traits::create (i, f, this));

          if (!pic_.present ())
          {
            this->pic (r);
            continue;
          }
        }

        // pic_big
        //
        if (n.name () == "pic_big" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_big_type > r (
            pic_big_traits::create (i, f, this));

          if (!pic_big_.present ())
          {
            this->pic_big (r);
            continue;
          }
        }

        // pic_small
        //
        if (n.name () == "pic_small" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_small_type > r (
            pic_small_traits::create (i, f, this));

          if (!pic_small_.present ())
          {
            this->pic_small (r);
            continue;
          }
        }

        // host
        //
        if (n.name () == "host" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< host_type > r (
            host_traits::create (i, f, this));

          if (!host_.present ())
          {
            this->host (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // event_type
        //
        if (n.name () == "event_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< event_type_type > r (
            event_type_traits::create (i, f, this));

          if (!event_type_.present ())
          {
            this->event_type (r);
            continue;
          }
        }

        // event_subtype
        //
        if (n.name () == "event_subtype" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< event_subtype_type > r (
            event_subtype_traits::create (i, f, this));

          if (!event_subtype_.present ())
          {
            this->event_subtype (r);
            continue;
          }
        }

        // start_time
        //
        if (n.name () == "start_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< start_time_type > r (
            start_time_traits::create (i, f, this));

          if (!start_time_.present ())
          {
            this->start_time (r);
            continue;
          }
        }

        // end_time
        //
        if (n.name () == "end_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< end_time_type > r (
            end_time_traits::create (i, f, this));

          if (!end_time_.present ())
          {
            this->end_time (r);
            continue;
          }
        }

        // creator
        //
        if (n.name () == "creator" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< creator_type > r (
            creator_traits::create (i, f, this));

          if (!creator_.present ())
          {
            this->creator (r);
            continue;
          }
        }

        // update_time
        //
        if (n.name () == "update_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< update_time_type > r (
            update_time_traits::create (i, f, this));

          if (!update_time_.present ())
          {
            this->update_time (r);
            continue;
          }
        }

        // location
        //
        if (n.name () == "location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< location_type > r (
            location_traits::create (i, f, this));

          if (!location_.present ())
          {
            this->location (r);
            continue;
          }
        }

        // venue
        //
        if (n.name () == "venue" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< venue_type > r (
            venue_traits::create (i, f, this));

          if (!venue_.present ())
          {
            this->venue (r);
            continue;
          }
        }

        break;
      }

      if (!eid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "eid",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!tagline_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tagline",
          "http://api.facebook.com/1.0/");
      }

      if (!nid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nid",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_big_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic_big",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_small_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic_small",
          "http://api.facebook.com/1.0/");
      }

      if (!host_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "host",
          "http://api.facebook.com/1.0/");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!event_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "event_type",
          "http://api.facebook.com/1.0/");
      }

      if (!event_subtype_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "event_subtype",
          "http://api.facebook.com/1.0/");
      }

      if (!start_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "start_time",
          "http://api.facebook.com/1.0/");
      }

      if (!end_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "end_time",
          "http://api.facebook.com/1.0/");
      }

      if (!creator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "creator",
          "http://api.facebook.com/1.0/");
      }

      if (!update_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "update_time",
          "http://api.facebook.com/1.0/");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "http://api.facebook.com/1.0/");
      }

      if (!venue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "venue",
          "http://api.facebook.com/1.0/");
      }
    }

    event* event::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new event (*this, f, c);
    }

    event::
    ~event ()
    {
    }

    // event_member
    //

    event_member::
    event_member (const uid_type& uid,
                  const oid_type& oid,
                  const attending_type& attending)
    : ::xml_schema::type (),
      uid_ (uid, ::xml_schema::flags (), this),
      oid_ (oid, ::xml_schema::flags (), this),
      attending_ (attending, ::xml_schema::flags (), this)
    {
    }

    event_member::
    event_member (const event_member& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      oid_ (x.oid_, f, this),
      attending_ (x.attending_, f, this)
    {
    }

    event_member::
    event_member (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      oid_ (f, this),
      attending_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void event_member::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          if (!uid_.present ())
          {
            this->uid (r);
            continue;
          }
        }

        // oid
        //
        if (n.name () == "oid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< oid_type > r (
            oid_traits::create (i, f, this));

          if (!oid_.present ())
          {
            this->oid (r);
            continue;
          }
        }

        // attending
        //
        if (n.name () == "attending" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< attending_type > r (
            attending_traits::create (i, f, this));

          if (!attending_.present ())
          {
            this->attending (r);
            continue;
          }
        }

        break;
      }

      if (!uid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uid",
          "http://api.facebook.com/1.0/");
      }

      if (!oid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "oid",
          "http://api.facebook.com/1.0/");
      }

      if (!attending_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "attending",
          "http://api.facebook.com/1.0/");
      }
    }

    event_member* event_member::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new event_member (*this, f, c);
    }

    event_member::
    ~event_member ()
    {
    }

    // group
    //

    group::
    group (const gid_type& gid,
           const name_type& name,
           const nid_type& nid,
           const description_type& description,
           const group_type_type& group_type,
           const group_subtype_type& group_subtype,
           const recent_news_type& recent_news,
           const pic_type& pic,
           const pic_big_type& pic_big,
           const pic_small_type& pic_small,
           const creator_type& creator,
           const update_time_type& update_time,
           const office_type& office,
           const website_type& website,
           const venue_type& venue)
    : ::xml_schema::type (),
      gid_ (gid, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      nid_ (nid, ::xml_schema::flags (), this),
      description_ (description, ::xml_schema::flags (), this),
      group_type_ (group_type, ::xml_schema::flags (), this),
      group_subtype_ (group_subtype, ::xml_schema::flags (), this),
      recent_news_ (recent_news, ::xml_schema::flags (), this),
      pic_ (pic, ::xml_schema::flags (), this),
      pic_big_ (pic_big, ::xml_schema::flags (), this),
      pic_small_ (pic_small, ::xml_schema::flags (), this),
      creator_ (creator, ::xml_schema::flags (), this),
      update_time_ (update_time, ::xml_schema::flags (), this),
      office_ (office, ::xml_schema::flags (), this),
      website_ (website, ::xml_schema::flags (), this),
      venue_ (venue, ::xml_schema::flags (), this)
    {
    }

    group::
    group (const group& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      gid_ (x.gid_, f, this),
      name_ (x.name_, f, this),
      nid_ (x.nid_, f, this),
      description_ (x.description_, f, this),
      group_type_ (x.group_type_, f, this),
      group_subtype_ (x.group_subtype_, f, this),
      recent_news_ (x.recent_news_, f, this),
      pic_ (x.pic_, f, this),
      pic_big_ (x.pic_big_, f, this),
      pic_small_ (x.pic_small_, f, this),
      creator_ (x.creator_, f, this),
      update_time_ (x.update_time_, f, this),
      office_ (x.office_, f, this),
      website_ (x.website_, f, this),
      venue_ (x.venue_, f, this)
    {
    }

    group::
    group (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      gid_ (f, this),
      name_ (f, this),
      nid_ (f, this),
      description_ (f, this),
      group_type_ (f, this),
      group_subtype_ (f, this),
      recent_news_ (f, this),
      pic_ (f, this),
      pic_big_ (f, this),
      pic_small_ (f, this),
      creator_ (f, this),
      update_time_ (f, this),
      office_ (f, this),
      website_ (f, this),
      venue_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void group::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // gid
        //
        if (n.name () == "gid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< gid_type > r (
            gid_traits::create (i, f, this));

          if (!gid_.present ())
          {
            this->gid (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // nid
        //
        if (n.name () == "nid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< nid_type > r (
            nid_traits::create (i, f, this));

          if (!nid_.present ())
          {
            this->nid (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // group_type
        //
        if (n.name () == "group_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< group_type_type > r (
            group_type_traits::create (i, f, this));

          if (!group_type_.present ())
          {
            this->group_type (r);
            continue;
          }
        }

        // group_subtype
        //
        if (n.name () == "group_subtype" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< group_subtype_type > r (
            group_subtype_traits::create (i, f, this));

          if (!group_subtype_.present ())
          {
            this->group_subtype (r);
            continue;
          }
        }

        // recent_news
        //
        if (n.name () == "recent_news" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< recent_news_type > r (
            recent_news_traits::create (i, f, this));

          if (!recent_news_.present ())
          {
            this->recent_news (r);
            continue;
          }
        }

        // pic
        //
        if (n.name () == "pic" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_type > r (
            pic_traits::create (i, f, this));

          if (!pic_.present ())
          {
            this->pic (r);
            continue;
          }
        }

        // pic_big
        //
        if (n.name () == "pic_big" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_big_type > r (
            pic_big_traits::create (i, f, this));

          if (!pic_big_.present ())
          {
            this->pic_big (r);
            continue;
          }
        }

        // pic_small
        //
        if (n.name () == "pic_small" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_small_type > r (
            pic_small_traits::create (i, f, this));

          if (!pic_small_.present ())
          {
            this->pic_small (r);
            continue;
          }
        }

        // creator
        //
        if (n.name () == "creator" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< creator_type > r (
            creator_traits::create (i, f, this));

          if (!creator_.present ())
          {
            this->creator (r);
            continue;
          }
        }

        // update_time
        //
        if (n.name () == "update_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< update_time_type > r (
            update_time_traits::create (i, f, this));

          if (!update_time_.present ())
          {
            this->update_time (r);
            continue;
          }
        }

        // office
        //
        if (n.name () == "office" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< office_type > r (
            office_traits::create (i, f, this));

          if (!office_.present ())
          {
            this->office (r);
            continue;
          }
        }

        // website
        //
        if (n.name () == "website" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< website_type > r (
            website_traits::create (i, f, this));

          if (!website_.present ())
          {
            this->website (r);
            continue;
          }
        }

        // venue
        //
        if (n.name () == "venue" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< venue_type > r (
            venue_traits::create (i, f, this));

          if (!venue_.present ())
          {
            this->venue (r);
            continue;
          }
        }

        break;
      }

      if (!gid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "gid",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!nid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nid",
          "http://api.facebook.com/1.0/");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!group_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "group_type",
          "http://api.facebook.com/1.0/");
      }

      if (!group_subtype_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "group_subtype",
          "http://api.facebook.com/1.0/");
      }

      if (!recent_news_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "recent_news",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_big_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic_big",
          "http://api.facebook.com/1.0/");
      }

      if (!pic_small_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pic_small",
          "http://api.facebook.com/1.0/");
      }

      if (!creator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "creator",
          "http://api.facebook.com/1.0/");
      }

      if (!update_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "update_time",
          "http://api.facebook.com/1.0/");
      }

      if (!office_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "office",
          "http://api.facebook.com/1.0/");
      }

      if (!website_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "website",
          "http://api.facebook.com/1.0/");
      }

      if (!venue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "venue",
          "http://api.facebook.com/1.0/");
      }
    }

    group* group::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new group (*this, f, c);
    }

    group::
    ~group ()
    {
    }

    // group_member
    //

    group_member::
    group_member (const uid_type& uid,
                  const gid_type& gid,
                  const positions_type& positions)
    : ::xml_schema::type (),
      uid_ (uid, ::xml_schema::flags (), this),
      gid_ (gid, ::xml_schema::flags (), this),
      positions_ (positions, ::xml_schema::flags (), this)
    {
    }

    group_member::
    group_member (const group_member& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      gid_ (x.gid_, f, this),
      positions_ (x.positions_, f, this)
    {
    }

    group_member::
    group_member (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      gid_ (f, this),
      positions_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void group_member::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          if (!uid_.present ())
          {
            this->uid (r);
            continue;
          }
        }

        // gid
        //
        if (n.name () == "gid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< gid_type > r (
            gid_traits::create (i, f, this));

          if (!gid_.present ())
          {
            this->gid (r);
            continue;
          }
        }

        // positions
        //
        if (n.name () == "positions" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< positions_type > r (
            positions_traits::create (i, f, this));

          if (!positions_.present ())
          {
            this->positions (r);
            continue;
          }
        }

        break;
      }

      if (!uid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uid",
          "http://api.facebook.com/1.0/");
      }

      if (!gid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "gid",
          "http://api.facebook.com/1.0/");
      }

      if (!positions_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "positions",
          "http://api.facebook.com/1.0/");
      }
    }

    group_member* group_member::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new group_member (*this, f, c);
    }

    group_member::
    ~group_member ()
    {
    }

    // group_members
    //

    group_members::
    group_members (const members_type& members,
                   const admins_type& admins,
                   const officers_type& officers,
                   const not_replied_type& not_replied)
    : ::xml_schema::type (),
      members_ (members, ::xml_schema::flags (), this),
      admins_ (admins, ::xml_schema::flags (), this),
      officers_ (officers, ::xml_schema::flags (), this),
      not_replied_ (not_replied, ::xml_schema::flags (), this)
    {
    }

    group_members::
    group_members (const group_members& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      members_ (x.members_, f, this),
      admins_ (x.admins_, f, this),
      officers_ (x.officers_, f, this),
      not_replied_ (x.not_replied_, f, this)
    {
    }

    group_members::
    group_members (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      members_ (f, this),
      admins_ (f, this),
      officers_ (f, this),
      not_replied_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void group_members::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // members
        //
        if (n.name () == "members" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< members_type > r (
            members_traits::create (i, f, this));

          if (!members_.present ())
          {
            this->members (r);
            continue;
          }
        }

        // admins
        //
        if (n.name () == "admins" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< admins_type > r (
            admins_traits::create (i, f, this));

          if (!admins_.present ())
          {
            this->admins (r);
            continue;
          }
        }

        // officers
        //
        if (n.name () == "officers" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< officers_type > r (
            officers_traits::create (i, f, this));

          if (!officers_.present ())
          {
            this->officers (r);
            continue;
          }
        }

        // not_replied
        //
        if (n.name () == "not_replied" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< not_replied_type > r (
            not_replied_traits::create (i, f, this));

          if (!not_replied_.present ())
          {
            this->not_replied (r);
            continue;
          }
        }

        break;
      }

      if (!members_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "members",
          "http://api.facebook.com/1.0/");
      }

      if (!admins_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "admins",
          "http://api.facebook.com/1.0/");
      }

      if (!officers_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "officers",
          "http://api.facebook.com/1.0/");
      }

      if (!not_replied_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "not_replied",
          "http://api.facebook.com/1.0/");
      }
    }

    group_members* group_members::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new group_members (*this, f, c);
    }

    group_members::
    ~group_members ()
    {
    }

    // event_members
    //

    event_members::
    event_members (const attending_type& attending,
                   const unsure_type& unsure,
                   const declined_type& declined,
                   const not_replied_type& not_replied)
    : ::xml_schema::type (),
      attending_ (attending, ::xml_schema::flags (), this),
      unsure_ (unsure, ::xml_schema::flags (), this),
      declined_ (declined, ::xml_schema::flags (), this),
      not_replied_ (not_replied, ::xml_schema::flags (), this)
    {
    }

    event_members::
    event_members (const event_members& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      attending_ (x.attending_, f, this),
      unsure_ (x.unsure_, f, this),
      declined_ (x.declined_, f, this),
      not_replied_ (x.not_replied_, f, this)
    {
    }

    event_members::
    event_members (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      attending_ (f, this),
      unsure_ (f, this),
      declined_ (f, this),
      not_replied_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void event_members::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // attending
        //
        if (n.name () == "attending" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< attending_type > r (
            attending_traits::create (i, f, this));

          if (!attending_.present ())
          {
            this->attending (r);
            continue;
          }
        }

        // unsure
        //
        if (n.name () == "unsure" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< unsure_type > r (
            unsure_traits::create (i, f, this));

          if (!unsure_.present ())
          {
            this->unsure (r);
            continue;
          }
        }

        // declined
        //
        if (n.name () == "declined" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< declined_type > r (
            declined_traits::create (i, f, this));

          if (!declined_.present ())
          {
            this->declined (r);
            continue;
          }
        }

        // not_replied
        //
        if (n.name () == "not_replied" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< not_replied_type > r (
            not_replied_traits::create (i, f, this));

          if (!not_replied_.present ())
          {
            this->not_replied (r);
            continue;
          }
        }

        break;
      }

      if (!attending_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "attending",
          "http://api.facebook.com/1.0/");
      }

      if (!unsure_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "unsure",
          "http://api.facebook.com/1.0/");
      }

      if (!declined_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "declined",
          "http://api.facebook.com/1.0/");
      }

      if (!not_replied_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "not_replied",
          "http://api.facebook.com/1.0/");
      }
    }

    event_members* event_members::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new event_members (*this, f, c);
    }

    event_members::
    ~event_members ()
    {
    }

    // notification_count
    //

    notification_count::
    notification_count (const unread_type& unread,
                        const most_recent_type& most_recent)
    : ::xml_schema::type (),
      unread_ (unread, ::xml_schema::flags (), this),
      most_recent_ (most_recent, ::xml_schema::flags (), this)
    {
    }

    notification_count::
    notification_count (const notification_count& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      unread_ (x.unread_, f, this),
      most_recent_ (x.most_recent_, f, this)
    {
    }

    notification_count::
    notification_count (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      unread_ (f, this),
      most_recent_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void notification_count::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // unread
        //
        if (n.name () == "unread" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!unread_.present ())
          {
            this->unread (unread_traits::create (i, f, this));
            continue;
          }
        }

        // most_recent
        //
        if (n.name () == "most_recent" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< most_recent_type > r (
            most_recent_traits::create (i, f, this));

          if (!most_recent_.present ())
          {
            this->most_recent (r);
            continue;
          }
        }

        break;
      }

      if (!unread_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "unread",
          "http://api.facebook.com/1.0/");
      }

      if (!most_recent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "most_recent",
          "http://api.facebook.com/1.0/");
      }
    }

    notification_count* notification_count::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new notification_count (*this, f, c);
    }

    notification_count::
    ~notification_count ()
    {
    }

    // notifications
    //

    notifications::
    notifications (const messages_type& messages,
                   const pokes_type& pokes,
                   const shares_type& shares,
                   const friend_requests_type& friend_requests,
                   const group_invites_type& group_invites,
                   const event_invites_type& event_invites)
    : ::xml_schema::type (),
      messages_ (messages, ::xml_schema::flags (), this),
      pokes_ (pokes, ::xml_schema::flags (), this),
      shares_ (shares, ::xml_schema::flags (), this),
      friend_requests_ (friend_requests, ::xml_schema::flags (), this),
      group_invites_ (group_invites, ::xml_schema::flags (), this),
      event_invites_ (event_invites, ::xml_schema::flags (), this)
    {
    }

    notifications::
    notifications (const notifications& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      messages_ (x.messages_, f, this),
      pokes_ (x.pokes_, f, this),
      shares_ (x.shares_, f, this),
      friend_requests_ (x.friend_requests_, f, this),
      group_invites_ (x.group_invites_, f, this),
      event_invites_ (x.event_invites_, f, this)
    {
    }

    notifications::
    notifications (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      messages_ (f, this),
      pokes_ (f, this),
      shares_ (f, this),
      friend_requests_ (f, this),
      group_invites_ (f, this),
      event_invites_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void notifications::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // messages
        //
        if (n.name () == "messages" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< messages_type > r (
            messages_traits::create (i, f, this));

          if (!messages_.present ())
          {
            this->messages (r);
            continue;
          }
        }

        // pokes
        //
        if (n.name () == "pokes" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pokes_type > r (
            pokes_traits::create (i, f, this));

          if (!pokes_.present ())
          {
            this->pokes (r);
            continue;
          }
        }

        // shares
        //
        if (n.name () == "shares" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< shares_type > r (
            shares_traits::create (i, f, this));

          if (!shares_.present ())
          {
            this->shares (r);
            continue;
          }
        }

        // friend_requests
        //
        if (n.name () == "friend_requests" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< friend_requests_type > r (
            friend_requests_traits::create (i, f, this));

          if (!friend_requests_.present ())
          {
            this->friend_requests (r);
            continue;
          }
        }

        // group_invites
        //
        if (n.name () == "group_invites" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< group_invites_type > r (
            group_invites_traits::create (i, f, this));

          if (!group_invites_.present ())
          {
            this->group_invites (r);
            continue;
          }
        }

        // event_invites
        //
        if (n.name () == "event_invites" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< event_invites_type > r (
            event_invites_traits::create (i, f, this));

          if (!event_invites_.present ())
          {
            this->event_invites (r);
            continue;
          }
        }

        break;
      }

      if (!messages_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "messages",
          "http://api.facebook.com/1.0/");
      }

      if (!pokes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pokes",
          "http://api.facebook.com/1.0/");
      }

      if (!shares_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shares",
          "http://api.facebook.com/1.0/");
      }

      if (!friend_requests_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "friend_requests",
          "http://api.facebook.com/1.0/");
      }

      if (!group_invites_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "group_invites",
          "http://api.facebook.com/1.0/");
      }

      if (!event_invites_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "event_invites",
          "http://api.facebook.com/1.0/");
      }
    }

    notifications* notifications::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new notifications (*this, f, c);
    }

    notifications::
    ~notifications ()
    {
    }

    // photo
    //

    photo::
    photo (const pid_type& pid,
           const aid_type& aid,
           const owner_type& owner,
           const src_type& src,
           const src_big_type& src_big,
           const src_small_type& src_small,
           const link_type& link,
           const caption_type& caption,
           const created_type& created)
    : ::xml_schema::type (),
      pid_ (pid, ::xml_schema::flags (), this),
      aid_ (aid, ::xml_schema::flags (), this),
      owner_ (owner, ::xml_schema::flags (), this),
      src_ (src, ::xml_schema::flags (), this),
      src_big_ (src_big, ::xml_schema::flags (), this),
      src_small_ (src_small, ::xml_schema::flags (), this),
      link_ (link, ::xml_schema::flags (), this),
      caption_ (caption, ::xml_schema::flags (), this),
      created_ (created, ::xml_schema::flags (), this)
    {
    }

    photo::
    photo (const photo& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      pid_ (x.pid_, f, this),
      aid_ (x.aid_, f, this),
      owner_ (x.owner_, f, this),
      src_ (x.src_, f, this),
      src_big_ (x.src_big_, f, this),
      src_small_ (x.src_small_, f, this),
      link_ (x.link_, f, this),
      caption_ (x.caption_, f, this),
      created_ (x.created_, f, this)
    {
    }

    photo::
    photo (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      pid_ (f, this),
      aid_ (f, this),
      owner_ (f, this),
      src_ (f, this),
      src_big_ (f, this),
      src_small_ (f, this),
      link_ (f, this),
      caption_ (f, this),
      created_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void photo::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pid
        //
        if (n.name () == "pid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pid_type > r (
            pid_traits::create (i, f, this));

          if (!pid_.present ())
          {
            this->pid (r);
            continue;
          }
        }

        // aid
        //
        if (n.name () == "aid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< aid_type > r (
            aid_traits::create (i, f, this));

          if (!aid_.present ())
          {
            this->aid (r);
            continue;
          }
        }

        // owner
        //
        if (n.name () == "owner" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< owner_type > r (
            owner_traits::create (i, f, this));

          if (!owner_.present ())
          {
            this->owner (r);
            continue;
          }
        }

        // src
        //
        if (n.name () == "src" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< src_type > r (
            src_traits::create (i, f, this));

          if (!src_.present ())
          {
            this->src (r);
            continue;
          }
        }

        // src_big
        //
        if (n.name () == "src_big" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< src_big_type > r (
            src_big_traits::create (i, f, this));

          if (!src_big_.present ())
          {
            this->src_big (r);
            continue;
          }
        }

        // src_small
        //
        if (n.name () == "src_small" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< src_small_type > r (
            src_small_traits::create (i, f, this));

          if (!src_small_.present ())
          {
            this->src_small (r);
            continue;
          }
        }

        // link
        //
        if (n.name () == "link" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< link_type > r (
            link_traits::create (i, f, this));

          if (!link_.present ())
          {
            this->link (r);
            continue;
          }
        }

        // caption
        //
        if (n.name () == "caption" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< caption_type > r (
            caption_traits::create (i, f, this));

          if (!caption_.present ())
          {
            this->caption (r);
            continue;
          }
        }

        // created
        //
        if (n.name () == "created" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< created_type > r (
            created_traits::create (i, f, this));

          if (!created_.present ())
          {
            this->created (r);
            continue;
          }
        }

        break;
      }

      if (!pid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pid",
          "http://api.facebook.com/1.0/");
      }

      if (!aid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "aid",
          "http://api.facebook.com/1.0/");
      }

      if (!owner_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "owner",
          "http://api.facebook.com/1.0/");
      }

      if (!src_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "src",
          "http://api.facebook.com/1.0/");
      }

      if (!src_big_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "src_big",
          "http://api.facebook.com/1.0/");
      }

      if (!src_small_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "src_small",
          "http://api.facebook.com/1.0/");
      }

      if (!link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "http://api.facebook.com/1.0/");
      }

      if (!caption_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "caption",
          "http://api.facebook.com/1.0/");
      }

      if (!created_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "created",
          "http://api.facebook.com/1.0/");
      }
    }

    photo* photo::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new photo (*this, f, c);
    }

    photo::
    ~photo ()
    {
    }

    // photo_tag
    //

    photo_tag::
    photo_tag (const pid_type& pid,
               const xcoord_type& xcoord,
               const ycoord_type& ycoord,
               const created_type& created)
    : ::xml_schema::type (),
      pid_ (pid, ::xml_schema::flags (), this),
      subject_ (::xml_schema::flags (), this),
      text_ (::xml_schema::flags (), this),
      xcoord_ (xcoord, ::xml_schema::flags (), this),
      ycoord_ (ycoord, ::xml_schema::flags (), this),
      created_ (created, ::xml_schema::flags (), this)
    {
    }

    photo_tag::
    photo_tag (const photo_tag& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      pid_ (x.pid_, f, this),
      subject_ (x.subject_, f, this),
      text_ (x.text_, f, this),
      xcoord_ (x.xcoord_, f, this),
      ycoord_ (x.ycoord_, f, this),
      created_ (x.created_, f, this)
    {
    }

    photo_tag::
    photo_tag (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      pid_ (f, this),
      subject_ (f, this),
      text_ (f, this),
      xcoord_ (f, this),
      ycoord_ (f, this),
      created_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void photo_tag::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pid
        //
        if (n.name () == "pid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pid_type > r (
            pid_traits::create (i, f, this));

          if (!pid_.present ())
          {
            this->pid (r);
            continue;
          }
        }

        // subject
        //
        if (n.name () == "subject" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< subject_type > r (
            subject_traits::create (i, f, this));

          if (!this->subject ())
          {
            this->subject (r);
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< text_type > r (
            text_traits::create (i, f, this));

          if (!this->text ())
          {
            this->text (r);
            continue;
          }
        }

        // xcoord
        //
        if (n.name () == "xcoord" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!xcoord_.present ())
          {
            this->xcoord (xcoord_traits::create (i, f, this));
            continue;
          }
        }

        // ycoord
        //
        if (n.name () == "ycoord" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!ycoord_.present ())
          {
            this->ycoord (ycoord_traits::create (i, f, this));
            continue;
          }
        }

        // created
        //
        if (n.name () == "created" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< created_type > r (
            created_traits::create (i, f, this));

          if (!created_.present ())
          {
            this->created (r);
            continue;
          }
        }

        break;
      }

      if (!pid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pid",
          "http://api.facebook.com/1.0/");
      }

      if (!xcoord_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "xcoord",
          "http://api.facebook.com/1.0/");
      }

      if (!ycoord_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ycoord",
          "http://api.facebook.com/1.0/");
      }

      if (!created_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "created",
          "http://api.facebook.com/1.0/");
      }
    }

    photo_tag* photo_tag::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new photo_tag (*this, f, c);
    }

    photo_tag::
    ~photo_tag ()
    {
    }

    // album
    //

    album::
    album (const aid_type& aid,
           const cover_pid_type& cover_pid,
           const owner_type& owner,
           const name_type& name,
           const created_type& created,
           const modified_type& modified,
           const description_type& description,
           const location_type& location,
           const link_type& link,
           const size_type& size)
    : ::xml_schema::type (),
      aid_ (aid, ::xml_schema::flags (), this),
      cover_pid_ (cover_pid, ::xml_schema::flags (), this),
      owner_ (owner, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      created_ (created, ::xml_schema::flags (), this),
      modified_ (modified, ::xml_schema::flags (), this),
      description_ (description, ::xml_schema::flags (), this),
      location_ (location, ::xml_schema::flags (), this),
      link_ (link, ::xml_schema::flags (), this),
      size_ (size, ::xml_schema::flags (), this)
    {
    }

    album::
    album (const album& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      aid_ (x.aid_, f, this),
      cover_pid_ (x.cover_pid_, f, this),
      owner_ (x.owner_, f, this),
      name_ (x.name_, f, this),
      created_ (x.created_, f, this),
      modified_ (x.modified_, f, this),
      description_ (x.description_, f, this),
      location_ (x.location_, f, this),
      link_ (x.link_, f, this),
      size_ (x.size_, f, this)
    {
    }

    album::
    album (const xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      aid_ (f, this),
      cover_pid_ (f, this),
      owner_ (f, this),
      name_ (f, this),
      created_ (f, this),
      modified_ (f, this),
      description_ (f, this),
      location_ (f, this),
      link_ (f, this),
      size_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void album::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // aid
        //
        if (n.name () == "aid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< aid_type > r (
            aid_traits::create (i, f, this));

          if (!aid_.present ())
          {
            this->aid (r);
            continue;
          }
        }

        // cover_pid
        //
        if (n.name () == "cover_pid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< cover_pid_type > r (
            cover_pid_traits::create (i, f, this));

          if (!cover_pid_.present ())
          {
            this->cover_pid (r);
            continue;
          }
        }

        // owner
        //
        if (n.name () == "owner" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< owner_type > r (
            owner_traits::create (i, f, this));

          if (!owner_.present ())
          {
            this->owner (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // created
        //
        if (n.name () == "created" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< created_type > r (
            created_traits::create (i, f, this));

          if (!created_.present ())
          {
            this->created (r);
            continue;
          }
        }

        // modified
        //
        if (n.name () == "modified" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< modified_type > r (
            modified_traits::create (i, f, this));

          if (!modified_.present ())
          {
            this->modified (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // location
        //
        if (n.name () == "location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< location_type > r (
            location_traits::create (i, f, this));

          if (!location_.present ())
          {
            this->location (r);
            continue;
          }
        }

        // link
        //
        if (n.name () == "link" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< link_type > r (
            link_traits::create (i, f, this));

          if (!link_.present ())
          {
            this->link (r);
            continue;
          }
        }

        // size
        //
        if (n.name () == "size" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!size_.present ())
          {
            this->size (size_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!aid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "aid",
          "http://api.facebook.com/1.0/");
      }

      if (!cover_pid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "cover_pid",
          "http://api.facebook.com/1.0/");
      }

      if (!owner_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "owner",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!created_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "created",
          "http://api.facebook.com/1.0/");
      }

      if (!modified_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "modified",
          "http://api.facebook.com/1.0/");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "http://api.facebook.com/1.0/");
      }

      if (!link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "http://api.facebook.com/1.0/");
      }

      if (!size_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "size",
          "http://api.facebook.com/1.0/");
      }
    }

    album* album::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new album (*this, f, c);
    }

    album::
    ~album ()
    {
    }

    // affiliation
    //

    affiliation::
    affiliation (const nid_type& nid,
                 const name_type& name,
                 const type_type& type,
                 const status_type& status,
                 const year_type& year)
    : ::xml_schema::type (),
      nid_ (nid, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      type_ (type, ::xml_schema::flags (), this),
      status_ (status, ::xml_schema::flags (), this),
      year_ (year, ::xml_schema::flags (), this)
    {
    }

    affiliation::
    affiliation (const affiliation& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      nid_ (x.nid_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      status_ (x.status_, f, this),
      year_ (x.year_, f, this)
    {
    }

    affiliation::
    affiliation (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      nid_ (f, this),
      name_ (f, this),
      type_ (f, this),
      status_ (f, this),
      year_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void affiliation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // nid
        //
        if (n.name () == "nid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< nid_type > r (
            nid_traits::create (i, f, this));

          if (!nid_.present ())
          {
            this->nid (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // type
        //
        if (n.name () == "type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          if (!type_.present ())
          {
            this->type (r);
            continue;
          }
        }

        // status
        //
        if (n.name () == "status" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< status_type > r (
            status_traits::create (i, f, this));

          if (!status_.present ())
          {
            this->status (r);
            continue;
          }
        }

        // year
        //
        if (n.name () == "year" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< year_type > r (
            year_traits::create (i, f, this));

          if (!year_.present ())
          {
            this->year (r);
            continue;
          }
        }

        break;
      }

      if (!nid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "nid",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "http://api.facebook.com/1.0/");
      }

      if (!status_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "status",
          "http://api.facebook.com/1.0/");
      }

      if (!year_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "year",
          "http://api.facebook.com/1.0/");
      }
    }

    affiliation* affiliation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new affiliation (*this, f, c);
    }

    affiliation::
    ~affiliation ()
    {
    }

    // hs_info
    //

    hs_info::
    hs_info ()
    : ::xml_schema::type (),
      hs1_name_ (::xml_schema::flags (), this),
      hs2_name_ (::xml_schema::flags (), this),
      grad_year_ (::xml_schema::flags (), this),
      hs1_id_ (::xml_schema::flags (), this),
      hs2_id_ (::xml_schema::flags (), this)
    {
    }

    hs_info::
    hs_info (const hs_info& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      hs1_name_ (x.hs1_name_, f, this),
      hs2_name_ (x.hs2_name_, f, this),
      grad_year_ (x.grad_year_, f, this),
      hs1_id_ (x.hs1_id_, f, this),
      hs2_id_ (x.hs2_id_, f, this)
    {
    }

    hs_info::
    hs_info (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      hs1_name_ (f, this),
      hs2_name_ (f, this),
      grad_year_ (f, this),
      hs1_id_ (f, this),
      hs2_id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void hs_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // hs1_name
        //
        if (n.name () == "hs1_name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hs1_name_type > r (
            hs1_name_traits::create (i, f, this));

          if (!this->hs1_name ())
          {
            this->hs1_name (r);
            continue;
          }
        }

        // hs2_name
        //
        if (n.name () == "hs2_name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hs2_name_type > r (
            hs2_name_traits::create (i, f, this));

          if (!this->hs2_name ())
          {
            this->hs2_name (r);
            continue;
          }
        }

        // grad_year
        //
        if (n.name () == "grad_year" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< grad_year_type > r (
            grad_year_traits::create (i, f, this));

          if (!this->grad_year ())
          {
            this->grad_year (r);
            continue;
          }
        }

        // hs1_id
        //
        if (n.name () == "hs1_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hs1_id_type > r (
            hs1_id_traits::create (i, f, this));

          if (!this->hs1_id ())
          {
            this->hs1_id (r);
            continue;
          }
        }

        // hs2_id
        //
        if (n.name () == "hs2_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hs2_id_type > r (
            hs2_id_traits::create (i, f, this));

          if (!this->hs2_id ())
          {
            this->hs2_id (r);
            continue;
          }
        }

        break;
      }
    }

    hs_info* hs_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new hs_info (*this, f, c);
    }

    hs_info::
    ~hs_info ()
    {
    }

    // education_info
    //

    education_info::
    education_info (const name_type& name,
                    const year_type& year,
                    const concentrations_type& concentrations,
                    const degree_type& degree)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this),
      year_ (year, ::xml_schema::flags (), this),
      concentrations_ (concentrations, ::xml_schema::flags (), this),
      degree_ (degree, ::xml_schema::flags (), this)
    {
    }

    education_info::
    education_info (const education_info& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      year_ (x.year_, f, this),
      concentrations_ (x.concentrations_, f, this),
      degree_ (x.degree_, f, this)
    {
    }

    education_info::
    education_info (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      year_ (f, this),
      concentrations_ (f, this),
      degree_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void education_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // year
        //
        if (n.name () == "year" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< year_type > r (
            year_traits::create (i, f, this));

          if (!year_.present ())
          {
            this->year (r);
            continue;
          }
        }

        // concentrations
        //
        if (n.name () == "concentrations" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< concentrations_type > r (
            concentrations_traits::create (i, f, this));

          if (!concentrations_.present ())
          {
            this->concentrations (r);
            continue;
          }
        }

        // degree
        //
        if (n.name () == "degree" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< degree_type > r (
            degree_traits::create (i, f, this));

          if (!degree_.present ())
          {
            this->degree (r);
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!year_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "year",
          "http://api.facebook.com/1.0/");
      }

      if (!concentrations_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "concentrations",
          "http://api.facebook.com/1.0/");
      }

      if (!degree_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "degree",
          "http://api.facebook.com/1.0/");
      }
    }

    education_info* education_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new education_info (*this, f, c);
    }

    education_info::
    ~education_info ()
    {
    }

    // work_info
    //

    work_info::
    work_info (const location_type& location,
               const company_name_type& company_name,
               const position_type& position,
               const description_type& description,
               const start_date_type& start_date,
               const end_date_type& end_date)
    : ::xml_schema::type (),
      location_ (location, ::xml_schema::flags (), this),
      company_name_ (company_name, ::xml_schema::flags (), this),
      position_ (position, ::xml_schema::flags (), this),
      description_ (description, ::xml_schema::flags (), this),
      start_date_ (start_date, ::xml_schema::flags (), this),
      end_date_ (end_date, ::xml_schema::flags (), this)
    {
    }

    work_info::
    work_info (const work_info& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      location_ (x.location_, f, this),
      company_name_ (x.company_name_, f, this),
      position_ (x.position_, f, this),
      description_ (x.description_, f, this),
      start_date_ (x.start_date_, f, this),
      end_date_ (x.end_date_, f, this)
    {
    }

    work_info::
    work_info (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      location_ (f, this),
      company_name_ (f, this),
      position_ (f, this),
      description_ (f, this),
      start_date_ (f, this),
      end_date_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void work_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // location
        //
        if (n.name () == "location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< location_type > r (
            location_traits::create (i, f, this));

          if (!location_.present ())
          {
            this->location (r);
            continue;
          }
        }

        // company_name
        //
        if (n.name () == "company_name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< company_name_type > r (
            company_name_traits::create (i, f, this));

          if (!company_name_.present ())
          {
            this->company_name (r);
            continue;
          }
        }

        // position
        //
        if (n.name () == "position" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< position_type > r (
            position_traits::create (i, f, this));

          if (!position_.present ())
          {
            this->position (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // start_date
        //
        if (n.name () == "start_date" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< start_date_type > r (
            start_date_traits::create (i, f, this));

          if (!start_date_.present ())
          {
            this->start_date (r);
            continue;
          }
        }

        // end_date
        //
        if (n.name () == "end_date" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< end_date_type > r (
            end_date_traits::create (i, f, this));

          if (!end_date_.present ())
          {
            this->end_date (r);
            continue;
          }
        }

        break;
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "http://api.facebook.com/1.0/");
      }

      if (!company_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "company_name",
          "http://api.facebook.com/1.0/");
      }

      if (!position_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "position",
          "http://api.facebook.com/1.0/");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!start_date_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "start_date",
          "http://api.facebook.com/1.0/");
      }

      if (!end_date_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "end_date",
          "http://api.facebook.com/1.0/");
      }
    }

    work_info* work_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new work_info (*this, f, c);
    }

    work_info::
    ~work_info ()
    {
    }

    // user
    //

    user::
    user ()
    : ::xml_schema::type (),
      about_me_ (::xml_schema::flags (), this),
      activities_ (::xml_schema::flags (), this),
      affiliations_ (::xml_schema::flags (), this),
      birthday_ (::xml_schema::flags (), this),
      books_ (::xml_schema::flags (), this),
      current_location_ (::xml_schema::flags (), this),
      education_history_ (::xml_schema::flags (), this),
      first_name_ (::xml_schema::flags (), this),
      hometown_location_ (::xml_schema::flags (), this),
      hs_info_ (::xml_schema::flags (), this),
      interests_ (::xml_schema::flags (), this),
      is_app_user_ (::xml_schema::flags (), this),
      last_name_ (::xml_schema::flags (), this),
      meeting_for_ (::xml_schema::flags (), this),
      meeting_sex_ (::xml_schema::flags (), this),
      movies_ (::xml_schema::flags (), this),
      music_ (::xml_schema::flags (), this),
      name_ (::xml_schema::flags (), this),
      notes_count_ (::xml_schema::flags (), this),
      pic_ (::xml_schema::flags (), this),
      pic_big_ (::xml_schema::flags (), this),
      pic_small_ (::xml_schema::flags (), this),
      political_ (::xml_schema::flags (), this),
      profile_update_time_ (::xml_schema::flags (), this),
      quotes_ (::xml_schema::flags (), this),
      relationship_status_ (::xml_schema::flags (), this),
      religion_ (::xml_schema::flags (), this),
      sex_ (::xml_schema::flags (), this),
      significant_other_id_ (::xml_schema::flags (), this),
      status_ (::xml_schema::flags (), this),
      timezone_ (::xml_schema::flags (), this),
      tv_ (::xml_schema::flags (), this),
      uid_ (::xml_schema::flags (), this),
      wall_count_ (::xml_schema::flags (), this),
      work_history_ (::xml_schema::flags (), this),
      pic_square_ (::xml_schema::flags (), this),
      has_added_app_ (::xml_schema::flags (), this)
    {
    }

    user::
    user (const user& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      about_me_ (x.about_me_, f, this),
      activities_ (x.activities_, f, this),
      affiliations_ (x.affiliations_, f, this),
      birthday_ (x.birthday_, f, this),
      books_ (x.books_, f, this),
      current_location_ (x.current_location_, f, this),
      education_history_ (x.education_history_, f, this),
      first_name_ (x.first_name_, f, this),
      hometown_location_ (x.hometown_location_, f, this),
      hs_info_ (x.hs_info_, f, this),
      interests_ (x.interests_, f, this),
      is_app_user_ (x.is_app_user_, f, this),
      last_name_ (x.last_name_, f, this),
      meeting_for_ (x.meeting_for_, f, this),
      meeting_sex_ (x.meeting_sex_, f, this),
      movies_ (x.movies_, f, this),
      music_ (x.music_, f, this),
      name_ (x.name_, f, this),
      notes_count_ (x.notes_count_, f, this),
      pic_ (x.pic_, f, this),
      pic_big_ (x.pic_big_, f, this),
      pic_small_ (x.pic_small_, f, this),
      political_ (x.political_, f, this),
      profile_update_time_ (x.profile_update_time_, f, this),
      quotes_ (x.quotes_, f, this),
      relationship_status_ (x.relationship_status_, f, this),
      religion_ (x.religion_, f, this),
      sex_ (x.sex_, f, this),
      significant_other_id_ (x.significant_other_id_, f, this),
      status_ (x.status_, f, this),
      timezone_ (x.timezone_, f, this),
      tv_ (x.tv_, f, this),
      uid_ (x.uid_, f, this),
      wall_count_ (x.wall_count_, f, this),
      work_history_ (x.work_history_, f, this),
      pic_square_ (x.pic_square_, f, this),
      has_added_app_ (x.has_added_app_, f, this)
    {
    }

    user::
    user (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      about_me_ (f, this),
      activities_ (f, this),
      affiliations_ (f, this),
      birthday_ (f, this),
      books_ (f, this),
      current_location_ (f, this),
      education_history_ (f, this),
      first_name_ (f, this),
      hometown_location_ (f, this),
      hs_info_ (f, this),
      interests_ (f, this),
      is_app_user_ (f, this),
      last_name_ (f, this),
      meeting_for_ (f, this),
      meeting_sex_ (f, this),
      movies_ (f, this),
      music_ (f, this),
      name_ (f, this),
      notes_count_ (f, this),
      pic_ (f, this),
      pic_big_ (f, this),
      pic_small_ (f, this),
      political_ (f, this),
      profile_update_time_ (f, this),
      quotes_ (f, this),
      relationship_status_ (f, this),
      religion_ (f, this),
      sex_ (f, this),
      significant_other_id_ (f, this),
      status_ (f, this),
      timezone_ (f, this),
      tv_ (f, this),
      uid_ (f, this),
      wall_count_ (f, this),
      work_history_ (f, this),
      pic_square_ (f, this),
      has_added_app_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void user::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // about_me
        //
        if (n.name () == "about_me" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< about_me_type > r (
            about_me_traits::create (i, f, this));

          if (!this->about_me ())
          {
            this->about_me (r);
            continue;
          }
        }

        // activities
        //
        if (n.name () == "activities" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< activities_type > r (
            activities_traits::create (i, f, this));

          if (!this->activities ())
          {
            this->activities (r);
            continue;
          }
        }

        // affiliations
        //
        if (n.name () == "affiliations" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< affiliations_type > r (
            affiliations_traits::create (i, f, this));

          if (!this->affiliations ())
          {
            this->affiliations (r);
            continue;
          }
        }

        // birthday
        //
        if (n.name () == "birthday" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< birthday_type > r (
            birthday_traits::create (i, f, this));

          if (!this->birthday ())
          {
            this->birthday (r);
            continue;
          }
        }

        // books
        //
        if (n.name () == "books" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< books_type > r (
            books_traits::create (i, f, this));

          if (!this->books ())
          {
            this->books (r);
            continue;
          }
        }

        // current_location
        //
        if (n.name () == "current_location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< current_location_type > r (
            current_location_traits::create (i, f, this));

          if (!this->current_location ())
          {
            this->current_location (r);
            continue;
          }
        }

        // education_history
        //
        if (n.name () == "education_history" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< education_history_type > r (
            education_history_traits::create (i, f, this));

          if (!this->education_history ())
          {
            this->education_history (r);
            continue;
          }
        }

        // first_name
        //
        if (n.name () == "first_name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< first_name_type > r (
            first_name_traits::create (i, f, this));

          if (!this->first_name ())
          {
            this->first_name (r);
            continue;
          }
        }

        // hometown_location
        //
        if (n.name () == "hometown_location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hometown_location_type > r (
            hometown_location_traits::create (i, f, this));

          if (!this->hometown_location ())
          {
            this->hometown_location (r);
            continue;
          }
        }

        // hs_info
        //
        if (n.name () == "hs_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hs_info_type > r (
            hs_info_traits::create (i, f, this));

          if (!this->hs_info ())
          {
            this->hs_info (r);
            continue;
          }
        }

        // interests
        //
        if (n.name () == "interests" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< interests_type > r (
            interests_traits::create (i, f, this));

          if (!this->interests ())
          {
            this->interests (r);
            continue;
          }
        }

        // is_app_user
        //
        if (n.name () == "is_app_user" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->is_app_user ())
          {
            this->is_app_user (is_app_user_traits::create (i, f, this));
            continue;
          }
        }

        // last_name
        //
        if (n.name () == "last_name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< last_name_type > r (
            last_name_traits::create (i, f, this));

          if (!this->last_name ())
          {
            this->last_name (r);
            continue;
          }
        }

        // meeting_for
        //
        if (n.name () == "meeting_for" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< meeting_for_type > r (
            meeting_for_traits::create (i, f, this));

          if (!this->meeting_for ())
          {
            this->meeting_for (r);
            continue;
          }
        }

        // meeting_sex
        //
        if (n.name () == "meeting_sex" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< meeting_sex_type > r (
            meeting_sex_traits::create (i, f, this));

          if (!this->meeting_sex ())
          {
            this->meeting_sex (r);
            continue;
          }
        }

        // movies
        //
        if (n.name () == "movies" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< movies_type > r (
            movies_traits::create (i, f, this));

          if (!this->movies ())
          {
            this->movies (r);
            continue;
          }
        }

        // music
        //
        if (n.name () == "music" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< music_type > r (
            music_traits::create (i, f, this));

          if (!this->music ())
          {
            this->music (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!this->name ())
          {
            this->name (r);
            continue;
          }
        }

        // notes_count
        //
        if (n.name () == "notes_count" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->notes_count ())
          {
            this->notes_count (notes_count_traits::create (i, f, this));
            continue;
          }
        }

        // pic
        //
        if (n.name () == "pic" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_type > r (
            pic_traits::create (i, f, this));

          if (!this->pic ())
          {
            this->pic (r);
            continue;
          }
        }

        // pic_big
        //
        if (n.name () == "pic_big" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_big_type > r (
            pic_big_traits::create (i, f, this));

          if (!this->pic_big ())
          {
            this->pic_big (r);
            continue;
          }
        }

        // pic_small
        //
        if (n.name () == "pic_small" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_small_type > r (
            pic_small_traits::create (i, f, this));

          if (!this->pic_small ())
          {
            this->pic_small (r);
            continue;
          }
        }

        // political
        //
        if (n.name () == "political" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< political_type > r (
            political_traits::create (i, f, this));

          if (!this->political ())
          {
            this->political (r);
            continue;
          }
        }

        // profile_update_time
        //
        if (n.name () == "profile_update_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< profile_update_time_type > r (
            profile_update_time_traits::create (i, f, this));

          if (!this->profile_update_time ())
          {
            this->profile_update_time (r);
            continue;
          }
        }

        // quotes
        //
        if (n.name () == "quotes" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< quotes_type > r (
            quotes_traits::create (i, f, this));

          if (!this->quotes ())
          {
            this->quotes (r);
            continue;
          }
        }

        // relationship_status
        //
        if (n.name () == "relationship_status" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< relationship_status_type > r (
            relationship_status_traits::create (i, f, this));

          if (!this->relationship_status ())
          {
            this->relationship_status (r);
            continue;
          }
        }

        // religion
        //
        if (n.name () == "religion" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< religion_type > r (
            religion_traits::create (i, f, this));

          if (!this->religion ())
          {
            this->religion (r);
            continue;
          }
        }

        // sex
        //
        if (n.name () == "sex" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sex_type > r (
            sex_traits::create (i, f, this));

          if (!this->sex ())
          {
            this->sex (r);
            continue;
          }
        }

        // significant_other_id
        //
        if (n.name () == "significant_other_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< significant_other_id_type > r (
            significant_other_id_traits::create (i, f, this));

          if (!this->significant_other_id ())
          {
            this->significant_other_id (r);
            continue;
          }
        }

        // status
        //
        if (n.name () == "status" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< status_type > r (
            status_traits::create (i, f, this));

          if (!this->status ())
          {
            this->status (r);
            continue;
          }
        }

        // timezone
        //
        if (n.name () == "timezone" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->timezone ())
          {
            this->timezone (timezone_traits::create (i, f, this));
            continue;
          }
        }

        // tv
        //
        if (n.name () == "tv" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tv_type > r (
            tv_traits::create (i, f, this));

          if (!this->tv ())
          {
            this->tv (r);
            continue;
          }
        }

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          if (!this->uid ())
          {
            this->uid (r);
            continue;
          }
        }

        // wall_count
        //
        if (n.name () == "wall_count" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->wall_count ())
          {
            this->wall_count (wall_count_traits::create (i, f, this));
            continue;
          }
        }

        // work_history
        //
        if (n.name () == "work_history" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< work_history_type > r (
            work_history_traits::create (i, f, this));

          if (!this->work_history ())
          {
            this->work_history (r);
            continue;
          }
        }

        // pic_square
        //
        if (n.name () == "pic_square" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_square_type > r (
            pic_square_traits::create (i, f, this));

          if (!this->pic_square ())
          {
            this->pic_square (r);
            continue;
          }
        }

        // has_added_app
        //
        if (n.name () == "has_added_app" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->has_added_app ())
          {
            this->has_added_app (has_added_app_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    user* user::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new user (*this, f, c);
    }

    user::
    ~user ()
    {
    }

    // friend_info
    //

    friend_info::
    friend_info ()
    : ::xml_schema::type (),
      uid1_ (::xml_schema::flags (), this),
      uid2_ (::xml_schema::flags (), this),
      are_friends_ (::xml_schema::flags (), this)
    {
    }

    friend_info::
    friend_info (const friend_info& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid1_ (x.uid1_, f, this),
      uid2_ (x.uid2_, f, this),
      are_friends_ (x.are_friends_, f, this)
    {
    }

    friend_info::
    friend_info (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid1_ (f, this),
      uid2_ (f, this),
      are_friends_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friend_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid1
        //
        if (n.name () == "uid1" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid1_type > r (
            uid1_traits::create (i, f, this));

          if (!this->uid1 ())
          {
            this->uid1 (r);
            continue;
          }
        }

        // uid2
        //
        if (n.name () == "uid2" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid2_type > r (
            uid2_traits::create (i, f, this));

          if (!this->uid2 ())
          {
            this->uid2 (r);
            continue;
          }
        }

        // are_friends
        //
        if (n.name () == "are_friends" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->are_friends ())
          {
            this->are_friends (are_friends_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    friend_info* friend_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friend_info (*this, f, c);
    }

    friend_info::
    ~friend_info ()
    {
    }

    // friendlist
    //

    friendlist::
    friendlist (const flid_type& flid,
                const name_type& name)
    : ::xml_schema::type (),
      flid_ (flid, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      owner_ (::xml_schema::flags (), this)
    {
    }

    friendlist::
    friendlist (const friendlist& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      flid_ (x.flid_, f, this),
      name_ (x.name_, f, this),
      owner_ (x.owner_, f, this)
    {
    }

    friendlist::
    friendlist (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      flid_ (f, this),
      name_ (f, this),
      owner_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friendlist::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // flid
        //
        if (n.name () == "flid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< flid_type > r (
            flid_traits::create (i, f, this));

          if (!flid_.present ())
          {
            this->flid (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // owner
        //
        if (n.name () == "owner" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< owner_type > r (
            owner_traits::create (i, f, this));

          if (!this->owner ())
          {
            this->owner (r);
            continue;
          }
        }

        break;
      }

      if (!flid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "flid",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }
    }

    friendlist* friendlist::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friendlist (*this, f, c);
    }

    friendlist::
    ~friendlist ()
    {
    }

    // object_type_info
    //

    object_type_info::
    object_type_info (const name_type& name,
                      const object_class_type& object_class)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this),
      object_class_ (object_class, ::xml_schema::flags (), this)
    {
    }

    object_type_info::
    object_type_info (const object_type_info& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      object_class_ (x.object_class_, f, this)
    {
    }

    object_type_info::
    object_type_info (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      object_class_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void object_type_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // object_class
        //
        if (n.name () == "object_class" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!object_class_.present ())
          {
            this->object_class (object_class_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!object_class_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "object_class",
          "http://api.facebook.com/1.0/");
      }
    }

    object_type_info* object_type_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new object_type_info (*this, f, c);
    }

    object_type_info::
    ~object_type_info ()
    {
    }

    // object_property_info
    //

    object_property_info::
    object_property_info (const name_type& name,
                          const data_type_type& data_type,
                          const index_type_type& index_type)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this),
      data_type_ (data_type, ::xml_schema::flags (), this),
      index_type_ (index_type, ::xml_schema::flags (), this)
    {
    }

    object_property_info::
    object_property_info (const object_property_info& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      data_type_ (x.data_type_, f, this),
      index_type_ (x.index_type_, f, this)
    {
    }

    object_property_info::
    object_property_info (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      data_type_ (f, this),
      index_type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void object_property_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // data_type
        //
        if (n.name () == "data_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!data_type_.present ())
          {
            this->data_type (data_type_traits::create (i, f, this));
            continue;
          }
        }

        // index_type
        //
        if (n.name () == "index_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!index_type_.present ())
          {
            this->index_type (index_type_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!data_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "data_type",
          "http://api.facebook.com/1.0/");
      }

      if (!index_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "index_type",
          "http://api.facebook.com/1.0/");
      }
    }

    object_property_info* object_property_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new object_property_info (*this, f, c);
    }

    object_property_info::
    ~object_property_info ()
    {
    }

    // assoc_object_type
    //

    assoc_object_type::
    assoc_object_type (const alias_type& alias,
                       const object_type_type& object_type,
                       const unique_type& unique)
    : ::xml_schema::type (),
      alias_ (alias, ::xml_schema::flags (), this),
      object_type_ (object_type, ::xml_schema::flags (), this),
      unique_ (unique, ::xml_schema::flags (), this)
    {
    }

    assoc_object_type::
    assoc_object_type (const assoc_object_type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      alias_ (x.alias_, f, this),
      object_type_ (x.object_type_, f, this),
      unique_ (x.unique_, f, this)
    {
    }

    assoc_object_type::
    assoc_object_type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      alias_ (f, this),
      object_type_ (f, this),
      unique_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void assoc_object_type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // alias
        //
        if (n.name () == "alias" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< alias_type > r (
            alias_traits::create (i, f, this));

          if (!alias_.present ())
          {
            this->alias (r);
            continue;
          }
        }

        // object_type
        //
        if (n.name () == "object_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_type_type > r (
            object_type_traits::create (i, f, this));

          if (!object_type_.present ())
          {
            this->object_type (r);
            continue;
          }
        }

        // unique
        //
        if (n.name () == "unique" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!unique_.present ())
          {
            this->unique (unique_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!alias_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "alias",
          "http://api.facebook.com/1.0/");
      }

      if (!object_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "object_type",
          "http://api.facebook.com/1.0/");
      }

      if (!unique_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "unique",
          "http://api.facebook.com/1.0/");
      }
    }

    assoc_object_type* assoc_object_type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new assoc_object_type (*this, f, c);
    }

    assoc_object_type::
    ~assoc_object_type ()
    {
    }

    // object_assoc_info
    //

    object_assoc_info::
    object_assoc_info (const name_type& name,
                       const assoc_type_type& assoc_type,
                       const assoc_info1_type& assoc_info1,
                       const assoc_info2_type& assoc_info2)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this),
      assoc_type_ (assoc_type, ::xml_schema::flags (), this),
      assoc_info1_ (assoc_info1, ::xml_schema::flags (), this),
      assoc_info2_ (assoc_info2, ::xml_schema::flags (), this)
    {
    }

    object_assoc_info::
    object_assoc_info (const object_assoc_info& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      assoc_type_ (x.assoc_type_, f, this),
      assoc_info1_ (x.assoc_info1_, f, this),
      assoc_info2_ (x.assoc_info2_, f, this)
    {
    }

    object_assoc_info::
    object_assoc_info (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      assoc_type_ (f, this),
      assoc_info1_ (f, this),
      assoc_info2_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void object_assoc_info::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // assoc_type
        //
        if (n.name () == "assoc_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!assoc_type_.present ())
          {
            this->assoc_type (assoc_type_traits::create (i, f, this));
            continue;
          }
        }

        // assoc_info1
        //
        if (n.name () == "assoc_info1" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< assoc_info1_type > r (
            assoc_info1_traits::create (i, f, this));

          if (!assoc_info1_.present ())
          {
            this->assoc_info1 (r);
            continue;
          }
        }

        // assoc_info2
        //
        if (n.name () == "assoc_info2" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< assoc_info2_type > r (
            assoc_info2_traits::create (i, f, this));

          if (!assoc_info2_.present ())
          {
            this->assoc_info2 (r);
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!assoc_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "assoc_type",
          "http://api.facebook.com/1.0/");
      }

      if (!assoc_info1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "assoc_info1",
          "http://api.facebook.com/1.0/");
      }

      if (!assoc_info2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "assoc_info2",
          "http://api.facebook.com/1.0/");
      }
    }

    object_assoc_info* object_assoc_info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new object_assoc_info (*this, f, c);
    }

    object_assoc_info::
    ~object_assoc_info ()
    {
    }

    // object_association
    //

    object_association::
    object_association (const name_type& name,
                        const id1_type& id1,
                        const id2_type& id2,
                        const data_type& data,
                        const time_type& time)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this),
      id1_ (id1, ::xml_schema::flags (), this),
      id2_ (id2, ::xml_schema::flags (), this),
      data_ (data, ::xml_schema::flags (), this),
      time_ (time, ::xml_schema::flags (), this)
    {
    }

    object_association::
    object_association (const object_association& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      id1_ (x.id1_, f, this),
      id2_ (x.id2_, f, this),
      data_ (x.data_, f, this),
      time_ (x.time_, f, this)
    {
    }

    object_association::
    object_association (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      id1_ (f, this),
      id2_ (f, this),
      data_ (f, this),
      time_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void object_association::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // id1
        //
        if (n.name () == "id1" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!id1_.present ())
          {
            this->id1 (id1_traits::create (i, f, this));
            continue;
          }
        }

        // id2
        //
        if (n.name () == "id2" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!id2_.present ())
          {
            this->id2 (id2_traits::create (i, f, this));
            continue;
          }
        }

        // data
        //
        if (n.name () == "data" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< data_type > r (
            data_traits::create (i, f, this));

          if (!data_.present ())
          {
            this->data (r);
            continue;
          }
        }

        // time
        //
        if (n.name () == "time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< time_type > r (
            time_traits::create (i, f, this));

          if (!time_.present ())
          {
            this->time (r);
            continue;
          }
        }

        break;
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!id1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id1",
          "http://api.facebook.com/1.0/");
      }

      if (!id2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id2",
          "http://api.facebook.com/1.0/");
      }

      if (!data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "data",
          "http://api.facebook.com/1.0/");
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "time",
          "http://api.facebook.com/1.0/");
      }
    }

    object_association* object_association::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new object_association (*this, f, c);
    }

    object_association::
    ~object_association ()
    {
    }

    // listing
    //

    listing::
    listing (const listing_id_type& listing_id,
             const url_type& url,
             const title_type& title,
             const description_type& description,
             const poster_type& poster,
             const update_time_type& update_time,
             const category_type& category,
             const subcategory_type& subcategory)
    : ::xml_schema::type (),
      listing_id_ (listing_id, ::xml_schema::flags (), this),
      url_ (url, ::xml_schema::flags (), this),
      title_ (title, ::xml_schema::flags (), this),
      description_ (description, ::xml_schema::flags (), this),
      price_ (::xml_schema::flags (), this),
      poster_ (poster, ::xml_schema::flags (), this),
      update_time_ (update_time, ::xml_schema::flags (), this),
      category_ (category, ::xml_schema::flags (), this),
      subcategory_ (subcategory, ::xml_schema::flags (), this),
      image_urls_ (::xml_schema::flags (), this),
      condition_ (::xml_schema::flags (), this),
      isbn_ (::xml_schema::flags (), this),
      num_beds_ (::xml_schema::flags (), this),
      num_maths_ (::xml_schema::flags (), this),
      dogs_ (::xml_schema::flags (), this),
      cats_ (::xml_schema::flags (), this),
      smoking_ (::xml_schema::flags (), this),
      square_footage_ (::xml_schema::flags (), this),
      street_ (::xml_schema::flags (), this),
      crossstreet_ (::xml_schema::flags (), this),
      postal_ (::xml_schema::flags (), this),
      rent_ (::xml_schema::flags (), this),
      pay_ (::xml_schema::flags (), this),
      full_ (::xml_schema::flags (), this),
      intern_ (::xml_schema::flags (), this),
      summer_ (::xml_schema::flags (), this),
      nonprofit_ (::xml_schema::flags (), this),
      pay_type_ (::xml_schema::flags (), this)
    {
    }

    listing::
    listing (const listing& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      listing_id_ (x.listing_id_, f, this),
      url_ (x.url_, f, this),
      title_ (x.title_, f, this),
      description_ (x.description_, f, this),
      price_ (x.price_, f, this),
      poster_ (x.poster_, f, this),
      update_time_ (x.update_time_, f, this),
      category_ (x.category_, f, this),
      subcategory_ (x.subcategory_, f, this),
      image_urls_ (x.image_urls_, f, this),
      condition_ (x.condition_, f, this),
      isbn_ (x.isbn_, f, this),
      num_beds_ (x.num_beds_, f, this),
      num_maths_ (x.num_maths_, f, this),
      dogs_ (x.dogs_, f, this),
      cats_ (x.cats_, f, this),
      smoking_ (x.smoking_, f, this),
      square_footage_ (x.square_footage_, f, this),
      street_ (x.street_, f, this),
      crossstreet_ (x.crossstreet_, f, this),
      postal_ (x.postal_, f, this),
      rent_ (x.rent_, f, this),
      pay_ (x.pay_, f, this),
      full_ (x.full_, f, this),
      intern_ (x.intern_, f, this),
      summer_ (x.summer_, f, this),
      nonprofit_ (x.nonprofit_, f, this),
      pay_type_ (x.pay_type_, f, this)
    {
    }

    listing::
    listing (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      listing_id_ (f, this),
      url_ (f, this),
      title_ (f, this),
      description_ (f, this),
      price_ (f, this),
      poster_ (f, this),
      update_time_ (f, this),
      category_ (f, this),
      subcategory_ (f, this),
      image_urls_ (f, this),
      condition_ (f, this),
      isbn_ (f, this),
      num_beds_ (f, this),
      num_maths_ (f, this),
      dogs_ (f, this),
      cats_ (f, this),
      smoking_ (f, this),
      square_footage_ (f, this),
      street_ (f, this),
      crossstreet_ (f, this),
      postal_ (f, this),
      rent_ (f, this),
      pay_ (f, this),
      full_ (f, this),
      intern_ (f, this),
      summer_ (f, this),
      nonprofit_ (f, this),
      pay_type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void listing::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // listing_id
        //
        if (n.name () == "listing_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< listing_id_type > r (
            listing_id_traits::create (i, f, this));

          if (!listing_id_.present ())
          {
            this->listing_id (r);
            continue;
          }
        }

        // url
        //
        if (n.name () == "url" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< url_type > r (
            url_traits::create (i, f, this));

          if (!url_.present ())
          {
            this->url (r);
            continue;
          }
        }

        // title
        //
        if (n.name () == "title" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< title_type > r (
            title_traits::create (i, f, this));

          if (!title_.present ())
          {
            this->title (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // price
        //
        if (n.name () == "price" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->price ())
          {
            this->price (price_traits::create (i, f, this));
            continue;
          }
        }

        // poster
        //
        if (n.name () == "poster" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< poster_type > r (
            poster_traits::create (i, f, this));

          if (!poster_.present ())
          {
            this->poster (r);
            continue;
          }
        }

        // update_time
        //
        if (n.name () == "update_time" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< update_time_type > r (
            update_time_traits::create (i, f, this));

          if (!update_time_.present ())
          {
            this->update_time (r);
            continue;
          }
        }

        // category
        //
        if (n.name () == "category" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< category_type > r (
            category_traits::create (i, f, this));

          if (!category_.present ())
          {
            this->category (r);
            continue;
          }
        }

        // subcategory
        //
        if (n.name () == "subcategory" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< subcategory_type > r (
            subcategory_traits::create (i, f, this));

          if (!subcategory_.present ())
          {
            this->subcategory (r);
            continue;
          }
        }

        // image_urls
        //
        if (n.name () == "image_urls" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< image_urls_type > r (
            image_urls_traits::create (i, f, this));

          if (!this->image_urls ())
          {
            this->image_urls (r);
            continue;
          }
        }

        // condition
        //
        if (n.name () == "condition" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->condition ())
          {
            this->condition (condition_traits::create (i, f, this));
            continue;
          }
        }

        // isbn
        //
        if (n.name () == "isbn" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< isbn_type > r (
            isbn_traits::create (i, f, this));

          if (!this->isbn ())
          {
            this->isbn (r);
            continue;
          }
        }

        // num_beds
        //
        if (n.name () == "num_beds" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< num_beds_type > r (
            num_beds_traits::create (i, f, this));

          if (!this->num_beds ())
          {
            this->num_beds (r);
            continue;
          }
        }

        // num_maths
        //
        if (n.name () == "num_maths" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< num_maths_type > r (
            num_maths_traits::create (i, f, this));

          if (!this->num_maths ())
          {
            this->num_maths (r);
            continue;
          }
        }

        // dogs
        //
        if (n.name () == "dogs" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< dogs_type > r (
            dogs_traits::create (i, f, this));

          if (!this->dogs ())
          {
            this->dogs (r);
            continue;
          }
        }

        // cats
        //
        if (n.name () == "cats" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< cats_type > r (
            cats_traits::create (i, f, this));

          if (!this->cats ())
          {
            this->cats (r);
            continue;
          }
        }

        // smoking
        //
        if (n.name () == "smoking" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< smoking_type > r (
            smoking_traits::create (i, f, this));

          if (!this->smoking ())
          {
            this->smoking (r);
            continue;
          }
        }

        // square_footage
        //
        if (n.name () == "square_footage" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< square_footage_type > r (
            square_footage_traits::create (i, f, this));

          if (!this->square_footage ())
          {
            this->square_footage (r);
            continue;
          }
        }

        // street
        //
        if (n.name () == "street" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< street_type > r (
            street_traits::create (i, f, this));

          if (!this->street ())
          {
            this->street (r);
            continue;
          }
        }

        // crossstreet
        //
        if (n.name () == "crossstreet" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< crossstreet_type > r (
            crossstreet_traits::create (i, f, this));

          if (!this->crossstreet ())
          {
            this->crossstreet (r);
            continue;
          }
        }

        // postal
        //
        if (n.name () == "postal" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< postal_type > r (
            postal_traits::create (i, f, this));

          if (!this->postal ())
          {
            this->postal (r);
            continue;
          }
        }

        // rent
        //
        if (n.name () == "rent" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< rent_type > r (
            rent_traits::create (i, f, this));

          if (!this->rent ())
          {
            this->rent (r);
            continue;
          }
        }

        // pay
        //
        if (n.name () == "pay" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pay_type > r (
            pay_traits::create (i, f, this));

          if (!this->pay ())
          {
            this->pay (r);
            continue;
          }
        }

        // full
        //
        if (n.name () == "full" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< full_type > r (
            full_traits::create (i, f, this));

          if (!this->full ())
          {
            this->full (r);
            continue;
          }
        }

        // intern
        //
        if (n.name () == "intern" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< intern_type > r (
            intern_traits::create (i, f, this));

          if (!this->intern ())
          {
            this->intern (r);
            continue;
          }
        }

        // summer
        //
        if (n.name () == "summer" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< summer_type > r (
            summer_traits::create (i, f, this));

          if (!this->summer ())
          {
            this->summer (r);
            continue;
          }
        }

        // nonprofit
        //
        if (n.name () == "nonprofit" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< nonprofit_type > r (
            nonprofit_traits::create (i, f, this));

          if (!this->nonprofit ())
          {
            this->nonprofit (r);
            continue;
          }
        }

        // pay_type
        //
        if (n.name () == "pay_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pay_type_type > r (
            pay_type_traits::create (i, f, this));

          if (!this->pay_type1 ())
          {
            this->pay_type1 (r);
            continue;
          }
        }

        break;
      }

      if (!listing_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "listing_id",
          "http://api.facebook.com/1.0/");
      }

      if (!url_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "url",
          "http://api.facebook.com/1.0/");
      }

      if (!title_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "title",
          "http://api.facebook.com/1.0/");
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!poster_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "poster",
          "http://api.facebook.com/1.0/");
      }

      if (!update_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "update_time",
          "http://api.facebook.com/1.0/");
      }

      if (!category_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "category",
          "http://api.facebook.com/1.0/");
      }

      if (!subcategory_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "subcategory",
          "http://api.facebook.com/1.0/");
      }
    }

    listing* listing::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new listing (*this, f, c);
    }

    listing::
    ~listing ()
    {
    }

    // preference
    //

    preference::
    preference (const pref_id_type& pref_id,
                const value_type& value)
    : ::xml_schema::type (),
      pref_id_ (pref_id, ::xml_schema::flags (), this),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    preference::
    preference (const preference& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      pref_id_ (x.pref_id_, f, this),
      value_ (x.value_, f, this)
    {
    }

    preference::
    preference (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      pref_id_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void preference::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pref_id
        //
        if (n.name () == "pref_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!pref_id_.present ())
          {
            this->pref_id (pref_id_traits::create (i, f, this));
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          if (!value_.present ())
          {
            this->value (r);
            continue;
          }
        }

        break;
      }

      if (!pref_id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pref_id",
          "http://api.facebook.com/1.0/");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "http://api.facebook.com/1.0/");
      }
    }

    preference* preference::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new preference (*this, f, c);
    }

    preference::
    ~preference ()
    {
    }

    // page_hours
    //

    page_hours::
    page_hours (const mon_1_open_type& mon_1_open,
                const mon_1_close_type& mon_1_close,
                const tue_1_open_type& tue_1_open,
                const tue_1_close_type& tue_1_close,
                const wed_1_open_type& wed_1_open,
                const thu_1_open_type& thu_1_open,
                const thu_1_close_type& thu_1_close,
                const fri_1_open_type& fri_1_open,
                const fri_1_close_type& fri_1_close,
                const sat_1_open_type& sat_1_open,
                const sat_1_close_type& sat_1_close,
                const sun_1_open_type& sun_1_open,
                const sun_1_close_type& sun_1_close,
                const mon_2_open_type& mon_2_open,
                const mon_2_close_type& mon_2_close,
                const tue_2_open_type& tue_2_open,
                const tue_2_close_type& tue_2_close,
                const wed_2_open_type& wed_2_open,
                const wed_2_close_type& wed_2_close,
                const thu_2_open_type& thu_2_open,
                const thu_2_close_type& thu_2_close,
                const fri_2_open_type& fri_2_open,
                const fri_2_close_type& fri_2_close,
                const sat_2_open_type& sat_2_open,
                const sat_2_close_type& sat_2_close,
                const sun_2_open_type& sun_2_open,
                const sun_2_close_type& sun_2_close)
    : ::xml_schema::type (),
      mon_1_open_ (mon_1_open, ::xml_schema::flags (), this),
      mon_1_close_ (mon_1_close, ::xml_schema::flags (), this),
      tue_1_open_ (tue_1_open, ::xml_schema::flags (), this),
      tue_1_close_ (tue_1_close, ::xml_schema::flags (), this),
      wed_1_open_ (wed_1_open, ::xml_schema::flags (), this),
      thu_1_open_ (thu_1_open, ::xml_schema::flags (), this),
      thu_1_close_ (thu_1_close, ::xml_schema::flags (), this),
      fri_1_open_ (fri_1_open, ::xml_schema::flags (), this),
      fri_1_close_ (fri_1_close, ::xml_schema::flags (), this),
      sat_1_open_ (sat_1_open, ::xml_schema::flags (), this),
      sat_1_close_ (sat_1_close, ::xml_schema::flags (), this),
      sun_1_open_ (sun_1_open, ::xml_schema::flags (), this),
      sun_1_close_ (sun_1_close, ::xml_schema::flags (), this),
      mon_2_open_ (mon_2_open, ::xml_schema::flags (), this),
      mon_2_close_ (mon_2_close, ::xml_schema::flags (), this),
      tue_2_open_ (tue_2_open, ::xml_schema::flags (), this),
      tue_2_close_ (tue_2_close, ::xml_schema::flags (), this),
      wed_2_open_ (wed_2_open, ::xml_schema::flags (), this),
      wed_2_close_ (wed_2_close, ::xml_schema::flags (), this),
      thu_2_open_ (thu_2_open, ::xml_schema::flags (), this),
      thu_2_close_ (thu_2_close, ::xml_schema::flags (), this),
      fri_2_open_ (fri_2_open, ::xml_schema::flags (), this),
      fri_2_close_ (fri_2_close, ::xml_schema::flags (), this),
      sat_2_open_ (sat_2_open, ::xml_schema::flags (), this),
      sat_2_close_ (sat_2_close, ::xml_schema::flags (), this),
      sun_2_open_ (sun_2_open, ::xml_schema::flags (), this),
      sun_2_close_ (sun_2_close, ::xml_schema::flags (), this)
    {
    }

    page_hours::
    page_hours (const page_hours& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      mon_1_open_ (x.mon_1_open_, f, this),
      mon_1_close_ (x.mon_1_close_, f, this),
      tue_1_open_ (x.tue_1_open_, f, this),
      tue_1_close_ (x.tue_1_close_, f, this),
      wed_1_open_ (x.wed_1_open_, f, this),
      thu_1_open_ (x.thu_1_open_, f, this),
      thu_1_close_ (x.thu_1_close_, f, this),
      fri_1_open_ (x.fri_1_open_, f, this),
      fri_1_close_ (x.fri_1_close_, f, this),
      sat_1_open_ (x.sat_1_open_, f, this),
      sat_1_close_ (x.sat_1_close_, f, this),
      sun_1_open_ (x.sun_1_open_, f, this),
      sun_1_close_ (x.sun_1_close_, f, this),
      mon_2_open_ (x.mon_2_open_, f, this),
      mon_2_close_ (x.mon_2_close_, f, this),
      tue_2_open_ (x.tue_2_open_, f, this),
      tue_2_close_ (x.tue_2_close_, f, this),
      wed_2_open_ (x.wed_2_open_, f, this),
      wed_2_close_ (x.wed_2_close_, f, this),
      thu_2_open_ (x.thu_2_open_, f, this),
      thu_2_close_ (x.thu_2_close_, f, this),
      fri_2_open_ (x.fri_2_open_, f, this),
      fri_2_close_ (x.fri_2_close_, f, this),
      sat_2_open_ (x.sat_2_open_, f, this),
      sat_2_close_ (x.sat_2_close_, f, this),
      sun_2_open_ (x.sun_2_open_, f, this),
      sun_2_close_ (x.sun_2_close_, f, this)
    {
    }

    page_hours::
    page_hours (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      mon_1_open_ (f, this),
      mon_1_close_ (f, this),
      tue_1_open_ (f, this),
      tue_1_close_ (f, this),
      wed_1_open_ (f, this),
      thu_1_open_ (f, this),
      thu_1_close_ (f, this),
      fri_1_open_ (f, this),
      fri_1_close_ (f, this),
      sat_1_open_ (f, this),
      sat_1_close_ (f, this),
      sun_1_open_ (f, this),
      sun_1_close_ (f, this),
      mon_2_open_ (f, this),
      mon_2_close_ (f, this),
      tue_2_open_ (f, this),
      tue_2_close_ (f, this),
      wed_2_open_ (f, this),
      wed_2_close_ (f, this),
      thu_2_open_ (f, this),
      thu_2_close_ (f, this),
      fri_2_open_ (f, this),
      fri_2_close_ (f, this),
      sat_2_open_ (f, this),
      sat_2_close_ (f, this),
      sun_2_open_ (f, this),
      sun_2_close_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page_hours::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // mon_1_open
        //
        if (n.name () == "mon_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mon_1_open_type > r (
            mon_1_open_traits::create (i, f, this));

          if (!mon_1_open_.present ())
          {
            this->mon_1_open (r);
            continue;
          }
        }

        // mon_1_close
        //
        if (n.name () == "mon_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mon_1_close_type > r (
            mon_1_close_traits::create (i, f, this));

          if (!mon_1_close_.present ())
          {
            this->mon_1_close (r);
            continue;
          }
        }

        // tue_1_open
        //
        if (n.name () == "tue_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tue_1_open_type > r (
            tue_1_open_traits::create (i, f, this));

          if (!tue_1_open_.present ())
          {
            this->tue_1_open (r);
            continue;
          }
        }

        // tue_1_close
        //
        if (n.name () == "tue_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tue_1_close_type > r (
            tue_1_close_traits::create (i, f, this));

          if (!tue_1_close_.present ())
          {
            this->tue_1_close (r);
            continue;
          }
        }

        // wed_1_open
        //
        if (n.name () == "wed_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< wed_1_open_type > r (
            wed_1_open_traits::create (i, f, this));

          if (!wed_1_open_.present ())
          {
            this->wed_1_open (r);
            continue;
          }
        }

        // thu_1_open
        //
        if (n.name () == "thu_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< thu_1_open_type > r (
            thu_1_open_traits::create (i, f, this));

          if (!thu_1_open_.present ())
          {
            this->thu_1_open (r);
            continue;
          }
        }

        // thu_1_close
        //
        if (n.name () == "thu_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< thu_1_close_type > r (
            thu_1_close_traits::create (i, f, this));

          if (!thu_1_close_.present ())
          {
            this->thu_1_close (r);
            continue;
          }
        }

        // fri_1_open
        //
        if (n.name () == "fri_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< fri_1_open_type > r (
            fri_1_open_traits::create (i, f, this));

          if (!fri_1_open_.present ())
          {
            this->fri_1_open (r);
            continue;
          }
        }

        // fri_1_close
        //
        if (n.name () == "fri_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< fri_1_close_type > r (
            fri_1_close_traits::create (i, f, this));

          if (!fri_1_close_.present ())
          {
            this->fri_1_close (r);
            continue;
          }
        }

        // sat_1_open
        //
        if (n.name () == "sat_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sat_1_open_type > r (
            sat_1_open_traits::create (i, f, this));

          if (!sat_1_open_.present ())
          {
            this->sat_1_open (r);
            continue;
          }
        }

        // sat_1_close
        //
        if (n.name () == "sat_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sat_1_close_type > r (
            sat_1_close_traits::create (i, f, this));

          if (!sat_1_close_.present ())
          {
            this->sat_1_close (r);
            continue;
          }
        }

        // sun_1_open
        //
        if (n.name () == "sun_1_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sun_1_open_type > r (
            sun_1_open_traits::create (i, f, this));

          if (!sun_1_open_.present ())
          {
            this->sun_1_open (r);
            continue;
          }
        }

        // sun_1_close
        //
        if (n.name () == "sun_1_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sun_1_close_type > r (
            sun_1_close_traits::create (i, f, this));

          if (!sun_1_close_.present ())
          {
            this->sun_1_close (r);
            continue;
          }
        }

        // mon_2_open
        //
        if (n.name () == "mon_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mon_2_open_type > r (
            mon_2_open_traits::create (i, f, this));

          if (!mon_2_open_.present ())
          {
            this->mon_2_open (r);
            continue;
          }
        }

        // mon_2_close
        //
        if (n.name () == "mon_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mon_2_close_type > r (
            mon_2_close_traits::create (i, f, this));

          if (!mon_2_close_.present ())
          {
            this->mon_2_close (r);
            continue;
          }
        }

        // tue_2_open
        //
        if (n.name () == "tue_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tue_2_open_type > r (
            tue_2_open_traits::create (i, f, this));

          if (!tue_2_open_.present ())
          {
            this->tue_2_open (r);
            continue;
          }
        }

        // tue_2_close
        //
        if (n.name () == "tue_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< tue_2_close_type > r (
            tue_2_close_traits::create (i, f, this));

          if (!tue_2_close_.present ())
          {
            this->tue_2_close (r);
            continue;
          }
        }

        // wed_2_open
        //
        if (n.name () == "wed_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< wed_2_open_type > r (
            wed_2_open_traits::create (i, f, this));

          if (!wed_2_open_.present ())
          {
            this->wed_2_open (r);
            continue;
          }
        }

        // wed_2_close
        //
        if (n.name () == "wed_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< wed_2_close_type > r (
            wed_2_close_traits::create (i, f, this));

          if (!wed_2_close_.present ())
          {
            this->wed_2_close (r);
            continue;
          }
        }

        // thu_2_open
        //
        if (n.name () == "thu_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< thu_2_open_type > r (
            thu_2_open_traits::create (i, f, this));

          if (!thu_2_open_.present ())
          {
            this->thu_2_open (r);
            continue;
          }
        }

        // thu_2_close
        //
        if (n.name () == "thu_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< thu_2_close_type > r (
            thu_2_close_traits::create (i, f, this));

          if (!thu_2_close_.present ())
          {
            this->thu_2_close (r);
            continue;
          }
        }

        // fri_2_open
        //
        if (n.name () == "fri_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< fri_2_open_type > r (
            fri_2_open_traits::create (i, f, this));

          if (!fri_2_open_.present ())
          {
            this->fri_2_open (r);
            continue;
          }
        }

        // fri_2_close
        //
        if (n.name () == "fri_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< fri_2_close_type > r (
            fri_2_close_traits::create (i, f, this));

          if (!fri_2_close_.present ())
          {
            this->fri_2_close (r);
            continue;
          }
        }

        // sat_2_open
        //
        if (n.name () == "sat_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sat_2_open_type > r (
            sat_2_open_traits::create (i, f, this));

          if (!sat_2_open_.present ())
          {
            this->sat_2_open (r);
            continue;
          }
        }

        // sat_2_close
        //
        if (n.name () == "sat_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sat_2_close_type > r (
            sat_2_close_traits::create (i, f, this));

          if (!sat_2_close_.present ())
          {
            this->sat_2_close (r);
            continue;
          }
        }

        // sun_2_open
        //
        if (n.name () == "sun_2_open" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sun_2_open_type > r (
            sun_2_open_traits::create (i, f, this));

          if (!sun_2_open_.present ())
          {
            this->sun_2_open (r);
            continue;
          }
        }

        // sun_2_close
        //
        if (n.name () == "sun_2_close" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sun_2_close_type > r (
            sun_2_close_traits::create (i, f, this));

          if (!sun_2_close_.present ())
          {
            this->sun_2_close (r);
            continue;
          }
        }

        break;
      }

      if (!mon_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mon_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!mon_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mon_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!tue_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tue_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!tue_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tue_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!wed_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "wed_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!thu_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "thu_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!thu_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "thu_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!fri_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fri_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!fri_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fri_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!sat_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sat_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!sat_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sat_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!sun_1_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sun_1_open",
          "http://api.facebook.com/1.0/");
      }

      if (!sun_1_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sun_1_close",
          "http://api.facebook.com/1.0/");
      }

      if (!mon_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mon_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!mon_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mon_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!tue_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tue_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!tue_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "tue_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!wed_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "wed_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!wed_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "wed_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!thu_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "thu_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!thu_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "thu_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!fri_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fri_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!fri_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "fri_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!sat_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sat_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!sat_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sat_2_close",
          "http://api.facebook.com/1.0/");
      }

      if (!sun_2_open_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sun_2_open",
          "http://api.facebook.com/1.0/");
      }

      if (!sun_2_close_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sun_2_close",
          "http://api.facebook.com/1.0/");
      }
    }

    page_hours* page_hours::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_hours (*this, f, c);
    }

    page_hours::
    ~page_hours ()
    {
    }

    // page_parking
    //

    page_parking::
    page_parking (const street_type& street,
                  const lot_type& lot,
                  const valet_type& valet)
    : ::xml_schema::type (),
      street_ (street, ::xml_schema::flags (), this),
      lot_ (lot, ::xml_schema::flags (), this),
      valet_ (valet, ::xml_schema::flags (), this)
    {
    }

    page_parking::
    page_parking (const page_parking& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      street_ (x.street_, f, this),
      lot_ (x.lot_, f, this),
      valet_ (x.valet_, f, this)
    {
    }

    page_parking::
    page_parking (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      street_ (f, this),
      lot_ (f, this),
      valet_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page_parking::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // street
        //
        if (n.name () == "street" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!street_.present ())
          {
            this->street (street_traits::create (i, f, this));
            continue;
          }
        }

        // lot
        //
        if (n.name () == "lot" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!lot_.present ())
          {
            this->lot (lot_traits::create (i, f, this));
            continue;
          }
        }

        // valet
        //
        if (n.name () == "valet" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!valet_.present ())
          {
            this->valet (valet_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!street_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "street",
          "http://api.facebook.com/1.0/");
      }

      if (!lot_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lot",
          "http://api.facebook.com/1.0/");
      }

      if (!valet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "valet",
          "http://api.facebook.com/1.0/");
      }
    }

    page_parking* page_parking::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_parking (*this, f, c);
    }

    page_parking::
    ~page_parking ()
    {
    }

    // page_restaurant_services
    //

    page_restaurant_services::
    page_restaurant_services (const reserve_type& reserve,
                              const walkins_type& walkins,
                              const groups_type& groups,
                              const kids_type& kids,
                              const takeout_type& takeout,
                              const delivery_type& delivery,
                              const catering_type& catering,
                              const waiter_type& waiter,
                              const outdoor_type& outdoor)
    : ::xml_schema::type (),
      reserve_ (reserve, ::xml_schema::flags (), this),
      walkins_ (walkins, ::xml_schema::flags (), this),
      groups_ (groups, ::xml_schema::flags (), this),
      kids_ (kids, ::xml_schema::flags (), this),
      takeout_ (takeout, ::xml_schema::flags (), this),
      delivery_ (delivery, ::xml_schema::flags (), this),
      catering_ (catering, ::xml_schema::flags (), this),
      waiter_ (waiter, ::xml_schema::flags (), this),
      outdoor_ (outdoor, ::xml_schema::flags (), this)
    {
    }

    page_restaurant_services::
    page_restaurant_services (const page_restaurant_services& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      reserve_ (x.reserve_, f, this),
      walkins_ (x.walkins_, f, this),
      groups_ (x.groups_, f, this),
      kids_ (x.kids_, f, this),
      takeout_ (x.takeout_, f, this),
      delivery_ (x.delivery_, f, this),
      catering_ (x.catering_, f, this),
      waiter_ (x.waiter_, f, this),
      outdoor_ (x.outdoor_, f, this)
    {
    }

    page_restaurant_services::
    page_restaurant_services (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      reserve_ (f, this),
      walkins_ (f, this),
      groups_ (f, this),
      kids_ (f, this),
      takeout_ (f, this),
      delivery_ (f, this),
      catering_ (f, this),
      waiter_ (f, this),
      outdoor_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page_restaurant_services::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // reserve
        //
        if (n.name () == "reserve" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!reserve_.present ())
          {
            this->reserve (reserve_traits::create (i, f, this));
            continue;
          }
        }

        // walkins
        //
        if (n.name () == "walkins" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!walkins_.present ())
          {
            this->walkins (walkins_traits::create (i, f, this));
            continue;
          }
        }

        // groups
        //
        if (n.name () == "groups" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!groups_.present ())
          {
            this->groups (groups_traits::create (i, f, this));
            continue;
          }
        }

        // kids
        //
        if (n.name () == "kids" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!kids_.present ())
          {
            this->kids (kids_traits::create (i, f, this));
            continue;
          }
        }

        // takeout
        //
        if (n.name () == "takeout" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!takeout_.present ())
          {
            this->takeout (takeout_traits::create (i, f, this));
            continue;
          }
        }

        // delivery
        //
        if (n.name () == "delivery" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!delivery_.present ())
          {
            this->delivery (delivery_traits::create (i, f, this));
            continue;
          }
        }

        // catering
        //
        if (n.name () == "catering" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!catering_.present ())
          {
            this->catering (catering_traits::create (i, f, this));
            continue;
          }
        }

        // waiter
        //
        if (n.name () == "waiter" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!waiter_.present ())
          {
            this->waiter (waiter_traits::create (i, f, this));
            continue;
          }
        }

        // outdoor
        //
        if (n.name () == "outdoor" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!outdoor_.present ())
          {
            this->outdoor (outdoor_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!reserve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "reserve",
          "http://api.facebook.com/1.0/");
      }

      if (!walkins_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "walkins",
          "http://api.facebook.com/1.0/");
      }

      if (!groups_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "groups",
          "http://api.facebook.com/1.0/");
      }

      if (!kids_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "kids",
          "http://api.facebook.com/1.0/");
      }

      if (!takeout_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "takeout",
          "http://api.facebook.com/1.0/");
      }

      if (!delivery_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "delivery",
          "http://api.facebook.com/1.0/");
      }

      if (!catering_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "catering",
          "http://api.facebook.com/1.0/");
      }

      if (!waiter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "waiter",
          "http://api.facebook.com/1.0/");
      }

      if (!outdoor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "outdoor",
          "http://api.facebook.com/1.0/");
      }
    }

    page_restaurant_services* page_restaurant_services::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_restaurant_services (*this, f, c);
    }

    page_restaurant_services::
    ~page_restaurant_services ()
    {
    }

    // page_restaurant_specialties
    //

    page_restaurant_specialties::
    page_restaurant_specialties (const breakfast_type& breakfast,
                                 const lunch_type& lunch,
                                 const dinner_type& dinner,
                                 const coffee_type& coffee,
                                 const drinks_type& drinks)
    : ::xml_schema::type (),
      breakfast_ (breakfast, ::xml_schema::flags (), this),
      lunch_ (lunch, ::xml_schema::flags (), this),
      dinner_ (dinner, ::xml_schema::flags (), this),
      coffee_ (coffee, ::xml_schema::flags (), this),
      drinks_ (drinks, ::xml_schema::flags (), this)
    {
    }

    page_restaurant_specialties::
    page_restaurant_specialties (const page_restaurant_specialties& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      breakfast_ (x.breakfast_, f, this),
      lunch_ (x.lunch_, f, this),
      dinner_ (x.dinner_, f, this),
      coffee_ (x.coffee_, f, this),
      drinks_ (x.drinks_, f, this)
    {
    }

    page_restaurant_specialties::
    page_restaurant_specialties (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      breakfast_ (f, this),
      lunch_ (f, this),
      dinner_ (f, this),
      coffee_ (f, this),
      drinks_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page_restaurant_specialties::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // breakfast
        //
        if (n.name () == "breakfast" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!breakfast_.present ())
          {
            this->breakfast (breakfast_traits::create (i, f, this));
            continue;
          }
        }

        // lunch
        //
        if (n.name () == "lunch" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!lunch_.present ())
          {
            this->lunch (lunch_traits::create (i, f, this));
            continue;
          }
        }

        // dinner
        //
        if (n.name () == "dinner" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!dinner_.present ())
          {
            this->dinner (dinner_traits::create (i, f, this));
            continue;
          }
        }

        // coffee
        //
        if (n.name () == "coffee" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!coffee_.present ())
          {
            this->coffee (coffee_traits::create (i, f, this));
            continue;
          }
        }

        // drinks
        //
        if (n.name () == "drinks" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!drinks_.present ())
          {
            this->drinks (drinks_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!breakfast_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "breakfast",
          "http://api.facebook.com/1.0/");
      }

      if (!lunch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lunch",
          "http://api.facebook.com/1.0/");
      }

      if (!dinner_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dinner",
          "http://api.facebook.com/1.0/");
      }

      if (!coffee_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "coffee",
          "http://api.facebook.com/1.0/");
      }

      if (!drinks_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "drinks",
          "http://api.facebook.com/1.0/");
      }
    }

    page_restaurant_specialties* page_restaurant_specialties::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_restaurant_specialties (*this, f, c);
    }

    page_restaurant_specialties::
    ~page_restaurant_specialties ()
    {
    }

    // page_payment_options
    //

    page_payment_options::
    page_payment_options (const cash_only_type& cash_only,
                          const visa_type& visa,
                          const amex_type& amex,
                          const mastercard_type& mastercard,
                          const discover_type& discover)
    : ::xml_schema::type (),
      cash_only_ (cash_only, ::xml_schema::flags (), this),
      visa_ (visa, ::xml_schema::flags (), this),
      amex_ (amex, ::xml_schema::flags (), this),
      mastercard_ (mastercard, ::xml_schema::flags (), this),
      discover_ (discover, ::xml_schema::flags (), this)
    {
    }

    page_payment_options::
    page_payment_options (const page_payment_options& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cash_only_ (x.cash_only_, f, this),
      visa_ (x.visa_, f, this),
      amex_ (x.amex_, f, this),
      mastercard_ (x.mastercard_, f, this),
      discover_ (x.discover_, f, this)
    {
    }

    page_payment_options::
    page_payment_options (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cash_only_ (f, this),
      visa_ (f, this),
      amex_ (f, this),
      mastercard_ (f, this),
      discover_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page_payment_options::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cash_only
        //
        if (n.name () == "cash_only" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!cash_only_.present ())
          {
            this->cash_only (cash_only_traits::create (i, f, this));
            continue;
          }
        }

        // visa
        //
        if (n.name () == "visa" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!visa_.present ())
          {
            this->visa (visa_traits::create (i, f, this));
            continue;
          }
        }

        // amex
        //
        if (n.name () == "amex" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!amex_.present ())
          {
            this->amex (amex_traits::create (i, f, this));
            continue;
          }
        }

        // mastercard
        //
        if (n.name () == "mastercard" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!mastercard_.present ())
          {
            this->mastercard (mastercard_traits::create (i, f, this));
            continue;
          }
        }

        // discover
        //
        if (n.name () == "discover" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!discover_.present ())
          {
            this->discover (discover_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!cash_only_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "cash_only",
          "http://api.facebook.com/1.0/");
      }

      if (!visa_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "visa",
          "http://api.facebook.com/1.0/");
      }

      if (!amex_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "amex",
          "http://api.facebook.com/1.0/");
      }

      if (!mastercard_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mastercard",
          "http://api.facebook.com/1.0/");
      }

      if (!discover_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "discover",
          "http://api.facebook.com/1.0/");
      }
    }

    page_payment_options* page_payment_options::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page_payment_options (*this, f, c);
    }

    page_payment_options::
    ~page_payment_options ()
    {
    }

    // page
    //

    page::
    page ()
    : ::xml_schema::type (),
      page_id_ (::xml_schema::flags (), this),
      name_ (::xml_schema::flags (), this),
      pic_small_ (::xml_schema::flags (), this),
      pic_big_ (::xml_schema::flags (), this),
      pic_square_ (::xml_schema::flags (), this),
      pic_ (::xml_schema::flags (), this),
      pic_large_ (::xml_schema::flags (), this),
      status_ (::xml_schema::flags (), this),
      type_ (::xml_schema::flags (), this),
      website_ (::xml_schema::flags (), this),
      has_added_app_ (::xml_schema::flags (), this),
      founded_ (::xml_schema::flags (), this),
      company_overview_ (::xml_schema::flags (), this),
      mission_ (::xml_schema::flags (), this),
      products_ (::xml_schema::flags (), this),
      location_ (::xml_schema::flags (), this),
      parking_ (::xml_schema::flags (), this),
      public_transit_ (::xml_schema::flags (), this),
      hours_ (::xml_schema::flags (), this),
      attire_ (::xml_schema::flags (), this),
      payment_options_ (::xml_schema::flags (), this),
      culinary_team_ (::xml_schema::flags (), this),
      general_manager_ (::xml_schema::flags (), this),
      price_range_ (::xml_schema::flags (), this),
      restaurant_services_ (::xml_schema::flags (), this),
      restaurant_specialties_ (::xml_schema::flags (), this),
      release_date_ (::xml_schema::flags (), this),
      genre_ (::xml_schema::flags (), this),
      starring_ (::xml_schema::flags (), this),
      screenplay_by_ (::xml_schema::flags (), this),
      directed_by_ (::xml_schema::flags (), this),
      produced_by_ (::xml_schema::flags (), this),
      studio_ (::xml_schema::flags (), this),
      awards_ (::xml_schema::flags (), this),
      plot_outline_ (::xml_schema::flags (), this),
      network_ (::xml_schema::flags (), this),
      season_ (::xml_schema::flags (), this),
      schedule_ (::xml_schema::flags (), this),
      written_by_ (::xml_schema::flags (), this),
      band_members_ (::xml_schema::flags (), this),
      hometown_ (::xml_schema::flags (), this),
      current_location_ (::xml_schema::flags (), this),
      record_label_ (::xml_schema::flags (), this),
      booking_agent_ (::xml_schema::flags (), this),
      artists_we_like_ (::xml_schema::flags (), this),
      influences_ (::xml_schema::flags (), this),
      band_interests_ (::xml_schema::flags (), this),
      bio_ (::xml_schema::flags (), this),
      affiliation_ (::xml_schema::flags (), this),
      birthday_ (::xml_schema::flags (), this),
      personal_info_ (::xml_schema::flags (), this),
      personal_interests_ (::xml_schema::flags (), this),
      members_ (::xml_schema::flags (), this),
      built_ (::xml_schema::flags (), this),
      features_ (::xml_schema::flags (), this),
      mpg_ (::xml_schema::flags (), this),
      general_info_ (::xml_schema::flags (), this)
    {
    }

    page::
    page (const page& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      page_id_ (x.page_id_, f, this),
      name_ (x.name_, f, this),
      pic_small_ (x.pic_small_, f, this),
      pic_big_ (x.pic_big_, f, this),
      pic_square_ (x.pic_square_, f, this),
      pic_ (x.pic_, f, this),
      pic_large_ (x.pic_large_, f, this),
      status_ (x.status_, f, this),
      type_ (x.type_, f, this),
      website_ (x.website_, f, this),
      has_added_app_ (x.has_added_app_, f, this),
      founded_ (x.founded_, f, this),
      company_overview_ (x.company_overview_, f, this),
      mission_ (x.mission_, f, this),
      products_ (x.products_, f, this),
      location_ (x.location_, f, this),
      parking_ (x.parking_, f, this),
      public_transit_ (x.public_transit_, f, this),
      hours_ (x.hours_, f, this),
      attire_ (x.attire_, f, this),
      payment_options_ (x.payment_options_, f, this),
      culinary_team_ (x.culinary_team_, f, this),
      general_manager_ (x.general_manager_, f, this),
      price_range_ (x.price_range_, f, this),
      restaurant_services_ (x.restaurant_services_, f, this),
      restaurant_specialties_ (x.restaurant_specialties_, f, this),
      release_date_ (x.release_date_, f, this),
      genre_ (x.genre_, f, this),
      starring_ (x.starring_, f, this),
      screenplay_by_ (x.screenplay_by_, f, this),
      directed_by_ (x.directed_by_, f, this),
      produced_by_ (x.produced_by_, f, this),
      studio_ (x.studio_, f, this),
      awards_ (x.awards_, f, this),
      plot_outline_ (x.plot_outline_, f, this),
      network_ (x.network_, f, this),
      season_ (x.season_, f, this),
      schedule_ (x.schedule_, f, this),
      written_by_ (x.written_by_, f, this),
      band_members_ (x.band_members_, f, this),
      hometown_ (x.hometown_, f, this),
      current_location_ (x.current_location_, f, this),
      record_label_ (x.record_label_, f, this),
      booking_agent_ (x.booking_agent_, f, this),
      artists_we_like_ (x.artists_we_like_, f, this),
      influences_ (x.influences_, f, this),
      band_interests_ (x.band_interests_, f, this),
      bio_ (x.bio_, f, this),
      affiliation_ (x.affiliation_, f, this),
      birthday_ (x.birthday_, f, this),
      personal_info_ (x.personal_info_, f, this),
      personal_interests_ (x.personal_interests_, f, this),
      members_ (x.members_, f, this),
      built_ (x.built_, f, this),
      features_ (x.features_, f, this),
      mpg_ (x.mpg_, f, this),
      general_info_ (x.general_info_, f, this)
    {
    }

    page::
    page (const xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      page_id_ (f, this),
      name_ (f, this),
      pic_small_ (f, this),
      pic_big_ (f, this),
      pic_square_ (f, this),
      pic_ (f, this),
      pic_large_ (f, this),
      status_ (f, this),
      type_ (f, this),
      website_ (f, this),
      has_added_app_ (f, this),
      founded_ (f, this),
      company_overview_ (f, this),
      mission_ (f, this),
      products_ (f, this),
      location_ (f, this),
      parking_ (f, this),
      public_transit_ (f, this),
      hours_ (f, this),
      attire_ (f, this),
      payment_options_ (f, this),
      culinary_team_ (f, this),
      general_manager_ (f, this),
      price_range_ (f, this),
      restaurant_services_ (f, this),
      restaurant_specialties_ (f, this),
      release_date_ (f, this),
      genre_ (f, this),
      starring_ (f, this),
      screenplay_by_ (f, this),
      directed_by_ (f, this),
      produced_by_ (f, this),
      studio_ (f, this),
      awards_ (f, this),
      plot_outline_ (f, this),
      network_ (f, this),
      season_ (f, this),
      schedule_ (f, this),
      written_by_ (f, this),
      band_members_ (f, this),
      hometown_ (f, this),
      current_location_ (f, this),
      record_label_ (f, this),
      booking_agent_ (f, this),
      artists_we_like_ (f, this),
      influences_ (f, this),
      band_interests_ (f, this),
      bio_ (f, this),
      affiliation_ (f, this),
      birthday_ (f, this),
      personal_info_ (f, this),
      personal_interests_ (f, this),
      members_ (f, this),
      built_ (f, this),
      features_ (f, this),
      mpg_ (f, this),
      general_info_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void page::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // page_id
        //
        if (n.name () == "page_id" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< page_id_type > r (
            page_id_traits::create (i, f, this));

          if (!this->page_id ())
          {
            this->page_id (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!this->name ())
          {
            this->name (r);
            continue;
          }
        }

        // pic_small
        //
        if (n.name () == "pic_small" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_small_type > r (
            pic_small_traits::create (i, f, this));

          if (!this->pic_small ())
          {
            this->pic_small (r);
            continue;
          }
        }

        // pic_big
        //
        if (n.name () == "pic_big" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_big_type > r (
            pic_big_traits::create (i, f, this));

          if (!this->pic_big ())
          {
            this->pic_big (r);
            continue;
          }
        }

        // pic_square
        //
        if (n.name () == "pic_square" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_square_type > r (
            pic_square_traits::create (i, f, this));

          if (!this->pic_square ())
          {
            this->pic_square (r);
            continue;
          }
        }

        // pic
        //
        if (n.name () == "pic" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_type > r (
            pic_traits::create (i, f, this));

          if (!this->pic ())
          {
            this->pic (r);
            continue;
          }
        }

        // pic_large
        //
        if (n.name () == "pic_large" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< pic_large_type > r (
            pic_large_traits::create (i, f, this));

          if (!this->pic_large ())
          {
            this->pic_large (r);
            continue;
          }
        }

        // status
        //
        if (n.name () == "status" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< status_type > r (
            status_traits::create (i, f, this));

          if (!this->status ())
          {
            this->status (r);
            continue;
          }
        }

        // type
        //
        if (n.name () == "type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          if (!this->type ())
          {
            this->type (r);
            continue;
          }
        }

        // website
        //
        if (n.name () == "website" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< website_type > r (
            website_traits::create (i, f, this));

          if (!this->website ())
          {
            this->website (r);
            continue;
          }
        }

        // has_added_app
        //
        if (n.name () == "has_added_app" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!this->has_added_app ())
          {
            this->has_added_app (has_added_app_traits::create (i, f, this));
            continue;
          }
        }

        // founded
        //
        if (n.name () == "founded" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< founded_type > r (
            founded_traits::create (i, f, this));

          if (!this->founded ())
          {
            this->founded (r);
            continue;
          }
        }

        // company_overview
        //
        if (n.name () == "company_overview" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< company_overview_type > r (
            company_overview_traits::create (i, f, this));

          if (!this->company_overview ())
          {
            this->company_overview (r);
            continue;
          }
        }

        // mission
        //
        if (n.name () == "mission" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mission_type > r (
            mission_traits::create (i, f, this));

          if (!this->mission ())
          {
            this->mission (r);
            continue;
          }
        }

        // products
        //
        if (n.name () == "products" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< products_type > r (
            products_traits::create (i, f, this));

          if (!this->products ())
          {
            this->products (r);
            continue;
          }
        }

        // location
        //
        if (n.name () == "location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< location_type > r (
            location_traits::create (i, f, this));

          if (!this->location ())
          {
            this->location (r);
            continue;
          }
        }

        // parking
        //
        if (n.name () == "parking" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< parking_type > r (
            parking_traits::create (i, f, this));

          if (!this->parking ())
          {
            this->parking (r);
            continue;
          }
        }

        // public_transit
        //
        if (n.name () == "public_transit" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< public_transit_type > r (
            public_transit_traits::create (i, f, this));

          if (!this->public_transit ())
          {
            this->public_transit (r);
            continue;
          }
        }

        // hours
        //
        if (n.name () == "hours" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hours_type > r (
            hours_traits::create (i, f, this));

          if (!this->hours ())
          {
            this->hours (r);
            continue;
          }
        }

        // attire
        //
        if (n.name () == "attire" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< attire_type > r (
            attire_traits::create (i, f, this));

          if (!this->attire ())
          {
            this->attire (r);
            continue;
          }
        }

        // payment_options
        //
        if (n.name () == "payment_options" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< payment_options_type > r (
            payment_options_traits::create (i, f, this));

          if (!this->payment_options ())
          {
            this->payment_options (r);
            continue;
          }
        }

        // culinary_team
        //
        if (n.name () == "culinary_team" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< culinary_team_type > r (
            culinary_team_traits::create (i, f, this));

          if (!this->culinary_team ())
          {
            this->culinary_team (r);
            continue;
          }
        }

        // general_manager
        //
        if (n.name () == "general_manager" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< general_manager_type > r (
            general_manager_traits::create (i, f, this));

          if (!this->general_manager ())
          {
            this->general_manager (r);
            continue;
          }
        }

        // price_range
        //
        if (n.name () == "price_range" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< price_range_type > r (
            price_range_traits::create (i, f, this));

          if (!this->price_range ())
          {
            this->price_range (r);
            continue;
          }
        }

        // restaurant_services
        //
        if (n.name () == "restaurant_services" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< restaurant_services_type > r (
            restaurant_services_traits::create (i, f, this));

          if (!this->restaurant_services ())
          {
            this->restaurant_services (r);
            continue;
          }
        }

        // restaurant_specialties
        //
        if (n.name () == "restaurant_specialties" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< restaurant_specialties_type > r (
            restaurant_specialties_traits::create (i, f, this));

          if (!this->restaurant_specialties ())
          {
            this->restaurant_specialties (r);
            continue;
          }
        }

        // release_date
        //
        if (n.name () == "release_date" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< release_date_type > r (
            release_date_traits::create (i, f, this));

          if (!this->release_date ())
          {
            this->release_date (r);
            continue;
          }
        }

        // genre
        //
        if (n.name () == "genre" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< genre_type > r (
            genre_traits::create (i, f, this));

          if (!this->genre ())
          {
            this->genre (r);
            continue;
          }
        }

        // starring
        //
        if (n.name () == "starring" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< starring_type > r (
            starring_traits::create (i, f, this));

          if (!this->starring ())
          {
            this->starring (r);
            continue;
          }
        }

        // screenplay_by
        //
        if (n.name () == "screenplay_by" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< screenplay_by_type > r (
            screenplay_by_traits::create (i, f, this));

          if (!this->screenplay_by ())
          {
            this->screenplay_by (r);
            continue;
          }
        }

        // directed_by
        //
        if (n.name () == "directed_by" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< directed_by_type > r (
            directed_by_traits::create (i, f, this));

          if (!this->directed_by ())
          {
            this->directed_by (r);
            continue;
          }
        }

        // produced_by
        //
        if (n.name () == "produced_by" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< produced_by_type > r (
            produced_by_traits::create (i, f, this));

          if (!this->produced_by ())
          {
            this->produced_by (r);
            continue;
          }
        }

        // studio
        //
        if (n.name () == "studio" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< studio_type > r (
            studio_traits::create (i, f, this));

          if (!this->studio ())
          {
            this->studio (r);
            continue;
          }
        }

        // awards
        //
        if (n.name () == "awards" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< awards_type > r (
            awards_traits::create (i, f, this));

          if (!this->awards ())
          {
            this->awards (r);
            continue;
          }
        }

        // plot_outline
        //
        if (n.name () == "plot_outline" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< plot_outline_type > r (
            plot_outline_traits::create (i, f, this));

          if (!this->plot_outline ())
          {
            this->plot_outline (r);
            continue;
          }
        }

        // network
        //
        if (n.name () == "network" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< network_type > r (
            network_traits::create (i, f, this));

          if (!this->network ())
          {
            this->network (r);
            continue;
          }
        }

        // season
        //
        if (n.name () == "season" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< season_type > r (
            season_traits::create (i, f, this));

          if (!this->season ())
          {
            this->season (r);
            continue;
          }
        }

        // schedule
        //
        if (n.name () == "schedule" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< schedule_type > r (
            schedule_traits::create (i, f, this));

          if (!this->schedule ())
          {
            this->schedule (r);
            continue;
          }
        }

        // written_by
        //
        if (n.name () == "written_by" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< written_by_type > r (
            written_by_traits::create (i, f, this));

          if (!this->written_by ())
          {
            this->written_by (r);
            continue;
          }
        }

        // band_members
        //
        if (n.name () == "band_members" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< band_members_type > r (
            band_members_traits::create (i, f, this));

          if (!this->band_members ())
          {
            this->band_members (r);
            continue;
          }
        }

        // hometown
        //
        if (n.name () == "hometown" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< hometown_type > r (
            hometown_traits::create (i, f, this));

          if (!this->hometown ())
          {
            this->hometown (r);
            continue;
          }
        }

        // current_location
        //
        if (n.name () == "current_location" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< current_location_type > r (
            current_location_traits::create (i, f, this));

          if (!this->current_location ())
          {
            this->current_location (r);
            continue;
          }
        }

        // record_label
        //
        if (n.name () == "record_label" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< record_label_type > r (
            record_label_traits::create (i, f, this));

          if (!this->record_label ())
          {
            this->record_label (r);
            continue;
          }
        }

        // booking_agent
        //
        if (n.name () == "booking_agent" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< booking_agent_type > r (
            booking_agent_traits::create (i, f, this));

          if (!this->booking_agent ())
          {
            this->booking_agent (r);
            continue;
          }
        }

        // artists_we_like
        //
        if (n.name () == "artists_we_like" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< artists_we_like_type > r (
            artists_we_like_traits::create (i, f, this));

          if (!this->artists_we_like ())
          {
            this->artists_we_like (r);
            continue;
          }
        }

        // influences
        //
        if (n.name () == "influences" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< influences_type > r (
            influences_traits::create (i, f, this));

          if (!this->influences ())
          {
            this->influences (r);
            continue;
          }
        }

        // band_interests
        //
        if (n.name () == "band_interests" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< band_interests_type > r (
            band_interests_traits::create (i, f, this));

          if (!this->band_interests ())
          {
            this->band_interests (r);
            continue;
          }
        }

        // bio
        //
        if (n.name () == "bio" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< bio_type > r (
            bio_traits::create (i, f, this));

          if (!this->bio ())
          {
            this->bio (r);
            continue;
          }
        }

        // affiliation
        //
        if (n.name () == "affiliation" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< affiliation_type > r (
            affiliation_traits::create (i, f, this));

          if (!this->affiliation ())
          {
            this->affiliation (r);
            continue;
          }
        }

        // birthday
        //
        if (n.name () == "birthday" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< birthday_type > r (
            birthday_traits::create (i, f, this));

          if (!this->birthday ())
          {
            this->birthday (r);
            continue;
          }
        }

        // personal_info
        //
        if (n.name () == "personal_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< personal_info_type > r (
            personal_info_traits::create (i, f, this));

          if (!this->personal_info ())
          {
            this->personal_info (r);
            continue;
          }
        }

        // personal_interests
        //
        if (n.name () == "personal_interests" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< personal_interests_type > r (
            personal_interests_traits::create (i, f, this));

          if (!this->personal_interests ())
          {
            this->personal_interests (r);
            continue;
          }
        }

        // members
        //
        if (n.name () == "members" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< members_type > r (
            members_traits::create (i, f, this));

          if (!this->members ())
          {
            this->members (r);
            continue;
          }
        }

        // built
        //
        if (n.name () == "built" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< built_type > r (
            built_traits::create (i, f, this));

          if (!this->built ())
          {
            this->built (r);
            continue;
          }
        }

        // features
        //
        if (n.name () == "features" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< features_type > r (
            features_traits::create (i, f, this));

          if (!this->features ())
          {
            this->features (r);
            continue;
          }
        }

        // mpg
        //
        if (n.name () == "mpg" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< mpg_type > r (
            mpg_traits::create (i, f, this));

          if (!this->mpg ())
          {
            this->mpg (r);
            continue;
          }
        }

        // general_info
        //
        if (n.name () == "general_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< general_info_type > r (
            general_info_traits::create (i, f, this));

          if (!this->general_info ())
          {
            this->general_info (r);
            continue;
          }
        }

        break;
      }
    }

    page* page::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new page (*this, f, c);
    }

    page::
    ~page ()
    {
    }

    // cookie
    //

    cookie::
    cookie (const uid_type& uid,
            const name_type& name,
            const value_type& value,
            const expires_type& expires,
            const path_type& path)
    : ::xml_schema::type (),
      uid_ (uid, ::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      value_ (value, ::xml_schema::flags (), this),
      expires_ (expires, ::xml_schema::flags (), this),
      path_ (path, ::xml_schema::flags (), this)
    {
    }

    cookie::
    cookie (const cookie& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      name_ (x.name_, f, this),
      value_ (x.value_, f, this),
      expires_ (x.expires_, f, this),
      path_ (x.path_, f, this)
    {
    }

    cookie::
    cookie (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      name_ (f, this),
      value_ (f, this),
      expires_ (f, this),
      path_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void cookie::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          if (!uid_.present ())
          {
            this->uid (r);
            continue;
          }
        }

        // name
        //
        if (n.name () == "name" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          if (!name_.present ())
          {
            this->name (r);
            continue;
          }
        }

        // value
        //
        if (n.name () == "value" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          if (!value_.present ())
          {
            this->value (r);
            continue;
          }
        }

        // expires
        //
        if (n.name () == "expires" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          if (!expires_.present ())
          {
            this->expires (expires_traits::create (i, f, this));
            continue;
          }
        }

        // path
        //
        if (n.name () == "path" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< path_type > r (
            path_traits::create (i, f, this));

          if (!path_.present ())
          {
            this->path (r);
            continue;
          }
        }

        break;
      }

      if (!uid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "uid",
          "http://api.facebook.com/1.0/");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "name",
          "http://api.facebook.com/1.0/");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "http://api.facebook.com/1.0/");
      }

      if (!expires_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "expires",
          "http://api.facebook.com/1.0/");
      }

      if (!path_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "path",
          "http://api.facebook.com/1.0/");
      }
    }

    cookie* cookie::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new cookie (*this, f, c);
    }

    cookie::
    ~cookie ()
    {
    }

    // phrase
    //

    phrase::
    phrase (const description_type& description,
            const text_type& text)
    : ::xml_schema::type (),
      description_ (description, ::xml_schema::flags (), this),
      text_ (text, ::xml_schema::flags (), this)
    {
    }

    phrase::
    phrase (const phrase& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      description_ (x.description_, f, this),
      text_ (x.text_, f, this)
    {
    }

    phrase::
    phrase (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      description_ (f, this),
      text_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void phrase::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!description_.present ())
          {
            this->description (r);
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< text_type > r (
            text_traits::create (i, f, this));

          if (!text_.present ())
          {
            this->text (r);
            continue;
          }
        }

        break;
      }

      if (!description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "description",
          "http://api.facebook.com/1.0/");
      }

      if (!text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "text",
          "http://api.facebook.com/1.0/");
      }
    }

    phrase* phrase::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new phrase (*this, f, c);
    }

    phrase::
    ~phrase ()
    {
    }

    // request_args
    //

    request_args::
    request_args ()
    : ::xml_schema::type (),
      arg_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    request_args::
    request_args (const request_args& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      arg_ (x.arg_, f, this),
      list_ (x.list_, f, this)
    {
    }

    request_args::
    request_args (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      arg_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void request_args::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // arg
        //
        if (n.name () == "arg" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< arg_type > r (
            arg_traits::create (i, f, this));

          this->arg ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    request_args* request_args::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new request_args (*this, f, c);
    }

    request_args::
    ~request_args ()
    {
    }

    // positions
    //

    positions::
    positions ()
    : ::xml_schema::type (),
      member_type_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    positions::
    positions (const positions& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      member_type_ (x.member_type_, f, this),
      list_ (x.list_, f, this)
    {
    }

    positions::
    positions (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      member_type_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void positions::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // member_type
        //
        if (n.name () == "member_type" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< member_type_type > r (
            member_type_traits::create (i, f, this));

          this->member_type ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    positions* positions::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new positions (*this, f, c);
    }

    positions::
    ~positions ()
    {
    }

    // members
    //

    members::
    members ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    members::
    members (const members& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    members::
    members (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void members::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    members* members::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new members (*this, f, c);
    }

    members::
    ~members ()
    {
    }

    // admins
    //

    admins::
    admins ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    admins::
    admins (const admins& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    admins::
    admins (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void admins::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    admins* admins::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new admins (*this, f, c);
    }

    admins::
    ~admins ()
    {
    }

    // officers
    //

    officers::
    officers ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    officers::
    officers (const officers& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    officers::
    officers (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void officers::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    officers* officers::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new officers (*this, f, c);
    }

    officers::
    ~officers ()
    {
    }

    // not_replied
    //

    not_replied::
    not_replied ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    not_replied::
    not_replied (const not_replied& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    not_replied::
    not_replied (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void not_replied::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    not_replied* not_replied::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new not_replied (*this, f, c);
    }

    not_replied::
    ~not_replied ()
    {
    }

    // attending
    //

    attending::
    attending ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    attending::
    attending (const attending& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    attending::
    attending (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void attending::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    attending* attending::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new attending (*this, f, c);
    }

    attending::
    ~attending ()
    {
    }

    // unsure
    //

    unsure::
    unsure ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    unsure::
    unsure (const unsure& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    unsure::
    unsure (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void unsure::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    unsure* unsure::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new unsure (*this, f, c);
    }

    unsure::
    ~unsure ()
    {
    }

    // declined
    //

    declined::
    declined ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    declined::
    declined (const declined& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    declined::
    declined (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void declined::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    declined* declined::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new declined (*this, f, c);
    }

    declined::
    ~declined ()
    {
    }

    // not_replied1
    //

    not_replied1::
    not_replied1 ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    not_replied1::
    not_replied1 (const not_replied1& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    not_replied1::
    not_replied1 (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void not_replied1::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    not_replied1* not_replied1::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new not_replied1 (*this, f, c);
    }

    not_replied1::
    ~not_replied1 ()
    {
    }

    // friend_requests
    //

    friend_requests::
    friend_requests ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    friend_requests::
    friend_requests (const friend_requests& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    friend_requests::
    friend_requests (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friend_requests::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    friend_requests* friend_requests::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friend_requests (*this, f, c);
    }

    friend_requests::
    ~friend_requests ()
    {
    }

    // group_invites
    //

    group_invites::
    group_invites ()
    : ::xml_schema::type (),
      gid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    group_invites::
    group_invites (const group_invites& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      gid_ (x.gid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    group_invites::
    group_invites (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      gid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void group_invites::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // gid
        //
        if (n.name () == "gid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< gid_type > r (
            gid_traits::create (i, f, this));

          this->gid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    group_invites* group_invites::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new group_invites (*this, f, c);
    }

    group_invites::
    ~group_invites ()
    {
    }

    // event_invites
    //

    event_invites::
    event_invites ()
    : ::xml_schema::type (),
      eid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    event_invites::
    event_invites (const event_invites& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      eid_ (x.eid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    event_invites::
    event_invites (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      eid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void event_invites::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // eid
        //
        if (n.name () == "eid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< eid_type > r (
            eid_traits::create (i, f, this));

          this->eid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    event_invites* event_invites::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new event_invites (*this, f, c);
    }

    event_invites::
    ~event_invites ()
    {
    }

    // concentrations
    //

    concentrations::
    concentrations ()
    : ::xml_schema::type (),
      concentration_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    concentrations::
    concentrations (const concentrations& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      concentration_ (x.concentration_, f, this),
      list_ (x.list_, f, this)
    {
    }

    concentrations::
    concentrations (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      concentration_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void concentrations::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // concentration
        //
        if (n.name () == "concentration" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< concentration_type > r (
            concentration_traits::create (i, f, this));

          this->concentration ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    concentrations* concentrations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new concentrations (*this, f, c);
    }

    concentrations::
    ~concentrations ()
    {
    }

    // affiliations
    //

    affiliations::
    affiliations ()
    : ::xml_schema::type (),
      affiliation_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    affiliations::
    affiliations (const affiliations& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      affiliation_ (x.affiliation_, f, this),
      list_ (x.list_, f, this)
    {
    }

    affiliations::
    affiliations (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      affiliation_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void affiliations::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // affiliation
        //
        if (n.name () == "affiliation" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< affiliation_type > r (
            affiliation_traits::create (i, f, this));

          this->affiliation ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    affiliations* affiliations::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new affiliations (*this, f, c);
    }

    affiliations::
    ~affiliations ()
    {
    }

    // education_history
    //

    education_history::
    education_history ()
    : ::xml_schema::type (),
      education_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    education_history::
    education_history (const education_history& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      education_info_ (x.education_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    education_history::
    education_history (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      education_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void education_history::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // education_info
        //
        if (n.name () == "education_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< education_info_type > r (
            education_info_traits::create (i, f, this));

          this->education_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    education_history* education_history::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new education_history (*this, f, c);
    }

    education_history::
    ~education_history ()
    {
    }

    // meeting_for
    //

    meeting_for::
    meeting_for ()
    : ::xml_schema::type (),
      seeking_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    meeting_for::
    meeting_for (const meeting_for& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      seeking_ (x.seeking_, f, this),
      list_ (x.list_, f, this)
    {
    }

    meeting_for::
    meeting_for (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      seeking_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void meeting_for::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // seeking
        //
        if (n.name () == "seeking" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< seeking_type > r (
            seeking_traits::create (i, f, this));

          this->seeking ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    meeting_for* meeting_for::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new meeting_for (*this, f, c);
    }

    meeting_for::
    ~meeting_for ()
    {
    }

    // meeting_sex
    //

    meeting_sex::
    meeting_sex ()
    : ::xml_schema::type (),
      sex_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    meeting_sex::
    meeting_sex (const meeting_sex& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      sex_ (x.sex_, f, this),
      list_ (x.list_, f, this)
    {
    }

    meeting_sex::
    meeting_sex (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      sex_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void meeting_sex::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // sex
        //
        if (n.name () == "sex" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< sex_type > r (
            sex_traits::create (i, f, this));

          this->sex ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    meeting_sex* meeting_sex::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new meeting_sex (*this, f, c);
    }

    meeting_sex::
    ~meeting_sex ()
    {
    }

    // work_history
    //

    work_history::
    work_history ()
    : ::xml_schema::type (),
      work_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    work_history::
    work_history (const work_history& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      work_info_ (x.work_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    work_history::
    work_history (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      work_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void work_history::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // work_info
        //
        if (n.name () == "work_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< work_info_type > r (
            work_info_traits::create (i, f, this));

          this->work_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    work_history* work_history::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new work_history (*this, f, c);
    }

    work_history::
    ~work_history ()
    {
    }

    // image_urls
    //

    image_urls::
    image_urls ()
    : ::xml_schema::type (),
      image_urls_elt_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    image_urls::
    image_urls (const image_urls& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      image_urls_elt_ (x.image_urls_elt_, f, this),
      list_ (x.list_, f, this)
    {
    }

    image_urls::
    image_urls (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      image_urls_elt_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void image_urls::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // image_urls_elt
        //
        if (n.name () == "image_urls_elt" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< image_urls_elt_type > r (
            image_urls_elt_traits::create (i, f, this));

          this->image_urls_elt ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    image_urls* image_urls::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new image_urls (*this, f, c);
    }

    image_urls::
    ~image_urls ()
    {
    }

    // events_get_response
    //

    events_get_response::
    events_get_response ()
    : ::xml_schema::type (),
      event_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    events_get_response::
    events_get_response (const events_get_response& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      event_ (x.event_, f, this),
      list_ (x.list_, f, this)
    {
    }

    events_get_response::
    events_get_response (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      event_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void events_get_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // event
        //
        if (n.name () == "event" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< event_type > r (
            event_traits::create (i, f, this));

          this->event ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    events_get_response* events_get_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new events_get_response (*this, f, c);
    }

    events_get_response::
    ~events_get_response ()
    {
    }

    // friends_areFriends_response
    //

    friends_areFriends_response::
    friends_areFriends_response ()
    : ::xml_schema::type (),
      friend_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    friends_areFriends_response::
    friends_areFriends_response (const friends_areFriends_response& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      friend_info_ (x.friend_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    friends_areFriends_response::
    friends_areFriends_response (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      friend_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friends_areFriends_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // friend_info
        //
        if (n.name () == "friend_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< friend_info_type > r (
            friend_info_traits::create (i, f, this));

          this->friend_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    friends_areFriends_response* friends_areFriends_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friends_areFriends_response (*this, f, c);
    }

    friends_areFriends_response::
    ~friends_areFriends_response ()
    {
    }

    // friends_get_response
    //

    friends_get_response::
    friends_get_response ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    friends_get_response::
    friends_get_response (const friends_get_response& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    friends_get_response::
    friends_get_response (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friends_get_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    friends_get_response* friends_get_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friends_get_response (*this, f, c);
    }

    friends_get_response::
    ~friends_get_response ()
    {
    }

    // friends_getAppUsers_response
    //

    friends_getAppUsers_response::
    friends_getAppUsers_response ()
    : ::xml_schema::type (),
      uid_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    friends_getAppUsers_response::
    friends_getAppUsers_response (const friends_getAppUsers_response& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      uid_ (x.uid_, f, this),
      list_ (x.list_, f, this)
    {
    }

    friends_getAppUsers_response::
    friends_getAppUsers_response (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      uid_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friends_getAppUsers_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uid
        //
        if (n.name () == "uid" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< uid_type > r (
            uid_traits::create (i, f, this));

          this->uid ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    friends_getAppUsers_response* friends_getAppUsers_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friends_getAppUsers_response (*this, f, c);
    }

    friends_getAppUsers_response::
    ~friends_getAppUsers_response ()
    {
    }

    // friends_getLists_response
    //

    friends_getLists_response::
    friends_getLists_response ()
    : ::xml_schema::type (),
      friendlist_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    friends_getLists_response::
    friends_getLists_response (const friends_getLists_response& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      friendlist_ (x.friendlist_, f, this),
      list_ (x.list_, f, this)
    {
    }

    friends_getLists_response::
    friends_getLists_response (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      friendlist_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void friends_getLists_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // friendlist
        //
        if (n.name () == "friendlist" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< friendlist_type > r (
            friendlist_traits::create (i, f, this));

          this->friendlist ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    friends_getLists_response* friends_getLists_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new friends_getLists_response (*this, f, c);
    }

    friends_getLists_response::
    ~friends_getLists_response ()
    {
    }

    // groups_get_response
    //

    groups_get_response::
    groups_get_response ()
    : ::xml_schema::type (),
      group_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    groups_get_response::
    groups_get_response (const groups_get_response& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      group_ (x.group_, f, this),
      list_ (x.list_, f, this)
    {
    }

    groups_get_response::
    groups_get_response (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      group_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void groups_get_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // group
        //
        if (n.name () == "group" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< group_type > r (
            group_traits::create (i, f, this));

          this->group ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    groups_get_response* groups_get_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new groups_get_response (*this, f, c);
    }

    groups_get_response::
    ~groups_get_response ()
    {
    }

    // data_getCookies_response
    //

    data_getCookies_response::
    data_getCookies_response ()
    : ::xml_schema::type (),
      cookie_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getCookies_response::
    data_getCookies_response (const data_getCookies_response& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cookie_ (x.cookie_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getCookies_response::
    data_getCookies_response (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cookie_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getCookies_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // cookie
        //
        if (n.name () == "cookie" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< cookie_type > r (
            cookie_traits::create (i, f, this));

          this->cookie ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getCookies_response* data_getCookies_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getCookies_response (*this, f, c);
    }

    data_getCookies_response::
    ~data_getCookies_response ()
    {
    }

    // marketplace_getCategories_response
    //

    marketplace_getCategories_response::
    marketplace_getCategories_response ()
    : ::xml_schema::type (),
      marketplace_category_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    marketplace_getCategories_response::
    marketplace_getCategories_response (const marketplace_getCategories_response& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      marketplace_category_ (x.marketplace_category_, f, this),
      list_ (x.list_, f, this)
    {
    }

    marketplace_getCategories_response::
    marketplace_getCategories_response (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      marketplace_category_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void marketplace_getCategories_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // marketplace_category
        //
        if (n.name () == "marketplace_category" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< marketplace_category_type > r (
            marketplace_category_traits::create (i, f, this));

          this->marketplace_category ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    marketplace_getCategories_response* marketplace_getCategories_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_getCategories_response (*this, f, c);
    }

    marketplace_getCategories_response::
    ~marketplace_getCategories_response ()
    {
    }

    // marketplace_getSubCategories_response
    //

    marketplace_getSubCategories_response::
    marketplace_getSubCategories_response ()
    : ::xml_schema::type (),
      marketplace_subcategory_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    marketplace_getSubCategories_response::
    marketplace_getSubCategories_response (const marketplace_getSubCategories_response& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      marketplace_subcategory_ (x.marketplace_subcategory_, f, this),
      list_ (x.list_, f, this)
    {
    }

    marketplace_getSubCategories_response::
    marketplace_getSubCategories_response (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      marketplace_subcategory_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void marketplace_getSubCategories_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // marketplace_subcategory
        //
        if (n.name () == "marketplace_subcategory" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< marketplace_subcategory_type > r (
            marketplace_subcategory_traits::create (i, f, this));

          this->marketplace_subcategory ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    marketplace_getSubCategories_response* marketplace_getSubCategories_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_getSubCategories_response (*this, f, c);
    }

    marketplace_getSubCategories_response::
    ~marketplace_getSubCategories_response ()
    {
    }

    // marketplace_getListings_response
    //

    marketplace_getListings_response::
    marketplace_getListings_response ()
    : ::xml_schema::type (),
      listing_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    marketplace_getListings_response::
    marketplace_getListings_response (const marketplace_getListings_response& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      listing_ (x.listing_, f, this),
      list_ (x.list_, f, this)
    {
    }

    marketplace_getListings_response::
    marketplace_getListings_response (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      listing_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void marketplace_getListings_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // listing
        //
        if (n.name () == "listing" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< listing_type > r (
            listing_traits::create (i, f, this));

          this->listing ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    marketplace_getListings_response* marketplace_getListings_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_getListings_response (*this, f, c);
    }

    marketplace_getListings_response::
    ~marketplace_getListings_response ()
    {
    }

    // marketplace_search_response
    //

    marketplace_search_response::
    marketplace_search_response ()
    : ::xml_schema::type (),
      listing_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    marketplace_search_response::
    marketplace_search_response (const marketplace_search_response& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      listing_ (x.listing_, f, this),
      list_ (x.list_, f, this)
    {
    }

    marketplace_search_response::
    marketplace_search_response (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      listing_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void marketplace_search_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // listing
        //
        if (n.name () == "listing" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< listing_type > r (
            listing_traits::create (i, f, this));

          this->listing ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    marketplace_search_response* marketplace_search_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new marketplace_search_response (*this, f, c);
    }

    marketplace_search_response::
    ~marketplace_search_response ()
    {
    }

    // photos_get_response
    //

    photos_get_response::
    photos_get_response ()
    : ::xml_schema::type (),
      photo_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    photos_get_response::
    photos_get_response (const photos_get_response& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      photo_ (x.photo_, f, this),
      list_ (x.list_, f, this)
    {
    }

    photos_get_response::
    photos_get_response (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      photo_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void photos_get_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // photo
        //
        if (n.name () == "photo" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< photo_type > r (
            photo_traits::create (i, f, this));

          this->photo ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    photos_get_response* photos_get_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new photos_get_response (*this, f, c);
    }

    photos_get_response::
    ~photos_get_response ()
    {
    }

    // photos_getAlbums_response
    //

    photos_getAlbums_response::
    photos_getAlbums_response ()
    : ::xml_schema::type (),
      album_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    photos_getAlbums_response::
    photos_getAlbums_response (const photos_getAlbums_response& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      album_ (x.album_, f, this),
      list_ (x.list_, f, this)
    {
    }

    photos_getAlbums_response::
    photos_getAlbums_response (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      album_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void photos_getAlbums_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // album
        //
        if (n.name () == "album" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< album_type > r (
            album_traits::create (i, f, this));

          this->album ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    photos_getAlbums_response* photos_getAlbums_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new photos_getAlbums_response (*this, f, c);
    }

    photos_getAlbums_response::
    ~photos_getAlbums_response ()
    {
    }

    // photos_getTags_response
    //

    photos_getTags_response::
    photos_getTags_response ()
    : ::xml_schema::type (),
      photo_tag_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    photos_getTags_response::
    photos_getTags_response (const photos_getTags_response& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      photo_tag_ (x.photo_tag_, f, this),
      list_ (x.list_, f, this)
    {
    }

    photos_getTags_response::
    photos_getTags_response (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      photo_tag_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void photos_getTags_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // photo_tag
        //
        if (n.name () == "photo_tag" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< photo_tag_type > r (
            photo_tag_traits::create (i, f, this));

          this->photo_tag ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    photos_getTags_response* photos_getTags_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new photos_getTags_response (*this, f, c);
    }

    photos_getTags_response::
    ~photos_getTags_response ()
    {
    }

    // update_decodeIDs_response
    //

    update_decodeIDs_response::
    update_decodeIDs_response ()
    : ::xml_schema::type (),
      id_map_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    update_decodeIDs_response::
    update_decodeIDs_response (const update_decodeIDs_response& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_map_ (x.id_map_, f, this),
      list_ (x.list_, f, this)
    {
    }

    update_decodeIDs_response::
    update_decodeIDs_response (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_map_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void update_decodeIDs_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id_map
        //
        if (n.name () == "id_map" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< id_map_type > r (
            id_map_traits::create (i, f, this));

          this->id_map ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    update_decodeIDs_response* update_decodeIDs_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new update_decodeIDs_response (*this, f, c);
    }

    update_decodeIDs_response::
    ~update_decodeIDs_response ()
    {
    }

    // users_getInfo_response
    //

    users_getInfo_response::
    users_getInfo_response ()
    : ::xml_schema::type (),
      user_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    users_getInfo_response::
    users_getInfo_response (const users_getInfo_response& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      user_ (x.user_, f, this),
      list_ (x.list_, f, this)
    {
    }

    users_getInfo_response::
    users_getInfo_response (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      user_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void users_getInfo_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // user
        //
        if (n.name () == "user" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< user_type > r (
            user_traits::create (i, f, this));

          this->user ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    users_getInfo_response* users_getInfo_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new users_getInfo_response (*this, f, c);
    }

    users_getInfo_response::
    ~users_getInfo_response ()
    {
    }

    // pages_getInfo_response
    //

    pages_getInfo_response::
    pages_getInfo_response ()
    : ::xml_schema::type (),
      page_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    pages_getInfo_response::
    pages_getInfo_response (const pages_getInfo_response& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      page_ (x.page_, f, this),
      list_ (x.list_, f, this)
    {
    }

    pages_getInfo_response::
    pages_getInfo_response (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      page_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void pages_getInfo_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // page
        //
        if (n.name () == "page" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< page_type > r (
            page_traits::create (i, f, this));

          this->page ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    pages_getInfo_response* pages_getInfo_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new pages_getInfo_response (*this, f, c);
    }

    pages_getInfo_response::
    ~pages_getInfo_response ()
    {
    }

    // data_getUserPreferences_response
    //

    data_getUserPreferences_response::
    data_getUserPreferences_response ()
    : ::xml_schema::type (),
      preference_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getUserPreferences_response::
    data_getUserPreferences_response (const data_getUserPreferences_response& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      preference_ (x.preference_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getUserPreferences_response::
    data_getUserPreferences_response (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      preference_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getUserPreferences_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // preference
        //
        if (n.name () == "preference" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< preference_type > r (
            preference_traits::create (i, f, this));

          this->preference ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getUserPreferences_response* data_getUserPreferences_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getUserPreferences_response (*this, f, c);
    }

    data_getUserPreferences_response::
    ~data_getUserPreferences_response ()
    {
    }

    // data_getObjectTypes_response
    //

    data_getObjectTypes_response::
    data_getObjectTypes_response ()
    : ::xml_schema::type (),
      object_type_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getObjectTypes_response::
    data_getObjectTypes_response (const data_getObjectTypes_response& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      object_type_info_ (x.object_type_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getObjectTypes_response::
    data_getObjectTypes_response (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      object_type_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getObjectTypes_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // object_type_info
        //
        if (n.name () == "object_type_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_type_info_type > r (
            object_type_info_traits::create (i, f, this));

          this->object_type_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getObjectTypes_response* data_getObjectTypes_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getObjectTypes_response (*this, f, c);
    }

    data_getObjectTypes_response::
    ~data_getObjectTypes_response ()
    {
    }

    // data_getObjectType_response
    //

    data_getObjectType_response::
    data_getObjectType_response ()
    : ::xml_schema::type (),
      object_property_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getObjectType_response::
    data_getObjectType_response (const data_getObjectType_response& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      object_property_info_ (x.object_property_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getObjectType_response::
    data_getObjectType_response (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      object_property_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getObjectType_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // object_property_info
        //
        if (n.name () == "object_property_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_property_info_type > r (
            object_property_info_traits::create (i, f, this));

          this->object_property_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getObjectType_response* data_getObjectType_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getObjectType_response (*this, f, c);
    }

    data_getObjectType_response::
    ~data_getObjectType_response ()
    {
    }

    // data_getObjects_response
    //

    data_getObjects_response::
    data_getObjects_response ()
    : ::xml_schema::type (),
      data_getObjects_response_elt_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getObjects_response::
    data_getObjects_response (const data_getObjects_response& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      data_getObjects_response_elt_ (x.data_getObjects_response_elt_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getObjects_response::
    data_getObjects_response (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      data_getObjects_response_elt_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getObjects_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // data_getObjects_response_elt
        //
        if (n.name () == "data_getObjects_response_elt" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< data_getObjects_response_elt_type > r (
            data_getObjects_response_elt_traits::create (i, f, this));

          this->data_getObjects_response_elt ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getObjects_response* data_getObjects_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getObjects_response (*this, f, c);
    }

    data_getObjects_response::
    ~data_getObjects_response ()
    {
    }

    // data_getAssociationDefinitions_response
    //

    data_getAssociationDefinitions_response::
    data_getAssociationDefinitions_response ()
    : ::xml_schema::type (),
      object_assoc_info_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getAssociationDefinitions_response::
    data_getAssociationDefinitions_response (const data_getAssociationDefinitions_response& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      object_assoc_info_ (x.object_assoc_info_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getAssociationDefinitions_response::
    data_getAssociationDefinitions_response (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      object_assoc_info_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getAssociationDefinitions_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // object_assoc_info
        //
        if (n.name () == "object_assoc_info" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_assoc_info_type > r (
            object_assoc_info_traits::create (i, f, this));

          this->object_assoc_info ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getAssociationDefinitions_response* data_getAssociationDefinitions_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getAssociationDefinitions_response (*this, f, c);
    }

    data_getAssociationDefinitions_response::
    ~data_getAssociationDefinitions_response ()
    {
    }

    // data_getAssociatedObjects_response
    //

    data_getAssociatedObjects_response::
    data_getAssociatedObjects_response ()
    : ::xml_schema::type (),
      object_association_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getAssociatedObjects_response::
    data_getAssociatedObjects_response (const data_getAssociatedObjects_response& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      object_association_ (x.object_association_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getAssociatedObjects_response::
    data_getAssociatedObjects_response (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      object_association_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getAssociatedObjects_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // object_association
        //
        if (n.name () == "object_association" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_association_type > r (
            object_association_traits::create (i, f, this));

          this->object_association ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getAssociatedObjects_response* data_getAssociatedObjects_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getAssociatedObjects_response (*this, f, c);
    }

    data_getAssociatedObjects_response::
    ~data_getAssociatedObjects_response ()
    {
    }

    // data_getAssociatedObjectCounts_response
    //

    data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response ()
    : ::xml_schema::type (),
      data_getAssociatedObjectCounts_response_elt_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response (const data_getAssociatedObjectCounts_response& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      data_getAssociatedObjectCounts_response_elt_ (x.data_getAssociatedObjectCounts_response_elt_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getAssociatedObjectCounts_response::
    data_getAssociatedObjectCounts_response (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      data_getAssociatedObjectCounts_response_elt_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getAssociatedObjectCounts_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // data_getAssociatedObjectCounts_response_elt
        //
        if (n.name () == "data_getAssociatedObjectCounts_response_elt" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          this->data_getAssociatedObjectCounts_response_elt ().push_back (data_getAssociatedObjectCounts_response_elt_traits::create (i, f, this));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getAssociatedObjectCounts_response* data_getAssociatedObjectCounts_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getAssociatedObjectCounts_response (*this, f, c);
    }

    data_getAssociatedObjectCounts_response::
    ~data_getAssociatedObjectCounts_response ()
    {
    }

    // data_getAssociations_response
    //

    data_getAssociations_response::
    data_getAssociations_response ()
    : ::xml_schema::type (),
      object_association_ (::xml_schema::flags (), this),
      list_ (::xml_schema::flags (), this)
    {
    }

    data_getAssociations_response::
    data_getAssociations_response (const data_getAssociations_response& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      object_association_ (x.object_association_, f, this),
      list_ (x.list_, f, this)
    {
    }

    data_getAssociations_response::
    data_getAssociations_response (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      object_association_ (f, this),
      list_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);
        this->parse (p, f);
      }
    }

    void data_getAssociations_response::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // object_association
        //
        if (n.name () == "object_association" && n.namespace_ () == "http://api.facebook.com/1.0/")
        {
          ::std::auto_ptr< object_association_type > r (
            object_association_traits::create (i, f, this));

          this->object_association ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "list" && n.namespace_ ().empty ())
        {
          this->list (list_traits::create (i, f, this));
          continue;
        }
      }
    }

    data_getAssociations_response* data_getAssociations_response::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new data_getAssociations_response (*this, f, c);
    }

    data_getAssociations_response::
    ~data_getAssociations_response ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace FacebookCpp
{
  namespace XSD
  {
    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (const ::std::string& u,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (::std::istream& is,
                               const ::std::string& sid,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_createToken_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (xercesc::InputSource& i,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
        ::FacebookCpp::XSD::auth_createToken_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (const xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
          ::FacebookCpp::XSD::auth_createToken_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "auth_createToken_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::auth_token, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "auth_createToken_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::auth_token >
    auth_createToken_response (xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "auth_createToken_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::auth_token > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::auth_token, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "auth_createToken_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (const ::std::string& u,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (::std::istream& is,
                              const ::std::string& sid,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::auth_getSession_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (xercesc::InputSource& i,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
        ::FacebookCpp::XSD::auth_getSession_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (const xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
          ::FacebookCpp::XSD::auth_getSession_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "auth_getSession_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::session_info, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "auth_getSession_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::session_info >
    auth_getSession_response (xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "auth_getSession_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::session_info > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::session_info, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "auth_getSession_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (const ::std::string& u,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (xercesc::InputSource& i,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
        ::FacebookCpp::XSD::events_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (const xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
          ::FacebookCpp::XSD::events_get_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "events_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::events_get_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "events_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response >
    events_get_response_ (xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "events_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::events_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::events_get_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "events_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::events_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
        ::FacebookCpp::XSD::events_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
          ::FacebookCpp::XSD::events_getMembers_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "events_getMembers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::event_members, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "events_getMembers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::event_members >
    events_getMembers_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "events_getMembers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::event_members > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::event_members, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "events_getMembers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_setRefHandle_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_setRefHandle_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::fbml_setRefHandle_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_setRefHandle_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_setRefHandle_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_setRefHandle_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_setRefHandle_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_setRefHandle_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshRefUrl_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::fbml_refreshRefUrl_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_refreshRefUrl_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_refreshRefUrl_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshRefUrl_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_refreshRefUrl_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_refreshRefUrl_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_refreshImgSrc_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::fbml_refreshImgSrc_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_refreshImgSrc_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_refreshImgSrc_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_refreshImgSrc_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_refreshImgSrc_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_refreshImgSrc_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (const ::std::string& u,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (::std::istream& is,
                                       const ::std::string& sid,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (xercesc::InputSource& i,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (const xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::fbml_uploadNativeStrings_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_uploadNativeStrings_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_uploadNativeStrings_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    fbml_uploadNativeStrings_response (xercesc::DOMDocument* d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "fbml_uploadNativeStrings_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "fbml_uploadNativeStrings_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (const ::std::string& u,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (::std::istream& is,
                                      const ::std::string& sid,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishStoryToUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (xercesc::InputSource& i,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishStoryToUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (const xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::feed_publishStoryToUser_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "feed_publishStoryToUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "feed_publishStoryToUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishStoryToUser_response (xercesc::DOMDocument* d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "feed_publishStoryToUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "feed_publishStoryToUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (const ::std::string& u,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (::std::istream& is,
                                       const ::std::string& sid,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::feed_publishActionOfUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (xercesc::InputSource& i,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::feed_publishActionOfUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (const xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::feed_publishActionOfUser_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "feed_publishActionOfUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "feed_publishActionOfUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    feed_publishActionOfUser_response (xercesc::DOMDocument* d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "feed_publishActionOfUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "feed_publishActionOfUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_areFriends_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
        ::FacebookCpp::XSD::friends_areFriends_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
          ::FacebookCpp::XSD::friends_areFriends_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_areFriends_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_areFriends_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_areFriends_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response >
    friends_areFriends_response_ (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_areFriends_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_areFriends_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_areFriends_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_areFriends_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (const ::std::string& u,
                           xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (::std::istream& is,
                           const ::std::string& sid,
                           xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (xercesc::InputSource& i,
                           xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
        ::FacebookCpp::XSD::friends_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (const xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
          ::FacebookCpp::XSD::friends_get_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_get_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response >
    friends_get_response_ (xercesc::DOMDocument* d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_get_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (const ::std::string& u,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getAppUsers_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (xercesc::InputSource& i,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
        ::FacebookCpp::XSD::friends_getAppUsers_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (const xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
          ::FacebookCpp::XSD::friends_getAppUsers_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_getAppUsers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_getAppUsers_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_getAppUsers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response >
    friends_getAppUsers_response_ (xercesc::DOMDocument* d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_getAppUsers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getAppUsers_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_getAppUsers_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_getAppUsers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::friends_getLists_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
        ::FacebookCpp::XSD::friends_getLists_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
          ::FacebookCpp::XSD::friends_getLists_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_getLists_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_getLists_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_getLists_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response >
    friends_getLists_response_ (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "friends_getLists_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::friends_getLists_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::friends_getLists_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "friends_getLists_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (const ::std::string& u,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (xercesc::InputSource& i,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
        ::FacebookCpp::XSD::groups_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (const xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
          ::FacebookCpp::XSD::groups_get_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "groups_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::groups_get_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "groups_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response >
    groups_get_response_ (xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "groups_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::groups_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::groups_get_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "groups_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::groups_getMembers_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
        ::FacebookCpp::XSD::groups_getMembers_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
          ::FacebookCpp::XSD::groups_getMembers_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "groups_getMembers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::group_members, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "groups_getMembers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::group_members >
    groups_getMembers_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "groups_getMembers_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::group_members > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::group_members, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "groups_getMembers_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (const ::std::string& u,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (::std::istream& is,
                               const ::std::string& sid,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getCookies_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (xercesc::InputSource& i,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
        ::FacebookCpp::XSD::data_getCookies_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (const xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
          ::FacebookCpp::XSD::data_getCookies_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getCookies_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getCookies_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getCookies_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response >
    data_getCookies_response_ (xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getCookies_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getCookies_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getCookies_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getCookies_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (const ::std::string& u,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (::std::istream& is,
                             const ::std::string& sid,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setCookie_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (xercesc::InputSource& i,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setCookie_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (const xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setCookie_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setCookie_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setCookie_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setCookie_response (xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setCookie_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setCookie_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (const ::std::string& u,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (const ::std::string& u,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (const ::std::string& u,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (xercesc::InputSource& i,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (xercesc::InputSource& i,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (xercesc::InputSource& i,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (const xercesc::DOMDocument& d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
          ::FacebookCpp::XSD::marketplace_getCategories_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getCategories_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getCategories_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getCategories_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response >
    marketplace_getCategories_response_ (xercesc::DOMDocument* d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getCategories_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getCategories_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getCategories_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getCategories_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (const ::std::string& u,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (const ::std::string& u,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (const ::std::string& u,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (::std::istream& is,
                                            const ::std::string& sid,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (xercesc::InputSource& i,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (xercesc::InputSource& i,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (xercesc::InputSource& i,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
        ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (const xercesc::DOMDocument& d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
          ::FacebookCpp::XSD::marketplace_getSubCategories_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getSubCategories_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getSubCategories_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getSubCategories_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response >
    marketplace_getSubCategories_response_ (xercesc::DOMDocument* d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getSubCategories_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getSubCategories_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getSubCategories_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getSubCategories_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (const ::std::string& u,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_getListings_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (xercesc::InputSource& i,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
        ::FacebookCpp::XSD::marketplace_getListings_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (const xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
          ::FacebookCpp::XSD::marketplace_getListings_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getListings_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getListings_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getListings_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response >
    marketplace_getListings_response_ (xercesc::DOMDocument* d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_getListings_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_getListings_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_getListings_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_getListings_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_search_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
        ::FacebookCpp::XSD::marketplace_search_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
          ::FacebookCpp::XSD::marketplace_search_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_search_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_search_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_search_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response >
    marketplace_search_response_ (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_search_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::marketplace_search_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::marketplace_search_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_search_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (const ::std::string& u,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_createListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (xercesc::InputSource& i,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
        ::FacebookCpp::XSD::marketplace_createListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (const xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
          ::FacebookCpp::XSD::marketplace_createListing_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_createListing_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::lid, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_createListing_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::lid >
    marketplace_createListing_response (xercesc::DOMDocument* d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_createListing_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::lid > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::lid, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_createListing_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (const ::std::string& u,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (::std::istream& is,
                                        const ::std::string& sid,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::marketplace_removeListing_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (xercesc::InputSource& i,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::marketplace_removeListing_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (const xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::marketplace_removeListing_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_removeListing_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_removeListing_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    marketplace_removeListing_response (xercesc::DOMDocument* d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "marketplace_removeListing_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "marketplace_removeListing_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_get_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
        ::FacebookCpp::XSD::notifications_get_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
          ::FacebookCpp::XSD::notifications_get_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::notifications, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::notifications >
    notifications_get_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::notifications > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::notifications, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_send_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::notifications_send_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::notifications_send_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_send_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_send_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    notifications_send_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_send_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_send_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (const ::std::string& u,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (::std::istream& is,
                                      const ::std::string& sid,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::notifications_sendEmail_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (xercesc::InputSource& i,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
        ::FacebookCpp::XSD::notifications_sendEmail_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (const xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
          ::FacebookCpp::XSD::notifications_sendEmail_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_sendEmail_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::uid_list, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_sendEmail_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid_list >
    notifications_sendEmail_response (xercesc::DOMDocument* d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "notifications_sendEmail_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::uid_list > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::uid_list, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "notifications_sendEmail_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (const ::std::string& u,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (::std::istream& is,
                          const ::std::string& sid,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_get_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (xercesc::InputSource& i,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
        ::FacebookCpp::XSD::photos_get_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (const xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
          ::FacebookCpp::XSD::photos_get_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_get_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response >
    photos_get_response_ (xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_get_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_get_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_get_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_get_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getAlbums_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
        ::FacebookCpp::XSD::photos_getAlbums_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
          ::FacebookCpp::XSD::photos_getAlbums_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_getAlbums_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_getAlbums_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_getAlbums_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response >
    photos_getAlbums_response_ (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_getAlbums_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getAlbums_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_getAlbums_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_getAlbums_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (const ::std::string& u,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (::std::istream& is,
                              const ::std::string& sid,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_getTags_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (xercesc::InputSource& i,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
        ::FacebookCpp::XSD::photos_getTags_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (const xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
          ::FacebookCpp::XSD::photos_getTags_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_getTags_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_getTags_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_getTags_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response >
    photos_getTags_response_ (xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_getTags_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photos_getTags_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photos_getTags_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_getTags_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_createAlbum_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
        ::FacebookCpp::XSD::photos_createAlbum_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
          ::FacebookCpp::XSD::photos_createAlbum_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_createAlbum_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::album, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_createAlbum_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::album >
    photos_createAlbum_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_createAlbum_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::album > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::album, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_createAlbum_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (const ::std::string& u,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (::std::istream& is,
                            const ::std::string& sid,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_upload_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (xercesc::InputSource& i,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
        ::FacebookCpp::XSD::photos_upload_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (const xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
          ::FacebookCpp::XSD::photos_upload_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_upload_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photo, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_upload_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::photo >
    photos_upload_response (xercesc::DOMDocument* d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_upload_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::photo > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::photo, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_upload_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (const ::std::string& u,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (::std::istream& is,
                            const ::std::string& sid,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::photos_addTag_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (xercesc::InputSource& i,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::photos_addTag_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (const xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::photos_addTag_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_addTag_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_addTag_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    photos_addTag_response (xercesc::DOMDocument* d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "photos_addTag_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "photos_addTag_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (const ::std::string& u,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_setFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (xercesc::InputSource& i,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::profile_setFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (const xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::profile_setFBML_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "profile_setFBML_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "profile_setFBML_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    profile_setFBML_response (xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "profile_setFBML_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "profile_setFBML_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (const ::std::string& u,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (::std::istream& is,
                              const ::std::string& sid,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::profile_getFBML_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (xercesc::InputSource& i,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::profile_getFBML_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (const xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::profile_getFBML_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "profile_getFBML_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "profile_getFBML_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    profile_getFBML_response (xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "profile_getFBML_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "profile_getFBML_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::update_decodeIDs_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
        ::FacebookCpp::XSD::update_decodeIDs_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
          ::FacebookCpp::XSD::update_decodeIDs_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "update_decodeIDs_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::update_decodeIDs_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "update_decodeIDs_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response >
    update_decodeIDs_response_ (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "update_decodeIDs_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::update_decodeIDs_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::update_decodeIDs_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "update_decodeIDs_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (const ::std::string& u,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (xercesc::InputSource& i,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
        ::FacebookCpp::XSD::users_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (const xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
          ::FacebookCpp::XSD::users_getInfo_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_getInfo_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::users_getInfo_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_getInfo_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response >
    users_getInfo_response_ (xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_getInfo_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::users_getInfo_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::users_getInfo_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_getInfo_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (const ::std::string& u,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (xercesc::InputSource& i,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (const xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::users_isAppAdded_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_isAppAdded_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_isAppAdded_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_isAppAdded_response (xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_isAppAdded_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_isAppAdded_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_hasAppPermission_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_hasAppPermission_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::users_hasAppPermission_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_hasAppPermission_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_hasAppPermission_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_hasAppPermission_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_hasAppPermission_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_hasAppPermission_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (const ::std::string& u,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (::std::istream& is,
                                    const ::std::string& sid,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_getLoggedInUser_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (xercesc::InputSource& i,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
        ::FacebookCpp::XSD::users_getLoggedInUser_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (const xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
          ::FacebookCpp::XSD::users_getLoggedInUser_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_getLoggedInUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::uid, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_getLoggedInUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::uid >
    users_getLoggedInUser_response (xercesc::DOMDocument* d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_getLoggedInUser_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::uid > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::uid, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_getLoggedInUser_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (const ::std::string& u,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (::std::istream& is,
                              const ::std::string& sid,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::users_setStatus_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (xercesc::InputSource& i,
                              xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::users_setStatus_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (const xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::users_setStatus_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_setStatus_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_setStatus_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    users_setStatus_response (xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "users_setStatus_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "users_setStatus_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (const ::std::string& u,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (::std::istream& is,
                             const ::std::string& sid,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_getInfo_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (xercesc::InputSource& i,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
        ::FacebookCpp::XSD::pages_getInfo_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (const xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
          ::FacebookCpp::XSD::pages_getInfo_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_getInfo_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::pages_getInfo_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_getInfo_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response >
    pages_getInfo_response_ (xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_getInfo_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::pages_getInfo_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::pages_getInfo_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_getInfo_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (const ::std::string& u,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (::std::istream& is,
                            const ::std::string& sid,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAdmin_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (xercesc::InputSource& i,
                            xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAdmin_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (const xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::pages_isAdmin_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isAdmin_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isAdmin_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAdmin_response (xercesc::DOMDocument* d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isAdmin_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isAdmin_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (const ::std::string& u,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (::std::istream& is,
                          const ::std::string& sid,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isFan_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (xercesc::InputSource& i,
                          xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isFan_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (const xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::pages_isFan_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isFan_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isFan_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isFan_response (xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isFan_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isFan_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (const ::std::string& u,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (::std::istream& is,
                               const ::std::string& sid,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::pages_isAppAdded_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (xercesc::InputSource& i,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::pages_isAppAdded_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (const xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::pages_isAppAdded_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isAppAdded_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isAppAdded_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    pages_isAppAdded_response (xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "pages_isAppAdded_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "pages_isAppAdded_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setUserPreference_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setUserPreference_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setUserPreference_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreference_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setUserPreference_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setUserPreference_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (const ::std::string& u,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (::std::istream& is,
                                      const ::std::string& sid,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setUserPreferences_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (xercesc::InputSource& i,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setUserPreferences_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (const xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setUserPreferences_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setUserPreferences_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setUserPreferences_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setUserPreferences_response (xercesc::DOMDocument* d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setUserPreferences_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setUserPreferences_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreference_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getUserPreference_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::data_getUserPreference_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getUserPreference_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getUserPreference_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getUserPreference_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getUserPreference_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getUserPreference_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (const ::std::string& u,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (::std::istream& is,
                                       const ::std::string& sid,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getUserPreferences_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (xercesc::InputSource& i,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
        ::FacebookCpp::XSD::data_getUserPreferences_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (const xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
          ::FacebookCpp::XSD::data_getUserPreferences_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getUserPreferences_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getUserPreferences_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getUserPreferences_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response >
    data_getUserPreferences_response_ (xercesc::DOMDocument* d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getUserPreferences_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getUserPreferences_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getUserPreferences_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getUserPreferences_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (const ::std::string& u,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (xercesc::InputSource& i,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_createObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (const xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_createObjectType_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_createObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_createObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_createObjectType_response (xercesc::DOMDocument* d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_createObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_createObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_dropObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_dropObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_dropObjectType_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_dropObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_dropObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_dropObjectType_response (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_dropObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_dropObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (const ::std::string& u,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (::std::istream& is,
                                    const ::std::string& sid,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectType_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (xercesc::InputSource& i,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectType_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (const xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_renameObjectType_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectType_response (xercesc::DOMDocument* d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (const ::std::string& u,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (xercesc::InputSource& i,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (const xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_defineObjectProperty_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_defineObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_defineObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineObjectProperty_response (xercesc::DOMDocument* d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_defineObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_defineObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (const ::std::string& u,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (const ::std::string& u,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (const ::std::string& u,
                                          xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (::std::istream& is,
                                          const ::std::string& sid,
                                          xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (xercesc::InputSource& i,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (xercesc::InputSource& i,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (xercesc::InputSource& i,
                                          xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (const xercesc::DOMDocument& d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_undefineObjectProperty_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_undefineObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_undefineObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineObjectProperty_response (xercesc::DOMDocument* d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_undefineObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_undefineObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (const ::std::string& u,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (::std::istream& is,
                                        const ::std::string& sid,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (xercesc::InputSource& i,
                                        xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (const xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_renameObjectProperty_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameObjectProperty_response (xercesc::DOMDocument* d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (const ::std::string& u,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (::std::istream& is,
                                   const ::std::string& sid,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectTypes_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (xercesc::InputSource& i,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
        ::FacebookCpp::XSD::data_getObjectTypes_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (const xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
          ::FacebookCpp::XSD::data_getObjectTypes_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectTypes_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjectTypes_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectTypes_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response >
    data_getObjectTypes_response_ (xercesc::DOMDocument* d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectTypes_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectTypes_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjectTypes_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectTypes_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectType_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
        ::FacebookCpp::XSD::data_getObjectType_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
          ::FacebookCpp::XSD::data_getObjectType_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjectType_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response >
    data_getObjectType_response_ (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectType_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjectType_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjectType_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectType_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_createObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_createObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::long_ > r (
          ::FacebookCpp::XSD::data_createObject_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_createObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::long_ > r (
          new ::xml_schema::long_ (
            ::xsd::cxx::tree::traits< ::xml_schema::long_, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_createObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_createObject_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_createObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::long_ > r (
          new ::xml_schema::long_ (
            ::xsd::cxx::tree::traits< ::xml_schema::long_, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_createObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_updateObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_updateObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_updateObject_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_updateObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_updateObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_updateObject_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_updateObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_updateObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_deleteObject_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_deleteObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_deleteObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObject_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_deleteObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_deleteObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_deleteObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_deleteObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_deleteObjects_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_deleteObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_deleteObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_deleteObjects_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_deleteObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_deleteObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (const ::std::string& u,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (::std::istream& is,
                             const ::std::string& sid,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObject_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (xercesc::InputSource& i,
                             xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
        ::FacebookCpp::XSD::data_getObject_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (const xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
          ::FacebookCpp::XSD::data_getObject_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::container, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::container >
    data_getObject_response (xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObject_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::container > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::container, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObject_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (const ::std::string& u,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (::std::istream& is,
                               const ::std::string& sid,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (xercesc::InputSource& i,
                               xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
        ::FacebookCpp::XSD::data_getObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (const xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
          ::FacebookCpp::XSD::data_getObjects_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjects_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response >
    data_getObjects_response_ (xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getObjects_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getObjects_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::data_getObjectProperty_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getObjectProperty_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setObjectProperty_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setObjectProperty_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setObjectProperty_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setObjectProperty_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setObjectProperty_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setObjectProperty_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::data_getHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::data_getHashValue_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    data_getHashValue_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::long_ > r (
        ::FacebookCpp::XSD::data_setHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::long_ > r (
          ::FacebookCpp::XSD::data_setHashValue_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::long_ > r (
          new ::xml_schema::long_ (
            ::xsd::cxx::tree::traits< ::xml_schema::long_, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::long_ >
    data_setHashValue_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::long_ > r (
          new ::xml_schema::long_ (
            ::xsd::cxx::tree::traits< ::xml_schema::long_, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (const ::std::string& u,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (::std::istream& is,
                                const ::std::string& sid,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_incHashValue_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (xercesc::InputSource& i,
                                xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_incHashValue_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (const xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::int_ > r (
          ::FacebookCpp::XSD::data_incHashValue_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_incHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::int_ > r (
          new ::xml_schema::int_ (
            ::xsd::cxx::tree::traits< ::xml_schema::int_, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_incHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_incHashValue_response (xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_incHashValue_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::int_ > r (
          new ::xml_schema::int_ (
            ::xsd::cxx::tree::traits< ::xml_schema::int_, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_incHashValue_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (const ::std::string& u,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (::std::istream& is,
                                 const ::std::string& sid,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKey_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (xercesc::InputSource& i,
                                 xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKey_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (const xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_removeHashKey_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeHashKey_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeHashKey_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKey_response (xercesc::DOMDocument* d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeHashKey_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeHashKey_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeHashKeys_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeHashKeys_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_removeHashKeys_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeHashKeys_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeHashKeys_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeHashKeys_response (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeHashKeys_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeHashKeys_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_defineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_defineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_defineAssociation_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_defineAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_defineAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_defineAssociation_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_defineAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_defineAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (const ::std::string& u,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (::std::istream& is,
                                       const ::std::string& sid,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_undefineAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (xercesc::InputSource& i,
                                       xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_undefineAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (const xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_undefineAssociation_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_undefineAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_undefineAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_undefineAssociation_response (xercesc::DOMDocument* d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_undefineAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_undefineAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_renameAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_renameAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_renameAssociation_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_renameAssociation_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_renameAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_renameAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (const ::std::string& u,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (const ::std::string& u,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (const ::std::string& u,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (::std::istream& is,
                                            const ::std::string& sid,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinition_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (xercesc::InputSource& i,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (xercesc::InputSource& i,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (xercesc::InputSource& i,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
        ::FacebookCpp::XSD::data_getAssociationDefinition_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (const xercesc::DOMDocument& d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
          ::FacebookCpp::XSD::data_getAssociationDefinition_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociationDefinition_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::object_assoc_info, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociationDefinition_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info >
    data_getAssociationDefinition_response (xercesc::DOMDocument* d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociationDefinition_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::object_assoc_info > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::object_assoc_info, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociationDefinition_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (const ::std::string& u,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (const ::std::string& u,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (const ::std::string& u,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (xercesc::InputSource& i,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (xercesc::InputSource& i,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (xercesc::InputSource& i,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
        ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (const xercesc::DOMDocument& d,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
          ::FacebookCpp::XSD::data_getAssociationDefinitions_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociationDefinitions_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociationDefinitions_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociationDefinitions_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response >
    data_getAssociationDefinitions_response_ (xercesc::DOMDocument* d,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociationDefinitions_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociationDefinitions_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociationDefinitions_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociationDefinitions_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (const ::std::string& u,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (::std::istream& is,
                                  const ::std::string& sid,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (xercesc::InputSource& i,
                                  xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (const xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setAssociation_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociation_response (xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (const ::std::string& u,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (::std::istream& is,
                                   const ::std::string& sid,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_setAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (xercesc::InputSource& i,
                                   xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_setAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (const xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_setAssociations_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_setAssociations_response (xercesc::DOMDocument* d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_setAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_setAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociation_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociation_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_removeAssociation_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociation_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociation_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociation_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (const ::std::string& u,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (::std::istream& is,
                                      const ::std::string& sid,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociations_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (xercesc::InputSource& i,
                                      xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociations_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (const xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_removeAssociations_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociations_response (xercesc::DOMDocument* d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (const ::std::string& u,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (const ::std::string& u,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (const ::std::string& u,
                                           xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (::std::istream& is,
                                           const ::std::string& sid,
                                           xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_removeAssociatedObjects_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (xercesc::InputSource& i,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (xercesc::InputSource& i,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (xercesc::InputSource& i,
                                           xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (const xercesc::DOMDocument& d,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::data_removeAssociatedObjects_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociatedObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociatedObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    data_removeAssociatedObjects_response (xercesc::DOMDocument* d,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_removeAssociatedObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_removeAssociatedObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (const ::std::string& u,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (const ::std::string& u,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (const ::std::string& u,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (::std::istream& is,
                                         const ::std::string& sid,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (xercesc::InputSource& i,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (xercesc::InputSource& i,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (xercesc::InputSource& i,
                                         xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (const xercesc::DOMDocument& d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
          ::FacebookCpp::XSD::data_getAssociatedObjects_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociatedObjects_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response >
    data_getAssociatedObjects_response_ (xercesc::DOMDocument* d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjects_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjects_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociatedObjects_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjects_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (const ::std::string& u,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (const ::std::string& u,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (const ::std::string& u,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            const ::std::string& sid,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (::std::istream& is,
                                            const ::std::string& sid,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (xercesc::InputSource& i,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (xercesc::InputSource& i,
                                            ::xml_schema::error_handler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (xercesc::InputSource& i,
                                            xercesc::DOMErrorHandler& h,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::int_ > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (const xercesc::DOMDocument& d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::int_ > r (
          ::FacebookCpp::XSD::data_getAssociatedObjectCount_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjectCount_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::int_ > r (
          new ::xml_schema::int_ (
            ::xsd::cxx::tree::traits< ::xml_schema::int_, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjectCount_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::int_ >
    data_getAssociatedObjectCount_response (xercesc::DOMDocument* d,
                                            ::xml_schema::flags f,
                                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjectCount_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::int_ > r (
          new ::xml_schema::int_ (
            ::xsd::cxx::tree::traits< ::xml_schema::int_, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjectCount_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (const ::std::string& u,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (const ::std::string& u,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (const ::std::string& u,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (::std::istream& is,
                                              const ::std::string& sid,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (xercesc::InputSource& i,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (xercesc::InputSource& i,
                                              ::xml_schema::error_handler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (xercesc::InputSource& i,
                                              xercesc::DOMErrorHandler& h,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
        ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (const xercesc::DOMDocument& d,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
          ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjectCounts_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjectCounts_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response >
    data_getAssociatedObjectCounts_response_ (xercesc::DOMDocument* d,
                                              ::xml_schema::flags f,
                                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociatedObjectCounts_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociatedObjectCounts_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociatedObjectCounts_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (const ::std::string& u,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (::std::istream& is,
                                    const ::std::string& sid,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::data_getAssociations_response_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (xercesc::InputSource& i,
                                    xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
        ::FacebookCpp::XSD::data_getAssociations_response_ (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (const xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
          ::FacebookCpp::XSD::data_getAssociations_response_ (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociations_response, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response >
    data_getAssociations_response_ (xercesc::DOMDocument* d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "data_getAssociations_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::data_getAssociations_response > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::data_getAssociations_response, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "data_getAssociations_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_getAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::FacebookCpp::XSD::admin_getAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::FacebookCpp::XSD::admin_getAppProperties_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "admin_getAppProperties_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "admin_getAppProperties_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::string >
    admin_getAppProperties_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "admin_getAppProperties_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "admin_getAppProperties_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (const ::std::string& u,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (::std::istream& is,
                                     const ::std::string& sid,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::admin_setAppProperties_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (xercesc::InputSource& i,
                                     xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xml_schema::boolean > r (
        ::FacebookCpp::XSD::admin_setAppProperties_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (const xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::boolean > r (
          ::FacebookCpp::XSD::admin_setAppProperties_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "admin_setAppProperties_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "admin_setAppProperties_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::xml_schema::boolean >
    admin_setAppProperties_response (xercesc::DOMDocument* d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "admin_setAppProperties_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::xml_schema::boolean > r (
          new ::xml_schema::boolean (
            ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
              e, f, 0)));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "admin_setAppProperties_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (const ::std::string& u,
                    xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::error_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::error_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::FacebookCpp::XSD::error_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::error_response (isrc, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::error_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (::std::istream& is,
                    const ::std::string& sid,
                    xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::FacebookCpp::XSD::error_response (isrc, h, f, p);
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (xercesc::InputSource& i,
                    xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
        ::FacebookCpp::XSD::error_response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (const xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
          ::FacebookCpp::XSD::error_response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "error_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::FacebookApiException, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "error_response",
        "http://api.facebook.com/1.0/");
    }

    ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException >
    error_response (xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "error_response" &&
          n.namespace_ () == "http://api.facebook.com/1.0/")
      {
        ::std::auto_ptr< ::FacebookCpp::XSD::FacebookApiException > r (
          ::xsd::cxx::tree::traits< ::FacebookCpp::XSD::FacebookApiException, char >::create (
            e, f, 0));
        c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "error_response",
        "http://api.facebook.com/1.0/");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

